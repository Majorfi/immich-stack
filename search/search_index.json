{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Immich Stack","text":"<p>Immich Stack is a Go CLI tool and library for automatically grouping (\"stacking\") similar photos in the Immich photo management system. It provides configurable, robust, and extensible logic for grouping, sorting, and managing photo stacks via the Immich API.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Automatic Stacking: Groups similar photos into stacks based on filename, date, and custom criteria</li> <li>Smart Burst Photo Handling: Automatically detects and properly orders burst photo sequences with the flexible <code>sequence</code> keyword (e.g., Sony's DSCPDC_0001_BURST, Canon's IMG_0001, etc.)</li> <li>Duplicate Detection: Find and list duplicate assets based on filename and timestamp</li> <li>Stack-Aware Trash Management: Fix incomplete trash operations by moving related stack members to trash</li> <li>Multi-User Support: Process multiple users sequentially with comma-separated API keys</li> <li>Configurable Grouping: Custom grouping logic via environment variables and command-line flags</li> <li>Parent/Child Promotion: Fine-grained control over stack parent selection with intelligent sequence detection and the <code>sequence</code> keyword</li> <li>Safe Operations: Dry-run mode, stack replacement, and reset with confirmation</li> <li>Comprehensive Logging: Colorful, structured logs with configurable levels and formats</li> <li>Tested and Modular: Table-driven tests and clear separation of concerns</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation</li> <li>Quick Start</li> <li>Configuration</li> </ul>"},{"location":"#commands","title":"Commands","text":"<ul> <li>Stack Command - Main stacking functionality</li> <li>Duplicates Command - Find duplicate assets</li> <li>Fix-Trash Command - Fix incomplete trash operations</li> </ul>"},{"location":"#features-reference","title":"Features &amp; Reference","text":"<ul> <li>Stacking Logic</li> <li>CLI Usage</li> <li>API Reference</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"architecture/","title":"Architecture Documentation","text":"<p>This document describes the internal architecture, state management, error handling, and technical design decisions of Immich Stack.</p>"},{"location":"architecture/#system-overview","title":"System Overview","text":"<p>Immich Stack is a stateless CLI application that synchronizes photo stacks between computed groupings and the Immich photo management system via its REST API.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   CLI Tool   \u2502 \u2500\u2500\u2500&gt; \u2502 Stacker Logic \u2502 \u2500\u2500\u2500&gt; \u2502  Immich API  \u2502\n\u2502  (Commands)  \u2502      \u2502  (Grouping)   \u2502      \u2502   (Stacks)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                      \u2502                      \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        Configuration\n                    (Criteria, Flags, Env)\n</code></pre>"},{"location":"architecture/#core-components","title":"Core Components","text":"<ol> <li>Command Layer (<code>cmd/</code>): CLI interface and command orchestration</li> <li>Stacker Logic (<code>pkg/stacker/</code>): Grouping algorithm and parent selection</li> <li>API Client (<code>pkg/immich/</code>): HTTP client with retry logic and error handling</li> <li>Utilities (<code>pkg/utils/</code>): Shared types, logging, and helpers</li> </ol>"},{"location":"architecture/#state-management","title":"State Management","text":""},{"location":"architecture/#stateless-design-philosophy","title":"Stateless Design Philosophy","text":"<p>Immich Stack is intentionally stateless between runs:</p> <ul> <li>No persistent database or state files</li> <li>Each run fetches fresh data from Immich API</li> <li>Computed groupings are derived from criteria on each execution</li> <li>No memory of previous runs or decisions</li> </ul>"},{"location":"architecture/#why-stateless","title":"Why Stateless?","text":"<p>Advantages:</p> <ul> <li>Resilient to Immich API changes (always uses current state)</li> <li>Self-healing from transient errors (retry on next run)</li> <li>Consistent with manually created stacks (no drift from external state)</li> <li>No risk of state corruption or inconsistency</li> <li>Simpler to reason about and debug</li> </ul> <p>Trade-offs:</p> <ul> <li>Must re-fetch all data on each run</li> <li>Cannot track incremental progress within a run</li> <li>No built-in idempotency tracking (relies on API state comparison)</li> </ul>"},{"location":"architecture/#state-lifecycle-per-run","title":"State Lifecycle Per Run","text":"<p>Each execution follows this lifecycle:</p> <pre><code>1. Initialize\n   \u251c\u2500 Load configuration (env vars, CLI flags)\n   \u251c\u2500 Create logger\n   \u2514\u2500 Create API client\n\n2. Fetch Current State\n   \u251c\u2500 GET /stacks (all existing stacks)\n   \u2502  \u2514\u2500 Build stacksMap (asset ID \u2192 stack)\n   \u251c\u2500 GET /assets (all assets to process)\n   \u2502  \u2514\u2500 Enrich with stack information\n   \u2514\u2500 GET /me (current user information)\n\n3. Compute Desired State\n   \u251c\u2500 Apply grouping criteria to assets\n   \u251c\u2500 Form groups (potential stacks)\n   \u2514\u2500 Determine parent for each group\n\n4. Compare States\n   \u251c\u2500 Identify new stacks to create\n   \u251c\u2500 Identify stacks to delete\n   \u2514\u2500 Identify stacks to update/replace\n\n5. Apply Changes\n   \u251c\u2500 DELETE /stacks/{id} (remove old stacks)\n   \u251c\u2500 PUT /stacks (create/update stacks)\n   \u2514\u2500 Log all actions\n\n6. Cleanup\n   \u2514\u2500 Exit (no state persisted)\n</code></pre>"},{"location":"architecture/#stack-state-representation","title":"Stack State Representation","text":"<p>Current State (from Immich):</p> <pre><code>type TStack struct {\n    ID             string\n    PrimaryAssetID string\n    Assets         []TAsset\n}\n</code></pre> <p>Desired State (computed):</p> <pre><code>type Group struct {\n    Key    string\n    Assets []TAsset  // First asset is desired parent\n}\n</code></pre>"},{"location":"architecture/#stack-comparison-logic","title":"Stack Comparison Logic","text":"<p>Determines if existing stack matches desired stack:</p> <pre><code>func needsUpdate(existing TStack, desired Group) bool {\n    // Different parent?\n    if existing.PrimaryAssetID != desired.Assets[0].ID {\n        return true\n    }\n\n    // Different asset membership?\n    if !sameAssets(existing.Assets, desired.Assets) {\n        return true\n    }\n\n    return false  // Stack is already correct\n}\n</code></pre>"},{"location":"architecture/#dry-run-verification","title":"Dry-Run Verification","text":""},{"location":"architecture/#how-dry-run-works","title":"How Dry-Run Works","text":"<p>Dry-run mode (<code>DRY_RUN=true</code>) simulates all operations without making API changes:</p> <pre><code>func (c *Client) ModifyStack(assetIDs []string) error {\n    if c.dryRun {\n        c.logger.Info(\"[DRY RUN] Would create stack\")\n        return nil  // No-op, just log\n    }\n\n    // Real API call\n    return c.doRequest(http.MethodPut, \"/stacks\", payload, nil)\n}\n</code></pre>"},{"location":"architecture/#dry-run-guarantees","title":"Dry-Run Guarantees","text":"<ol> <li>No API Writes: Only GET requests executed, no PUT/POST/DELETE</li> <li>Full Simulation: All grouping and comparison logic runs normally</li> <li>Accurate Logging: Shows exactly what would happen in real run</li> <li>Safe Testing: Can test dangerous operations (RESET_STACKS, REPLACE_STACKS)</li> </ol>"},{"location":"architecture/#dry-run-workflow","title":"Dry-Run Workflow","text":"<pre><code>User Request\n    \u2502\n    \u251c\u2500 DRY_RUN=true\n    \u2502   \u251c\u2500 Fetch current state (READ)\n    \u2502   \u251c\u2500 Compute desired state\n    \u2502   \u251c\u2500 Compare states\n    \u2502   \u251c\u2500 Log all planned actions\n    \u2502   \u2514\u2500 Exit (no writes)\n    \u2502\n    \u2514\u2500 DRY_RUN=false\n        \u251c\u2500 Fetch current state (READ)\n        \u251c\u2500 Compute desired state\n        \u251c\u2500 Compare states\n        \u251c\u2500 Execute actions (WRITE)\n        \u2514\u2500 Exit\n</code></pre>"},{"location":"architecture/#verifying-dry-run-output","title":"Verifying Dry-Run Output","text":"<p>Look for these log patterns:</p> <pre><code>[DRY RUN] Would create stack with 3 assets\n[DRY RUN] Would delete stack abc-123-def\n[DRY RUN] Would replace stack xyz-456-uvw\n</code></pre> <p>Real runs show:</p> <pre><code>\u2705 Success! Stack created\n\ud83d\uddd1\ufe0f  Deleted stack abc-123-def - replacing child stack with new one\n\ud83d\udd04 Updated stack xyz-456-uvw\n</code></pre>"},{"location":"architecture/#error-recovery-mechanisms","title":"Error Recovery Mechanisms","text":""},{"location":"architecture/#error-classification","title":"Error Classification","text":"<p>Errors are classified into three categories:</p> <ol> <li> <p>Transient Errors (retry automatically):</p> </li> <li> <p>Network failures (connection timeout, DNS resolution)</p> </li> <li>Server errors (5xx responses)</li> <li> <p>Rate limiting (429 responses)</p> </li> <li> <p>Permanent Errors (fail immediately):</p> </li> <li> <p>Authentication failures (401, 403)</p> </li> <li>Invalid request format (400)</li> <li> <p>Resource not found (404)</p> </li> <li> <p>Application Errors (log and continue):</p> </li> <li> <p>Invalid asset data</p> </li> <li>Criteria parsing errors</li> <li>Individual stack operation failures</li> </ol>"},{"location":"architecture/#error-handling-strategy","title":"Error Handling Strategy","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  API Request   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u251c\u2500 Success (2xx)\n        \u2502  \u2514\u2500&gt; Return data\n        \u2502\n        \u251c\u2500 Transient Error (5xx, timeout, 429)\n        \u2502  \u251c\u2500&gt; Retry with exponential backoff\n        \u2502  \u2514\u2500&gt; Max 3 retries, then fail\n        \u2502\n        \u251c\u2500 Permanent Error (4xx except 429)\n        \u2502  \u2514\u2500&gt; Fail immediately, log error\n        \u2502\n        \u2514\u2500 Application Error\n           \u2514\u2500&gt; Log error, continue processing\n</code></pre>"},{"location":"architecture/#graceful-degradation","title":"Graceful Degradation","text":"<p>When errors occur during processing:</p> <ol> <li>Individual Asset Failure: Skip asset, continue with others</li> <li>Stack Operation Failure: Log error, continue with remaining stacks</li> <li>API Client Failure: Retry automatically, then fail entire run</li> <li>Criteria Parsing Failure: Fail fast (cannot proceed without valid criteria)</li> </ol>"},{"location":"architecture/#recovery-actions","title":"Recovery Actions","text":"<p>For Transient Errors:</p> <ul> <li>Automatic retry with exponential backoff (500ms, 1s, 2s)</li> <li>Log retry attempts for debugging</li> <li>Fail entire operation after max retries</li> </ul> <p>For Permanent Errors:</p> <ul> <li>Log detailed error message with context</li> <li>Provide actionable remediation steps</li> <li>Exit with non-zero status code</li> </ul> <p>For Application Errors:</p> <ul> <li>Log error with asset/stack context</li> <li>Continue processing remaining items</li> <li>Report summary at end of run</li> </ul>"},{"location":"architecture/#api-retry-logic-and-backoff-strategy","title":"API Retry Logic and Backoff Strategy","text":""},{"location":"architecture/#retry-configuration","title":"Retry Configuration","text":"<pre><code>const (\n    maxRetries  = 3\n    baseDelay   = 500 * time.Millisecond\n)\n</code></pre>"},{"location":"architecture/#exponential-backoff","title":"Exponential Backoff","text":"<p>Retry delays follow exponential pattern:</p> <pre><code>Attempt 1: Wait 500ms  (baseDelay \u00d7 2^0)\nAttempt 2: Wait 1s     (baseDelay \u00d7 2^1)\nAttempt 3: Wait 2s     (baseDelay \u00d7 2^2)\nFail: No more retries\n</code></pre>"},{"location":"architecture/#retry-implementation","title":"Retry Implementation","text":"<pre><code>func (c *Client) doRequest(method, path string, body, response interface{}) error {\n    for attempt := 0; attempt &lt; maxRetries; attempt++ {\n        err := c.makeRequest(method, path, body, response)\n\n        if err == nil {\n            return nil  // Success\n        }\n\n        if !isRetriable(err) {\n            return err  // Permanent error, don't retry\n        }\n\n        if attempt &lt; maxRetries-1 {\n            delay := baseDelay * time.Duration(1&lt;&lt;attempt)\n            c.logger.Warnf(\"Retry %d/%d after %v\", attempt+1, maxRetries, delay)\n            time.Sleep(delay)\n        }\n    }\n\n    return fmt.Errorf(\"max retries exceeded\")\n}\n</code></pre>"},{"location":"architecture/#retriable-conditions","title":"Retriable Conditions","text":"<pre><code>func isRetriable(err error) bool {\n    // Network errors\n    if isNetworkError(err) {\n        return true\n    }\n\n    // HTTP status codes\n    if statusCode == 429 {  // Rate limited\n        return true\n    }\n    if statusCode &gt;= 500 &amp;&amp; statusCode &lt; 600 {  // Server errors\n        return true\n    }\n\n    return false  // Client errors (4xx) are not retriable\n}\n</code></pre>"},{"location":"architecture/#backoff-jitter","title":"Backoff Jitter","text":"<p>To prevent thundering herd, random jitter can be added:</p> <pre><code>delay := baseDelay * time.Duration(1&lt;&lt;attempt)\njitter := time.Duration(rand.Int63n(int64(delay / 2)))\ntime.Sleep(delay + jitter)\n</code></pre>"},{"location":"architecture/#rate-limiting-handling","title":"Rate Limiting Handling","text":"<p>When receiving 429 (Too Many Requests):</p> <ol> <li>Check <code>Retry-After</code> header if present</li> <li>Use exponential backoff if header absent</li> <li>Log rate limit event for monitoring</li> <li>Respect server's requested delay</li> </ol>"},{"location":"architecture/#concurrency-handling","title":"Concurrency Handling","text":""},{"location":"architecture/#multi-user-operations","title":"Multi-User Operations","text":"<p>When processing multiple API keys:</p> <pre><code>API_KEY=user1_key,user2_key,user3_key\n</code></pre> <p>Processing is sequential, not concurrent:</p> <pre><code>apiKeys := strings.Split(os.Getenv(\"API_KEY\"), \",\")\n\nfor _, key := range apiKeys {\n    client := immich.NewClient(apiURL, key, ...)\n\n    user, err := client.GetCurrentUser()\n    if err != nil {\n        logger.Errorf(\"Failed for key: %v\", err)\n        continue  // Skip this user, continue with others\n    }\n\n    logger.Infof(\"Processing user: %s\", user.Name)\n\n    // Process stacks for this user\n    if err := processStacks(client); err != nil {\n        logger.Errorf(\"Error for user %s: %v\", user.Name, err)\n        continue\n    }\n}\n</code></pre>"},{"location":"architecture/#why-sequential-processing","title":"Why Sequential Processing?","text":"<p>Design Choice: Sequential processing per user to:</p> <ol> <li>Avoid API Rate Limits: Concurrent requests could exceed limits</li> <li>Maintain Clear Logs: User-by-user logging is easier to follow</li> <li>Prevent Resource Contention: Single HTTP client per user</li> <li>Ensure Isolation: Errors in one user don't affect others</li> </ol>"},{"location":"architecture/#within-user-parallelism","title":"Within-User Parallelism","text":"<p>Within a single user's processing, operations are sequential:</p> <pre><code>Fetch Stacks \u2192 Fetch Assets \u2192 Group Assets \u2192 Apply Changes\n    \u2193             \u2193               \u2193              \u2193\n  Serial        Serial          Serial         Serial\n</code></pre> <p>Rationale:</p> <ul> <li>Stacks depend on assets (must fetch stacks first)</li> <li>Grouping requires all assets (can't parallelize)</li> <li>Stack operations have dependencies (delete before create)</li> </ul>"},{"location":"architecture/#thread-safety","title":"Thread Safety","text":"<p>HTTP client is not shared across goroutines:</p> <pre><code>// Safe: New client per user\nfor _, key := range apiKeys {\n    client := immich.NewClient(...)  // Fresh instance\n    // Use client for this user only\n}\n\n// Unsafe: Sharing client across goroutines\nclient := immich.NewClient(...)\nfor _, key := range apiKeys {\n    go func() {\n        // DON'T DO THIS - not thread-safe\n        client.SetAPIKey(key)\n    }()\n}\n</code></pre>"},{"location":"architecture/#signal-handling","title":"Signal Handling","text":"<p>Graceful shutdown for cron mode:</p> <pre><code>sigChan := make(chan os.Signal, 1)\nsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\ngo func() {\n    &lt;-sigChan\n    logger.Info(\"Received shutdown signal\")\n    shutdownFlag.Set(true)  // Set atomic flag\n}()\n\nfor !shutdownFlag.Get() {\n    runStacker()\n    time.Sleep(cronInterval)\n}\n</code></pre>"},{"location":"architecture/#api-client-architecture","title":"API Client Architecture","text":""},{"location":"architecture/#http-client-configuration","title":"HTTP Client Configuration","text":"<pre><code>client := &amp;http.Client{\n    Timeout: 600 * time.Second,  // 10 minutes\n    Transport: &amp;http.Transport{\n        MaxIdleConns:        100,\n        MaxIdleConnsPerHost: 100,\n        IdleConnTimeout:     90 * time.Second,\n    },\n}\n</code></pre>"},{"location":"architecture/#requestresponse-flow","title":"Request/Response Flow","text":"<pre><code>1. Build Request\n   \u251c\u2500 Set method (GET, POST, PUT, DELETE)\n   \u251c\u2500 Build URL (baseURL + path)\n   \u251c\u2500 Marshal JSON body (if present)\n   \u251c\u2500 Set headers (Content-Type, x-api-key)\n   \u2514\u2500 Create http.Request\n\n2. Execute Request (with retries)\n   \u251c\u2500 Attempt 1: Send request\n   \u2502  \u251c\u2500 Success? Return response\n   \u2502  \u2514\u2500 Retriable error? Continue\n   \u251c\u2500 Wait with exponential backoff\n   \u251c\u2500 Attempt 2: Send request\n   \u2502  \u2514\u2500 ...\n   \u2514\u2500 Attempt 3: Send request\n      \u2514\u2500 Fail if still erroring\n\n3. Handle Response\n   \u251c\u2500 Check status code\n   \u251c\u2500 Read response body\n   \u251c\u2500 Unmarshal JSON (if expected)\n   \u2514\u2500 Return data or error\n</code></pre>"},{"location":"architecture/#connection-pooling","title":"Connection Pooling","text":"<p>Benefits of connection pooling:</p> <ul> <li>Reduced Latency: Reuse existing TCP connections</li> <li>Lower Overhead: Avoid handshake for each request</li> <li>Better Performance: Especially for many small requests</li> </ul> <p>Configuration:</p> <pre><code>MaxIdleConns: 100          // Total idle connections across all hosts\nMaxIdleConnsPerHost: 100   // Idle connections per host\nIdleConnTimeout: 90s       // Close idle connections after 90s\n</code></pre>"},{"location":"architecture/#grouping-algorithm","title":"Grouping Algorithm","text":""},{"location":"architecture/#high-level-flow","title":"High-Level Flow","text":"<pre><code>Assets (unsorted) \u2192 Group By Criteria \u2192 Sort Within Groups \u2192 Stacks\n</code></pre>"},{"location":"architecture/#grouping-process","title":"Grouping Process","text":"<ol> <li>Initialize Empty Groups:</li> </ol> <pre><code>groups := make(map[string][]TAsset)\n</code></pre> <ol> <li>Iterate All Assets:</li> </ol> <pre><code>for _, asset := range assets {\n    key := computeGroupKey(asset, criteria)\n    groups[key] = append(groups[key], asset)\n}\n</code></pre> <ol> <li>Compute Group Key:</li> </ol> <pre><code>func computeGroupKey(asset TAsset, criteria []Criterion) string {\n    keys := []string{}\n    for _, crit := range criteria {\n        switch crit.Key {\n        case \"originalFileName\":\n            keys = append(keys, extractFilename(asset, crit))\n        case \"localDateTime\":\n            keys = append(keys, formatTime(asset, crit))\n        // ... other criteria\n        }\n    }\n    return strings.Join(keys, \"|\")\n}\n</code></pre>"},{"location":"architecture/#parent-selection-within-group","title":"Parent Selection Within Group","text":"<ol> <li>Sort Group by Promotion Rules:</li> </ol> <pre><code>sort.Slice(group, func(i, j int) bool {\n    return compareByPromotionRules(group[i], group[j])\n})\n</code></pre> <ol> <li>Promotion Rule Precedence:</li> </ol> <pre><code>1. PARENT_FILENAME_PROMOTE list order (left to right)\n2. PARENT_EXT_PROMOTE list order (left to right)\n3. Built-in extension rank (.jpeg &gt; .jpg &gt; .png &gt; others)\n4. Alphabetical order (case-insensitive)\n5. Local date/time (earliest first)\n6. Asset ID (lexicographic)\n</code></pre> <ol> <li>First Asset Becomes Parent:</li> </ol> <pre><code>parent := group[0]\nchildren := group[1:]\n</code></pre>"},{"location":"architecture/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"architecture/#time-complexity","title":"Time Complexity","text":"<ul> <li>Fetching Assets: O(n) where n = total assets</li> <li>Grouping: O(n \u00d7 m) where m = number of criteria</li> <li>Sorting Groups: O(k \u00d7 g log g) where k = number of groups, g = avg group size</li> <li>Creating Stacks: O(k) API calls</li> <li>Overall: O(n \u00d7 m + k \u00d7 g log g)</li> </ul>"},{"location":"architecture/#space-complexity","title":"Space Complexity","text":"<ul> <li>Assets: O(n) - all assets stored in memory</li> <li>Groups: O(n) - assets distributed across groups</li> <li>Stacks Map: O(s) where s = number of existing stacks</li> <li>Overall: O(n)</li> </ul>"},{"location":"architecture/#bottlenecks","title":"Bottlenecks","text":"<ol> <li>Network I/O: Fetching large asset lists from API</li> <li>Regex Evaluation: Complex patterns on every asset</li> <li>JSON Marshaling: Large payloads for stack operations</li> <li>Memory: Large libraries (100k+ assets) can consume 1-2GB</li> </ol>"},{"location":"architecture/#optimization-strategies","title":"Optimization Strategies","text":"<ul> <li>Use simple criteria (Legacy mode) for large libraries</li> <li>Increase time deltas to reduce group count</li> <li>Optimize regex patterns (anchors, no wildcards)</li> <li>Filter assets with WITH_ARCHIVED/WITH_DELETED</li> <li>Process in batches for very large libraries</li> </ul>"},{"location":"architecture/#logging-architecture","title":"Logging Architecture","text":""},{"location":"architecture/#log-levels","title":"Log Levels","text":"<pre><code>trace   // Very detailed (e.g., HTTP request/response bodies)\ndebug   // Detailed (e.g., parent selection decisions)\ninfo    // Standard (e.g., stack created, assets processed)\nwarn    // Warnings (e.g., retries, unexpected conditions)\nerror   // Errors (e.g., API failures, invalid config)\n</code></pre>"},{"location":"architecture/#structured-logging","title":"Structured Logging","text":"<p>Using logrus for structured logs:</p> <pre><code>logger.WithFields(logrus.Fields{\n    \"assetID\": asset.ID,\n    \"filename\": asset.OriginalFileName,\n    \"stackID\": stack.ID,\n}).Info(\"Stack created\")\n</code></pre>"},{"location":"architecture/#log-formats","title":"Log Formats","text":"<p>Text Format (human-readable):</p> <pre><code>level=info msg=\"Stack created\" assetID=abc-123 filename=IMG_1234.jpg\n</code></pre> <p>JSON Format (machine-parseable):</p> <pre><code>{\n  \"level\": \"info\",\n  \"msg\": \"Stack created\",\n  \"assetID\": \"abc-123\",\n  \"filename\": \"IMG_1234.jpg\",\n  \"time\": \"2025-11-12T10:30:00Z\"\n}\n</code></pre>"},{"location":"architecture/#dual-logging","title":"Dual Logging","text":"<p>When LOG_FILE is set:</p> <pre><code>if logFile != \"\" {\n    file, err := os.OpenFile(logFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)\n    if err == nil {\n        logger.SetOutput(io.MultiWriter(os.Stdout, file))\n    } else {\n        // Fallback to stdout only\n        logger.Warn(\"Could not open log file, using stdout only\")\n    }\n}\n</code></pre>"},{"location":"architecture/#testing-architecture","title":"Testing Architecture","text":""},{"location":"architecture/#test-structure","title":"Test Structure","text":"<pre><code>pkg/\n\u251c\u2500 stacker/\n\u2502  \u251c\u2500 stacker.go          # Implementation\n\u2502  \u251c\u2500 stacker_test.go     # Unit tests\n\u2502  \u2514\u2500 stacker_integration_test.go  # Integration tests\n\u2502\n\u2514\u2500 immich/\n   \u251c\u2500 client.go           # API client\n   \u2514\u2500 client_test.go      # Mock API tests\n</code></pre>"},{"location":"architecture/#test-categories","title":"Test Categories","text":"<ol> <li>Unit Tests: Test individual functions in isolation</li> <li>Integration Tests: Test component interactions</li> <li>Mock Tests: Test API client with mock HTTP server</li> </ol>"},{"location":"architecture/#testing-best-practices","title":"Testing Best Practices","text":"<ul> <li>Use table-driven tests for multiple scenarios</li> <li>Mock external dependencies (API, filesystem)</li> <li>Test edge cases (empty groups, single-asset stacks)</li> <li>Verify error handling paths</li> <li>Check log output for correct messages</li> </ul>"},{"location":"architecture/#security-considerations","title":"Security Considerations","text":""},{"location":"architecture/#api-key-handling","title":"API Key Handling","text":"<ul> <li>Never log API keys (sanitize in logs)</li> <li>Store keys in environment variables, not files</li> <li>Support multiple keys for multi-user scenarios</li> <li>Validate key format before use</li> </ul>"},{"location":"architecture/#input-validation","title":"Input Validation","text":"<ul> <li>Validate all user inputs (criteria, env vars)</li> <li>Sanitize regex patterns to prevent ReDoS</li> <li>Check for SQL injection in any database queries</li> <li>Validate file paths for log files</li> </ul>"},{"location":"architecture/#network-security","title":"Network Security","text":"<ul> <li>Use HTTPS for API calls (validate TLS)</li> <li>Set reasonable timeouts to prevent DoS</li> <li>Implement rate limiting respect</li> <li>Handle redirects securely</li> </ul>"},{"location":"architecture/#future-architecture-considerations","title":"Future Architecture Considerations","text":""},{"location":"architecture/#potential-improvements","title":"Potential Improvements","text":"<ol> <li>Incremental Processing: Track processed assets to skip on subsequent runs</li> <li>Parallel API Calls: Concurrent fetching/updating with proper throttling</li> <li>Persistent Cache: Cache asset metadata to reduce API calls</li> <li>Batch Optimization: Group stack operations into larger batches</li> <li>Streaming Processing: Process assets in streaming fashion for very large libraries</li> </ol>"},{"location":"architecture/#scalability-limits","title":"Scalability Limits","text":"<p>Current architecture scales to:</p> <ul> <li>Assets: ~200k (limited by memory)</li> <li>Stacks: ~50k (limited by API response size)</li> <li>Users: Unlimited (sequential processing)</li> <li>API Calls: Respects rate limits with exponential backoff</li> </ul>"},{"location":"architecture/#extension-points","title":"Extension Points","text":"<p>Areas designed for extension:</p> <ul> <li>New Criteria Types: Add to criteria.go</li> <li>Custom Comparison Logic: Extend grouping algorithm</li> <li>Additional Commands: Add to cmd/ directory</li> <li>Alternative APIs: Implement new client interface</li> </ul>"},{"location":"development/","title":"Development Guide","text":"<p>This guide helps you set up and contribute to Immich Stack development.</p>"},{"location":"development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.21 or later</li> <li>Docker and Docker Compose</li> <li>Make (optional, for using Makefile)</li> </ul>"},{"location":"development/#setup","title":"Setup","text":"<ol> <li>Clone the repository</li> </ol> <pre><code>git clone https://github.com/majorfi/immich-stack.git\ncd immich-stack\n</code></pre> <ol> <li>Install dependencies</li> </ol> <pre><code>go mod download\n</code></pre> <ol> <li>Create development environment</li> </ol> <pre><code>cp .env.example .env\n</code></pre>"},{"location":"development/#development-workflow","title":"Development Workflow","text":""},{"location":"development/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\ngo test ./...\n\n# Run specific test\ngo test ./internal/stack\n\n# Run with coverage\ngo test -cover ./...\n</code></pre>"},{"location":"development/#building","title":"Building","text":"<pre><code># Build binary\ngo build -o immich-stack\n\n# Build for specific platform\nGOOS=linux GOARCH=amd64 go build -o immich-stack\n</code></pre>"},{"location":"development/#docker-development","title":"Docker Development","text":"<pre><code># Build development image\ndocker build -t immich-stack:dev .\n\n# Run development container\ndocker run -it --rm \\\n  --name immich-stack-dev \\\n  --env-file .env \\\n  -v $(pwd):/app \\\n  immich-stack:dev\n</code></pre>"},{"location":"development/#code-structure","title":"Code Structure","text":"<pre><code>.\n\u251c\u2500\u2500 cmd/                    # Command-line interface\n\u2502   \u2514\u2500\u2500 main.go            # Entry point\n\u251c\u2500\u2500 internal/              # Internal packages\n\u2502   \u251c\u2500\u2500 asset/            # Asset operations\n\u2502   \u251c\u2500\u2500 grouping/         # Grouping logic\n\u2502   \u2514\u2500\u2500 stack/            # Stack operations\n\u251c\u2500\u2500 pkg/                   # Public packages\n\u2502   \u251c\u2500\u2500 immich/           # Immich API client\n\u2502   \u251c\u2500\u2500 stacker/          # Stacking logic\n\u2502   \u2514\u2500\u2500 utils/            # Utility functions\n\u2514\u2500\u2500 docs/                 # Documentation\n</code></pre>"},{"location":"development/#coding-standards","title":"Coding Standards","text":""},{"location":"development/#go-code","title":"Go Code","text":"<ol> <li> <p>Formatting</p> </li> <li> <p>Use <code>go fmt</code></p> </li> <li>Follow Go standard formatting</li> <li> <p>Use <code>gofmt</code> for consistency</p> </li> <li> <p>Documentation</p> </li> <li> <p>Document all exported functions</p> </li> <li>Include examples where helpful</li> <li> <p>Follow Go doc conventions</p> </li> <li> <p>Testing</p> </li> <li> <p>Write unit tests</p> </li> <li>Use table-driven tests</li> <li>Test edge cases</li> </ol>"},{"location":"development/#error-handling","title":"Error Handling","text":"<ol> <li>Error Types</li> </ol> <pre><code>type StackError struct {\n    Code    string\n    Message string\n    Err     error\n}\n</code></pre> <ol> <li>Error Wrapping</li> </ol> <pre><code>return nil, fmt.Errorf(\"failed to create stack: %w\", err)\n</code></pre> <ol> <li>Error Checking</li> </ol> <pre><code>if err != nil {\n    return nil, err\n}\n</code></pre>"},{"location":"development/#contributing","title":"Contributing","text":"<ol> <li> <p>Fork and Clone</p> </li> <li> <p>Fork the repository</p> </li> <li>Clone your fork</li> <li> <p>Create a feature branch</p> </li> <li> <p>Development</p> </li> <li> <p>Write code</p> </li> <li>Add tests</li> <li> <p>Update documentation</p> </li> <li> <p>Testing</p> </li> <li> <p>Run all tests</p> </li> <li>Check formatting</li> <li> <p>Verify documentation</p> </li> <li> <p>Pull Request</p> </li> <li> <p>Push changes</p> </li> <li>Create pull request</li> <li>Wait for review</li> </ol>"},{"location":"development/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Code Quality</p> </li> <li> <p>Write clean, readable code</p> </li> <li>Follow Go best practices</li> <li> <p>Use meaningful names</p> </li> <li> <p>Testing</p> </li> <li> <p>Write comprehensive tests</p> </li> <li>Test edge cases</li> <li> <p>Maintain test coverage</p> </li> <li> <p>Documentation</p> </li> <li> <p>Keep docs up to date</p> </li> <li>Add examples</li> <li> <p>Document changes</p> </li> <li> <p>Performance</p> </li> <li> <p>Profile code</p> </li> <li>Optimize bottlenecks</li> <li>Consider memory usage</li> </ol>"},{"location":"development/#release-process","title":"Release Process","text":"<ol> <li> <p>Versioning</p> </li> <li> <p>Follow semantic versioning</p> </li> <li>Update version in code</li> <li> <p>Tag releases</p> </li> <li> <p>Building</p> </li> <li> <p>Build for all platforms</p> </li> <li>Create Docker images</li> <li> <p>Sign releases</p> </li> <li> <p>Deployment</p> </li> <li> <p>Push to registries</p> </li> <li>Update documentation</li> <li>Announce release</li> </ol>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide helps you resolve common issues with Immich Stack.</p>"},{"location":"troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"troubleshooting/#api-connection-issues","title":"API Connection Issues","text":"<p>Symptoms:</p> <ul> <li>\"Failed to connect to Immich API\"</li> <li>\"API request failed\"</li> <li>\"Invalid API key\"</li> </ul> <p>Solutions:</p> <ol> <li>Verify API URL is correct    <pre><code>API_URL=http://immich-server:2283/api\n</code></pre></li> <li>Check API key validity    <pre><code>API_KEY=your_valid_api_key\n</code></pre></li> <li>Ensure network connectivity    <pre><code>curl -I http://immich-server:2283/api\n</code></pre></li> </ol>"},{"location":"troubleshooting/#stack-creation-issues","title":"Stack Creation Issues","text":"<p>Symptoms:</p> <ul> <li>\"Failed to create stack\"</li> <li>\"Invalid stack data\"</li> <li>\"Stack already exists\"</li> </ul> <p>Solutions:</p> <ol> <li>Enable dry run mode to test    <pre><code>DRY_RUN=true\n</code></pre></li> <li>Check stack criteria    <pre><code>CRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\"~\",\".\"],\"index\":0}}]'\n</code></pre></li> <li>Verify asset data    <pre><code>WITH_ARCHIVED=true\nWITH_DELETED=false\n</code></pre></li> </ol>"},{"location":"troubleshooting/#grouping-issues","title":"Grouping Issues","text":"<p>Symptoms:</p> <ul> <li>\"Invalid grouping criteria\"</li> <li>\"No assets grouped\"</li> <li>\"Unexpected grouping results\"</li> </ul> <p>Solutions:</p> <ol> <li>Review criteria configuration    <pre><code>CRITERIA='[{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]'\n</code></pre></li> <li>Check parent selection    <pre><code>PARENT_FILENAME_PROMOTE=edit,raw\nPARENT_EXT_PROMOTE=.jpg,.dng\n</code></pre></li> <li>Enable debug logging    <pre><code>LOG_LEVEL=debug\n</code></pre></li> </ol>"},{"location":"troubleshooting/#infinite-re-stacking-loop-issue-35","title":"Infinite Re-stacking Loop (Issue #35)","text":"<p>Fixed in: Commit 2c3a75a (November 1, 2025)</p> <p>Symptoms:</p> <ul> <li>Same assets processed repeatedly across runs</li> <li>Different queue positions for same asset IDs (e.g., 338/4275, then 772/4278)</li> <li>False \"Success! Stack created\" messages for stacks that already exist</li> <li>Cron mode infinite loop on same subset of photos</li> <li>No progress through entire photo library</li> <li>Stack count remains static across runs</li> </ul> <p>Root Cause:</p> <p>The stacksMap only indexed PRIMARY assets of each stack, not all child assets. When checking if an asset was already stacked, child assets were not found, causing the tool to repeatedly attempt to restack them.</p> <p>Resolution:</p> <p>The fix changed stack indexing from:</p> <pre><code>// Old: Only indexed primary asset\nstacksMap[stack.PrimaryAssetID] = stack\n</code></pre> <p>To:</p> <pre><code>// New: Index ALL assets in the stack\nfor _, asset := range stack.Assets {\n    stacksMap[asset.ID] = stack\n}\n</code></pre> <p>Verification:</p> <p>If you experienced this issue, update to the latest version and verify:</p> <ol> <li>Check logs no longer show same asset IDs repeatedly</li> <li>Stack count should increase steadily across runs</li> <li>Queue positions should progress sequentially</li> <li>\"Success! Stack created\" should only appear for genuinely new stacks</li> </ol> <p>Affected Users:</p> <ul> <li>Large libraries (50k+ assets)</li> <li>Google Pixel camera files (RAW-01.COVER.jpg / RAW-02.ORIGINAL.dng patterns)</li> <li>Users running in cron mode with frequent intervals</li> </ul> <p>Related:</p> <ul> <li>GitHub Issue: #35</li> <li>Commit: 2c3a75a</li> </ul>"},{"location":"troubleshooting/#burst-photo-ordering-issues","title":"Burst Photo Ordering Issues","text":"<p>Symptoms:</p> <ul> <li>Burst photos not ordered correctly (e.g., 0000, 0002, 0003, 0001 instead of 0000, 0001, 0002, 0003)</li> <li>Numeric promote strings matching in wrong places (e.g., \"0001\" matching in timestamps)</li> <li>Need to handle sequences with varying number of digits (1, 10, 100)</li> </ul> <p>Solutions:</p> <ol> <li>Use the <code>sequence</code> keyword for flexible sequence handling (Recommended)</li> </ol> <pre><code># Order any numeric sequence regardless of digits\nPARENT_FILENAME_PROMOTE=sequence\n\n# Prioritize COVER files, then order by sequence\nPARENT_FILENAME_PROMOTE=COVER,sequence\n\n# Only match 4-digit sequences (0001, 0002, etc.)\nPARENT_FILENAME_PROMOTE=sequence:4\n\n# Only match sequences with specific prefix\nPARENT_FILENAME_PROMOTE=sequence:IMG_\n</code></pre> <ol> <li>Use comma-separated numeric sequences for burst photos (Legacy)</li> </ol> <pre><code>PARENT_FILENAME_PROMOTE=0000,0001,0002,0003\n</code></pre> <p>The system will automatically detect this as a sequence and order photos correctly.</p> <ol> <li>The sequence detection works with various patterns:</li> </ol> <pre><code># Pure numbers\nPARENT_FILENAME_PROMOTE=0000,0001,0002,0003\n\n# Prefixed numbers\nPARENT_FILENAME_PROMOTE=IMG_0001,IMG_0002,IMG_0003\n\n# Suffixed numbers\nPARENT_FILENAME_PROMOTE=1a,2a,3a\n</code></pre> <ol> <li> <p>Files with numbers beyond your promote list are handled automatically:</p> </li> <li> <p>If you specify <code>0000,0001,0002,0003</code> but have files up to <code>0999</code>, they will be sorted correctly at position 999</p> </li> <li> <p>Understanding <code>sequence:X</code> behavior:</p> </li> <li> <p><code>sequence</code> - Matches any numeric sequence (1, 2, 10, 100, etc.)</p> </li> <li><code>sequence:4</code> - Matches ONLY 4-digit numbers (0001, 0002, not 1, 10, 100)</li> <li><code>sequence:IMG_</code> - Matches only files with IMG_ prefix followed by numbers</li> </ol>"},{"location":"troubleshooting/#stack-recovery-procedures","title":"Stack Recovery Procedures","text":"<p>When to Use:</p> <ul> <li>After failed stack operations</li> <li>When migrating between criteria</li> <li>After database issues</li> <li>When cleaning up corrupted stacks</li> </ul> <p>Complete Stack Reset:</p> <pre><code># CAUTION: This will delete ALL existing stacks\nRUN_MODE=once\nRESET_STACKS=true\nCONFIRM_RESET_STACK=\"I acknowledge all my current stacks will be deleted and new one will be created\"\n\n# Run the stacker\n./immich-stack\n</code></pre> <p>Important Notes:</p> <ul> <li>RESET_STACKS only works with RUN_MODE=once</li> <li>Using RESET_STACKS in cron mode results in an error</li> <li>Confirmation text must match exactly</li> <li>Always test with DRY_RUN=true first</li> </ul> <p>Recovering from Partial Failures:</p> <ol> <li>Enable replace stacks mode to fix existing stacks:</li> </ol> <pre><code>REPLACE_STACKS=true\nDRY_RUN=false\n</code></pre> <ol> <li>Remove single-asset stacks (cleanup):</li> </ol> <pre><code>REMOVE_SINGLE_ASSET_STACKS=true\n</code></pre> <ol> <li>Process incrementally with filters:</li> </ol> <pre><code>WITH_ARCHIVED=false\nWITH_DELETED=false\n</code></pre> <p>Safe Recovery Workflow:</p> <ol> <li>First, run in dry-run mode to preview changes:</li> </ol> <pre><code>DRY_RUN=true\nREPLACE_STACKS=true\nLOG_LEVEL=debug\n</code></pre> <ol> <li> <p>Review the logs carefully to verify expected behavior</p> </li> <li> <p>Execute the actual operation:</p> </li> </ol> <pre><code>DRY_RUN=false\nREPLACE_STACKS=true\n</code></pre> <ol> <li>Monitor logs for errors:</li> </ol> <pre><code>docker logs -f immich-stack\n</code></pre> <p>Rolling Back Changes:</p> <p>If you need to revert to a previous state:</p> <ol> <li>Use Immich database backups (if available)</li> <li>Run complete reset with previous criteria configuration</li> <li>Manually adjust stacks via Immich UI for specific cases</li> </ol>"},{"location":"troubleshooting/#cron-mode-issues","title":"Cron Mode Issues","text":"<p>Symptoms:</p> <ul> <li>\"Cron job not running\"</li> <li>\"Invalid interval\"</li> <li>\"Unexpected execution\"</li> </ul> <p>Solutions:</p> <ol> <li>Verify run mode    <pre><code>RUN_MODE=cron\n</code></pre></li> <li>Check interval setting    <pre><code>CRON_INTERVAL=3600\n</code></pre></li> <li>Monitor logs    <pre><code>LOG_LEVEL=debug\nLOG_FORMAT=json\n</code></pre></li> </ol>"},{"location":"troubleshooting/#debugging","title":"Debugging","text":""},{"location":"troubleshooting/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>LOG_LEVEL=debug\nLOG_FORMAT=json\n</code></pre>"},{"location":"troubleshooting/#check-logs","title":"Check Logs","text":"<pre><code># View logs\ndocker logs immich-stack\n\n# Follow logs\ndocker logs -f immich-stack\n</code></pre>"},{"location":"troubleshooting/#test-configuration","title":"Test Configuration","text":"<ol> <li>Use dry run mode</li> </ol> <pre><code>DRY_RUN=true\n</code></pre> <ol> <li>Test with minimal criteria</li> </ol> <pre><code>CRITERIA='[{\"key\":\"originalFileName\"}]'\n</code></pre> <ol> <li>Verify API connection</li> </ol> <pre><code>curl -I $API_URL\n</code></pre>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#high-memory-usage","title":"High Memory Usage","text":"<p>Solutions:</p> <ol> <li>Process fewer assets at once</li> <li>Use more specific criteria</li> <li>Enable pagination</li> </ol>"},{"location":"troubleshooting/#slow-processing","title":"Slow Processing","text":"<p>Solutions:</p> <ol> <li>Optimize criteria</li> <li>Use appropriate delta values</li> <li>Consider batch processing</li> </ol>"},{"location":"troubleshooting/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Testing</p> </li> <li> <p>Always use dry run mode first</p> </li> <li>Test with small asset sets</li> <li> <p>Verify criteria before production</p> </li> <li> <p>Monitoring</p> </li> <li> <p>Enable debug logging</p> </li> <li>Monitor resource usage</li> <li> <p>Check operation results</p> </li> <li> <p>Maintenance</p> </li> <li> <p>Regular stack cleanup</p> </li> <li>API key rotation</li> <li> <p>Configuration review</p> </li> <li> <p>Security</p> </li> <li> <p>Secure API keys</p> </li> <li>Regular updates</li> <li>Access control</li> </ol>"},{"location":"api-reference/asset-operations/","title":"Asset Operations","text":"<p>The asset operations are implemented in <code>internal/asset/asset.go</code>.</p>"},{"location":"api-reference/asset-operations/#asset-structure","title":"Asset Structure","text":"<pre><code>type Asset struct {\n    ID              string    `json:\"id\"`\n    DeviceAssetID   string    `json:\"deviceAssetId\"`\n    OwnerID         string    `json:\"ownerId\"`\n    DeviceID        string    `json:\"deviceId\"`\n    Type            string    `json:\"type\"`\n    OriginalPath    string    `json:\"originalPath\"`\n    OriginalFileName string   `json:\"originalFileName\"`\n    Resized         bool      `json:\"resized\"`\n    FileCreatedAt   time.Time `json:\"fileCreatedAt\"`\n    FileModifiedAt  time.Time `json:\"fileModifiedAt\"`\n    UpdatedAt       time.Time `json:\"updatedAt\"`\n    IsFavorite      bool      `json:\"isFavorite\"`\n    IsArchived      bool      `json:\"isArchived\"`\n    IsReadOnly      bool      `json:\"isReadOnly\"`\n    Duration        string    `json:\"duration\"`\n    ExifInfo        ExifInfo  `json:\"exifInfo\"`\n}\n</code></pre>"},{"location":"api-reference/asset-operations/#available-operations","title":"Available Operations","text":""},{"location":"api-reference/asset-operations/#list-assets","title":"List Assets","text":"<pre><code>func ListAssets(ctx context.Context, client *immich.Client, options *ListOptions) ([]Asset, error)\n</code></pre> <p>Lists assets with optional filtering.</p> <p>Parameters:</p> <ul> <li><code>ctx</code>: Context for the operation</li> <li><code>client</code>: Immich API client</li> <li><code>options</code>: List options (filters, pagination, etc.)</li> </ul> <p>Returns:</p> <ul> <li><code>[]Asset</code>: Array of assets</li> <li><code>error</code>: Any error that occurred</li> </ul>"},{"location":"api-reference/asset-operations/#get-asset","title":"Get Asset","text":"<pre><code>func GetAsset(ctx context.Context, client *immich.Client, assetID string) (*Asset, error)\n</code></pre> <p>Retrieves a single asset by ID.</p> <p>Parameters:</p> <ul> <li><code>ctx</code>: Context for the operation</li> <li><code>client</code>: Immich API client</li> <li><code>assetID</code>: ID of the asset to retrieve</li> </ul> <p>Returns:</p> <ul> <li><code>*Asset</code>: Retrieved asset</li> <li><code>error</code>: Any error that occurred</li> </ul>"},{"location":"api-reference/asset-operations/#update-asset","title":"Update Asset","text":"<pre><code>func UpdateAsset(ctx context.Context, client *immich.Client, asset *Asset) error\n</code></pre> <p>Updates an existing asset.</p> <p>Parameters:</p> <ul> <li><code>ctx</code>: Context for the operation</li> <li><code>client</code>: Immich API client</li> <li><code>asset</code>: Asset to update</li> </ul> <p>Returns:</p> <ul> <li><code>error</code>: Any error that occurred</li> </ul>"},{"location":"api-reference/asset-operations/#delete-asset","title":"Delete Asset","text":"<pre><code>func DeleteAsset(ctx context.Context, client *immich.Client, assetID string) error\n</code></pre> <p>Deletes an asset by ID.</p> <p>Parameters:</p> <ul> <li><code>ctx</code>: Context for the operation</li> <li><code>client</code>: Immich API client</li> <li><code>assetID</code>: ID of the asset to delete</li> </ul> <p>Returns:</p> <ul> <li><code>error</code>: Any error that occurred</li> </ul>"},{"location":"api-reference/asset-operations/#list-options","title":"List Options","text":"<pre><code>type ListOptions struct {\n    IsArchived *bool\n    IsFavorite *bool\n    Skip       int\n    Take       int\n}\n</code></pre>"},{"location":"api-reference/asset-operations/#error-handling","title":"Error Handling","text":"<p>All operations handle the following error cases:</p> <ul> <li>Invalid asset ID</li> <li>Asset not found</li> <li>API errors</li> <li>Network errors</li> <li>Invalid asset data</li> </ul>"},{"location":"api-reference/asset-operations/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Error Handling</p> </li> <li> <p>Always check returned errors</p> </li> <li>Use appropriate error handling strategies</li> <li> <p>Log errors for debugging</p> </li> <li> <p>Context Usage</p> </li> <li> <p>Pass context through all operations</p> </li> <li>Use context for cancellation</li> <li> <p>Set appropriate timeouts</p> </li> <li> <p>Asset Filtering</p> </li> <li> <p>Use appropriate filters</p> </li> <li>Handle pagination properly</li> <li> <p>Consider performance implications</p> </li> <li> <p>Asset Updates</p> </li> <li> <p>Validate changes before updating</p> </li> <li>Handle conflicts gracefully</li> <li>Maintain data consistency</li> </ol>"},{"location":"api-reference/asset-operations/#example-usage","title":"Example Usage","text":"<pre><code>// List assets with filters\noptions := &amp;ListOptions{\n    IsArchived: &amp;false,\n    IsFavorite: &amp;true,\n    Take:       100,\n}\nassets, err := ListAssets(ctx, client, options)\nif err != nil {\n    log.Printf(\"Error listing assets: %v\", err)\n    return\n}\n\n// Get single asset\nasset, err := GetAsset(ctx, client, \"asset-id\")\nif err != nil {\n    log.Printf(\"Error getting asset: %v\", err)\n    return\n}\n\n// Update asset\nasset.IsFavorite = true\nerr = UpdateAsset(ctx, client, asset)\nif err != nil {\n    log.Printf(\"Error updating asset: %v\", err)\n    return\n}\n\n// Delete asset\nerr = DeleteAsset(ctx, client, \"asset-id\")\nif err != nil {\n    log.Printf(\"Error deleting asset: %v\", err)\n    return\n}\n</code></pre>"},{"location":"api-reference/cli-usage/","title":"CLI Usage","text":"<p>The main entrypoint is <code>cmd/main.go</code>, which provides a Cobra-based CLI with multiple commands.</p>"},{"location":"api-reference/cli-usage/#command-structure","title":"Command Structure","text":"<pre><code>immich-stack [command] [flags]\n</code></pre>"},{"location":"api-reference/cli-usage/#available-commands","title":"Available Commands","text":"<ul> <li>(default) - Main stacking functionality (when no command is specified)</li> <li><code>duplicates</code> - Find and list duplicate assets</li> <li><code>fix-trash</code> - Fix incomplete trash operations for stacks</li> <li><code>help</code> - Display help information</li> </ul>"},{"location":"api-reference/cli-usage/#basic-usage","title":"Basic Usage","text":"<pre><code># Run the main stacking command\n./immich-stack --api-key your_key --api-url http://immich:2283\n\n# Run duplicates command\n./immich-stack duplicates --api-key your_key\n\n# Run fix-trash command\n./immich-stack fix-trash --api-key your_key\n\n# Get help\n./immich-stack --help\n\n# Get help for a specific command\n./immich-stack duplicates --help\n</code></pre>"},{"location":"api-reference/cli-usage/#command-line-flags","title":"Command Line Flags","text":""},{"location":"api-reference/cli-usage/#global-flags-all-commands","title":"Global Flags (All Commands)","text":"Flag Env Var Description <code>--api-key</code> <code>API_KEY</code> Immich API key (comma-separated for multiple) <code>--api-url</code> <code>API_URL</code> Immich API base URL <code>--log-level</code> <code>LOG_LEVEL</code> Log verbosity: debug, info, warn, error <code>--log-format</code> <code>LOG_FORMAT</code> Log format: text or json"},{"location":"api-reference/cli-usage/#stack-command-flags","title":"Stack Command Flags","text":"Flag Env Var Description <code>--reset-stacks</code> <code>RESET_STACKS</code> Delete all existing stacks before processing (only in <code>RUN_MODE=once</code>) <code>--confirm-reset-stack</code> <code>CONFIRM_RESET_STACK</code> Required for RESET_STACKS. Must be set to: 'I acknowledge all my current stacks will be deleted and new one will be created' <code>--replace-stacks</code> <code>REPLACE_STACKS</code> Replace stacks for new groups <code>--dry-run</code> <code>DRY_RUN</code> Simulate actions without making changes <code>--criteria</code> <code>CRITERIA</code> Custom grouping criteria <code>--parent-filename-promote</code> <code>PARENT_FILENAME_PROMOTE</code> Substrings to promote as parent filenames <code>--parent-ext-promote</code> <code>PARENT_EXT_PROMOTE</code> Extensions to promote as parent files <code>--with-archived</code> <code>WITH_ARCHIVED</code> Include archived assets in processing <code>--with-deleted</code> <code>WITH_DELETED</code> Include deleted assets in processing <code>--run-mode</code> <code>RUN_MODE</code> Run mode: \"once\" (default) or \"cron\" <code>--cron-interval</code> <code>CRON_INTERVAL</code> Interval in seconds for cron mode <code>--log-level</code> <code>LOG_LEVEL</code> Log level: debug, info, warn, error <code>--remove-single-asset-stacks</code> <code>REMOVE_SINGLE_ASSET_STACKS</code> Remove stacks containing only one asset <code>--filter-album-ids</code> <code>FILTER_ALBUM_IDS</code> Filter by album IDs or names (comma-separated, OR logic) <code>--filter-taken-after</code> <code>FILTER_TAKEN_AFTER</code> Only process assets taken after this date (ISO 8601) <code>--filter-taken-before</code> <code>FILTER_TAKEN_BEFORE</code> Only process assets taken before this date (ISO 8601)"},{"location":"api-reference/cli-usage/#command-specific-notes","title":"Command-Specific Notes","text":"<ul> <li>duplicates: Uses global flags only, particularly <code>--with-archived</code> and <code>--with-deleted</code> to control which assets are checked</li> <li>fix-trash: Uses global flags plus the stacking criteria flags (<code>--criteria</code>, <code>--parent-filename-promote</code>, etc.) to determine which assets to move to trash</li> </ul>"},{"location":"api-reference/cli-usage/#examples","title":"Examples","text":""},{"location":"api-reference/cli-usage/#main-stacking-command","title":"Main Stacking Command","text":"<pre><code>immich-stack --api-key your_key --api-url http://immich-server:2283/api\n</code></pre>"},{"location":"api-reference/cli-usage/#find-duplicates","title":"Find Duplicates","text":"<pre><code>immich-stack duplicates --api-key your_key --api-url http://immich-server:2283/api\n</code></pre>"},{"location":"api-reference/cli-usage/#fix-trash-issues","title":"Fix Trash Issues","text":"<pre><code>immich-stack fix-trash --api-key your_key --dry-run\n</code></pre>"},{"location":"api-reference/cli-usage/#dry-run","title":"Dry Run","text":"<pre><code>immich-stack --dry-run --api-key your_key\n</code></pre>"},{"location":"api-reference/cli-usage/#custom-parent-selection","title":"Custom Parent Selection","text":"<pre><code># Promote edited and raw files\nimmich-stack \\\n  --parent-filename-promote edit,raw \\\n  --parent-ext-promote .jpg,.dng \\\n  --api-key your_key\n\n# Promote unedited files using empty string\nimmich-stack \\\n  --parent-filename-promote ,_edited,_crop \\\n  --api-key your_key\n</code></pre>"},{"location":"api-reference/cli-usage/#include-archiveddeleted","title":"Include Archived/Deleted","text":"<pre><code>immich-stack \\\n  --with-archived \\\n  --with-deleted \\\n  --api-key your_key\n</code></pre>"},{"location":"api-reference/cli-usage/#custom-criteria","title":"Custom Criteria","text":"<pre><code>immich-stack \\\n  --criteria '[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\"~\",\".\"],\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]' \\\n  --api-key your_key\n</code></pre>"},{"location":"api-reference/cli-usage/#reset-stacks","title":"Reset Stacks","text":"<pre><code>immich-stack \\\n  --reset-stacks \\\n  --confirm-reset-stack \"I acknowledge all my current stacks will be deleted and new one will be created\" \\\n  --api-key your_key\n</code></pre> <p>Note: <code>--reset-stacks</code> only works when <code>--run-mode</code> is <code>once</code> (or <code>RUN_MODE=once</code>).</p>"},{"location":"api-reference/cli-usage/#remove-single-asset-stacks","title":"Remove Single-Asset Stacks","text":"<pre><code>immich-stack \\\n  --remove-single-asset-stacks \\\n  --api-key your_key\n</code></pre>"},{"location":"api-reference/cli-usage/#asset-filtering","title":"Asset Filtering","text":"<pre><code># Filter by album ID\nimmich-stack \\\n  --filter-album-ids 550e8400-e29b-41d4-a716-446655440000 \\\n  --api-key your_key\n\n# Filter by album name\nimmich-stack \\\n  --filter-album-ids \"Vacation Photos\" \\\n  --api-key your_key\n\n# Filter by multiple albums (OR logic)\nimmich-stack \\\n  --filter-album-ids \"album-1,Vacation Photos,Family\" \\\n  --api-key your_key\n\n# Filter by date range\nimmich-stack \\\n  --filter-taken-after 2024-01-01T00:00:00Z \\\n  --filter-taken-before 2024-12-31T23:59:59Z \\\n  --api-key your_key\n\n# Combined: album and date filtering\nimmich-stack \\\n  --filter-album-ids \"My Photos\" \\\n  --filter-taken-after 2024-06-01T00:00:00Z \\\n  --api-key your_key\n</code></pre>"},{"location":"api-reference/cli-usage/#flag-precedence","title":"Flag Precedence","text":"<ul> <li>Command line flags take precedence over environment variables</li> <li>If both are set, the command line flag value is used</li> </ul>"},{"location":"api-reference/cli-usage/#error-handling","title":"Error Handling","text":"<p>The CLI provides clear error messages for:</p> <ul> <li>Missing required flags</li> <li>Invalid flag values</li> <li>API connection issues</li> <li>Stack operation failures</li> </ul>"},{"location":"api-reference/cli-usage/#exit-codes","title":"Exit Codes","text":"Code Description 0 Success 1 General error 2 Configuration error 3 API error 4 Stack operation error"},{"location":"api-reference/environment-variables/","title":"Environment Variables","text":"<p>This document provides a complete reference of all environment variables supported by Immich Stack.</p>"},{"location":"api-reference/environment-variables/#required-variables","title":"Required Variables","text":"Variable Description Example <code>API_KEY</code> Immich API key(s) <code>API_KEY=key1,key2</code> <code>API_URL</code> Immich API base URL <code>API_URL=http://immich:2283/api</code>"},{"location":"api-reference/environment-variables/#run-mode-configuration","title":"Run Mode Configuration","text":"Variable Description Default Example <code>RUN_MODE</code> Run mode: \"once\" or \"cron\" \"once\" <code>cron</code> <code>CRON_INTERVAL</code> Interval in seconds for cron 86400 (when RUN_MODE is cron) <code>3600</code>"},{"location":"api-reference/environment-variables/#stack-management","title":"Stack Management","text":"Variable Description Default Example <code>RESET_STACKS</code> Delete all existing stacks before processing (only in <code>RUN_MODE=once</code>) false <code>true</code> <code>CONFIRM_RESET_STACK</code> Confirmation message for reset - <code>\"I acknowledge...\"</code> <code>REPLACE_STACKS</code> Replace stacks for new groups true <code>false</code> <code>DRY_RUN</code> Simulate actions without making changes false <code>true</code> <code>REMOVE_SINGLE_ASSET_STACKS</code> Remove stacks containing only one asset false <code>true</code> <p>Note:</p> <ul> <li><code>RESET_STACKS</code> can only be used when <code>RUN_MODE=once</code>. Using it in <code>cron</code> mode results in an error.</li> <li><code>CONFIRM_RESET_STACK</code> must match the exact confirmation phrase shown in the examples.</li> </ul>"},{"location":"api-reference/environment-variables/#parent-selection","title":"Parent Selection","text":"Variable Description Default Example <code>PARENT_FILENAME_PROMOTE</code> Substrings to promote as parent filenames. Supports empty string for negative matching, the <code>sequence</code> keyword and automatic sequence detection for burst photos. <code>cover,edit,crop,hdr,biggestNumber</code> <code>,_edited</code> or <code>edit,raw</code> or <code>COVER,sequence</code> or <code>0000,0001,0002,0003</code> <code>PARENT_EXT_PROMOTE</code> Extensions to promote as parent files <code>.jpg,.png,.jpeg,.heic,.dng</code> <code>.jpg,.dng</code>"},{"location":"api-reference/environment-variables/#empty-string-for-negative-matching","title":"Empty String for Negative Matching","text":"<p>An empty string (<code>\"\"</code>) in the promote list acts as a negative match - it matches files that don't contain any of the other non-empty substrings in the list:</p> Example Description Effect <code>,_edited</code> Prioritize unedited files Files without \"_edited\" are promoted first <code>,_edited,_crop</code> Prioritize clean filenames Files without \"_edited\" or \"_crop\" come first <code>COVER,,_edited</code> Complex priority COVER files first, then files without \"_edited\", then \"_edited\" files <p>Examples:</p> <pre><code># Promote unedited JPGs over edited ones\nPARENT_FILENAME_PROMOTE=,_edited\n# Result: IMG_1234.jpg &gt; IMG_1234_edited.jpg\n\n# Multiple exclusions\nPARENT_FILENAME_PROMOTE=,_edited,_crop,_cropped\n# Result: IMG_1234.jpg &gt; IMG_1234_edited.jpg &gt; IMG_1234_crop.jpg &gt; IMG_1234_cropped.jpg\n</code></pre>"},{"location":"api-reference/environment-variables/#sequence-keyword","title":"Sequence Keyword","text":"<p>The <code>sequence</code> keyword provides flexible handling of sequential files (like burst photos):</p> Syntax Description Example Files Result <code>sequence</code> Matches any numeric sequence <code>IMG_0001.jpg</code>, <code>IMG_0010.jpg</code>, <code>IMG_0100.jpg</code> Orders by numeric value: 1, 10, 100 <code>sequence:4</code> Matches exactly 4-digit sequences <code>IMG_0001.jpg</code>, <code>IMG_0010.jpg</code> Only matches 4-digit numbers <code>sequence:IMG_</code> Matches sequences with specific prefix <code>IMG_001.jpg</code>, <code>PHOTO_001.jpg</code> Only orders files starting with <code>IMG_</code> <p>Mixed Promote Lists:</p> <pre><code># Prioritize COVER files, then order remaining by sequence\nPARENT_FILENAME_PROMOTE=COVER,sequence\n\n# Prioritize edited files, then 4-digit sequences\nPARENT_FILENAME_PROMOTE=edit,sequence:4\n</code></pre>"},{"location":"api-reference/environment-variables/#automatic-sequence-detection-legacy","title":"Automatic Sequence Detection (Legacy)","text":"<p>When <code>PARENT_FILENAME_PROMOTE</code> contains a numeric sequence pattern (e.g., <code>0000,0001,0002,0003</code>), the system automatically:</p> <ul> <li>Detects the sequence pattern (prefix, number, suffix)</li> <li>Matches files that follow the same pattern</li> <li>Orders files by their numeric value, even beyond the listed values</li> <li>Works with various formats: <code>IMG_0001</code>, <code>photo001</code>, <code>1a</code>, etc.</li> </ul> <p>Note: The <code>sequence</code> keyword is recommended over listing individual numbers for better flexibility.</p>"},{"location":"api-reference/environment-variables/#asset-inclusion","title":"Asset Inclusion","text":"Variable Description Default Example <code>WITH_ARCHIVED</code> Include archived assets in processing false <code>true</code> <code>WITH_DELETED</code> Include deleted assets in processing false <code>true</code>"},{"location":"api-reference/environment-variables/#asset-filtering","title":"Asset Filtering","text":"Variable Description Default Example <code>FILTER_ALBUM_IDS</code> Filter by album IDs or names (comma-separated) - <code>album-uuid-1,My Photos</code> <code>FILTER_TAKEN_AFTER</code> Only process assets taken after this date (ISO 8601) - <code>2024-01-01T00:00:00Z</code> <code>FILTER_TAKEN_BEFORE</code> Only process assets taken before this date (ISO 8601) - <code>2024-12-31T23:59:59Z</code>"},{"location":"api-reference/environment-variables/#album-filtering","title":"Album Filtering","text":"<p>Album filters accept both UUIDs and album names:</p> <pre><code># By UUID\nFILTER_ALBUM_IDS=550e8400-e29b-41d4-a716-446655440000\n\n# By name\nFILTER_ALBUM_IDS=Vacation Photos\n\n# Multiple albums (OR logic - assets from ANY album)\nFILTER_ALBUM_IDS=album-uuid-1,Vacation Photos,Family\n</code></pre> <p>When multiple albums are specified, assets from any of the albums are processed (OR logic).</p>"},{"location":"api-reference/environment-variables/#date-range-filtering","title":"Date Range Filtering","text":"<p>Date filters use ISO 8601 (RFC3339) format:</p> <pre><code># Assets from 2024 only\nFILTER_TAKEN_AFTER=2024-01-01T00:00:00Z\nFILTER_TAKEN_BEFORE=2024-12-31T23:59:59Z\n\n# Assets from last month\nFILTER_TAKEN_AFTER=2024-11-01T00:00:00Z\n</code></pre> <p>Valid date formats:</p> <ul> <li><code>2024-01-15T10:30:00Z</code> (UTC)</li> <li><code>2024-01-15T10:30:00+00:00</code> (with timezone offset)</li> <li><code>2024-01-15T10:30:00-05:00</code> (EST timezone)</li> </ul>"},{"location":"api-reference/environment-variables/#custom-criteria","title":"Custom Criteria","text":"Variable Description Default Example <code>CRITERIA</code> Custom grouping criteria JSON See below See Custom Criteria"},{"location":"api-reference/environment-variables/#default-criteria","title":"Default Criteria","text":"<p>When <code>CRITERIA</code> is not set, the following default is used:</p> <pre><code>[\n  {\n    \"key\": \"originalFileName\",\n    \"split\": { \"delimiters\": [\"~\", \".\"], \"index\": 0 }\n  },\n  {\n    \"key\": \"localDateTime\",\n    \"delta\": { \"milliseconds\": 1000 }\n  }\n]\n</code></pre> <p>This groups photos by:</p> <ul> <li>Base filename (before <code>~</code> or <code>.</code>)</li> <li>Time captured (within 1 second tolerance)</li> </ul>"},{"location":"api-reference/environment-variables/#custom-criteria-formats","title":"Custom Criteria Formats","text":"<p>The <code>CRITERIA</code> environment variable supports three formats for flexible asset stacking:</p>"},{"location":"api-reference/environment-variables/#legacy-array-format","title":"Legacy Array Format","text":"<p>Simple array of criteria where ALL conditions must match (AND logic):</p> <pre><code>[\n  {\n    \"key\": \"originalFileName\",\n    \"split\": { \"delimiters\": [\"~\", \".\"], \"index\": 0 }\n  },\n  { \"key\": \"localDateTime\", \"delta\": { \"milliseconds\": 1000 } }\n]\n</code></pre>"},{"location":"api-reference/environment-variables/#advanced-groups-format","title":"Advanced Groups Format","text":"<p>Flexible format supporting multiple grouping strategies with OR/AND logic:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"groups\": [\n    {\n      \"operator\": \"AND\",\n      \"criteria\": [\n        {\n          \"key\": \"originalFileName\",\n          \"regex\": { \"key\": \"PXL_\\\\d{8}_\\\\d+\", \"index\": 0 }\n        },\n        {\n          \"key\": \"localDateTime\",\n          \"delta\": { \"milliseconds\": 1000 }\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"api-reference/environment-variables/#advanced-expression-format","title":"Advanced Expression Format","text":"<p>Most powerful format supporting unlimited nested logical expressions with AND, OR, and NOT operations:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"operator\": \"OR\",\n        \"children\": [\n          {\n            \"criteria\": {\n              \"key\": \"originalFileName\",\n              \"regex\": { \"key\": \"PXL_\\\\d{8}_\\\\d+\", \"index\": 0 }\n            }\n          },\n          {\n            \"criteria\": {\n              \"key\": \"originalPath\",\n              \"split\": { \"delimiters\": [\"/\"], \"index\": 2 }\n            }\n          }\n        ]\n      },\n      {\n        \"criteria\": {\n          \"key\": \"localDateTime\",\n          \"delta\": { \"milliseconds\": 1000 }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>Format Features:</p> Format Complexity Use Case Logic Support Legacy Simple Basic grouping AND only Groups Medium Multiple grouping strategies AND/OR per group Expression Advanced Complex logical conditions Unlimited nesting with AND/OR/NOT <p>Expression Format Benefits:</p> <ul> <li>Unlimited Nesting: Create complex logical trees with multiple levels</li> <li>Full Logic Support: AND, OR, and NOT operators at any level</li> <li>Precise Control: Express any logical combination of criteria</li> <li>Backward Compatible: All legacy formats continue to work unchanged</li> </ul> <p>Complex Expression Example:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"operator\": \"OR\",\n        \"children\": [\n          {\n            \"criteria\": {\n              \"key\": \"originalFileName\",\n              \"regex\": { \"key\": \"PXL_\", \"index\": 0 }\n            }\n          },\n          {\n            \"criteria\": {\n              \"key\": \"originalFileName\",\n              \"regex\": { \"key\": \"IMG_\", \"index\": 0 }\n            }\n          }\n        ]\n      },\n      {\n        \"operator\": \"NOT\",\n        \"children\": [{ \"criteria\": { \"key\": \"isArchived\" } }]\n      },\n      {\n        \"criteria\": {\n          \"key\": \"localDateTime\",\n          \"delta\": { \"milliseconds\": 2000 }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>This example groups assets that:</p> <ul> <li>Have filenames starting with \"PXL*\" OR \"IMG*\"</li> <li>AND are NOT archived</li> <li>AND were taken within 2 seconds of each other</li> </ul>"},{"location":"api-reference/environment-variables/#logging","title":"Logging","text":"Variable Description Default Example <code>LOG_LEVEL</code> Log level (trace,debug,info,warn,error) info <code>debug</code> <code>LOG_FORMAT</code> Log format (json,text) text <code>json</code> <code>LOG_FILE</code> Optional file path for dual logging output - <code>/app/logs/immich-stack.log</code>"},{"location":"api-reference/environment-variables/#file-logging","title":"File Logging","text":"<p>When <code>LOG_FILE</code> is set, logs are written to both stdout (visible in <code>docker logs</code>) and the specified file. This is useful for:</p> <ul> <li>Persistent log storage across container restarts</li> <li>Log aggregation and analysis</li> <li>Debugging issues after they occur</li> </ul> <p>To enable file logging with Docker:</p> <ol> <li>Set the <code>LOG_FILE</code> environment variable to a path inside the container</li> <li>Mount a host directory to persist logs</li> </ol> <p>Example Docker Compose configuration:</p> <pre><code>environment:\n  - LOG_FILE=/app/logs/immich-stack.log\nvolumes:\n  - ./logs:/app/logs\n</code></pre> <p>If the log file cannot be created (e.g., permission issues), the application gracefully falls back to stdout-only logging.</p>"},{"location":"api-reference/environment-variables/#examples","title":"Examples","text":""},{"location":"api-reference/environment-variables/#basic-configuration","title":"Basic Configuration","text":"<pre><code>API_KEY=your_key\nAPI_URL=http://immich:2283/api\n</code></pre>"},{"location":"api-reference/environment-variables/#cron-mode","title":"Cron Mode","text":"<pre><code>RUN_MODE=cron\nCRON_INTERVAL=3600\n</code></pre>"},{"location":"api-reference/environment-variables/#stack-management_1","title":"Stack Management","text":"<pre><code>RESET_STACKS=true\nCONFIRM_RESET_STACK=\"I acknowledge all my current stacks will be deleted and new one will be created\"\nREPLACE_STACKS=true\nDRY_RUN=false\nREMOVE_SINGLE_ASSET_STACKS=true\n</code></pre> <p>This operation requires <code>RUN_MODE=once</code>.</p>"},{"location":"api-reference/environment-variables/#parent-selection_1","title":"Parent Selection","text":"<pre><code>PARENT_FILENAME_PROMOTE=edit,raw\nPARENT_EXT_PROMOTE=.jpg,.dng\n</code></pre>"},{"location":"api-reference/environment-variables/#custom-criteria-legacy-array-format","title":"Custom Criteria - Legacy Array Format","text":"<pre><code>CRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\"~\",\".\"],\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]'\n</code></pre>"},{"location":"api-reference/environment-variables/#custom-criteria-advanced-groups-format","title":"Custom Criteria - Advanced Groups Format","text":"<pre><code># Filter PXL files AND group by timestamp\nCRITERIA='{\n  \"mode\": \"advanced\",\n  \"groups\": [\n    {\n      \"operator\": \"AND\",\n      \"criteria\": [\n        {\"key\": \"originalFileName\", \"regex\": {\"key\": \"PXL_\\\\d{8}_\\\\d+\", \"index\": 0}},\n        {\"key\": \"localDateTime\", \"delta\": {\"milliseconds\": 1000}}\n      ]\n    }\n  ]\n}'\n\n# Group by same directory OR same timestamp\nCRITERIA='{\n  \"mode\": \"advanced\",\n  \"groups\": [\n    {\n      \"operator\": \"OR\",\n      \"criteria\": [\n        {\"key\": \"originalPath\", \"split\": {\"delimiters\": [\"/\"], \"index\": 2}},\n        {\"key\": \"localDateTime\", \"delta\": {\"milliseconds\": 1000}}\n      ]\n    }\n  ]\n}'\n</code></pre>"},{"location":"api-reference/environment-variables/#custom-criteria-advanced-expression-format","title":"Custom Criteria - Advanced Expression Format","text":"<pre><code># Complex multi-camera setup with exclusions\nCRITERIA='{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"operator\": \"OR\",\n        \"children\": [\n          {\"criteria\": {\"key\": \"originalFileName\", \"regex\": {\"key\": \"PXL_\", \"index\": 0}}},\n          {\"criteria\": {\"key\": \"originalFileName\", \"regex\": {\"key\": \"IMG_\", \"index\": 0}}}\n        ]\n      },\n      {\n        \"operator\": \"NOT\",\n        \"children\": [\n          {\"criteria\": {\"key\": \"isArchived\"}}\n        ]\n      },\n      {\"criteria\": {\"key\": \"localDateTime\", \"delta\": {\"milliseconds\": 2000}}}\n    ]\n  }\n}'\n</code></pre>"},{"location":"api-reference/environment-variables/#asset-filtering_1","title":"Asset Filtering","text":"<pre><code># Filter by specific album\nFILTER_ALBUM_IDS=550e8400-e29b-41d4-a716-446655440000\n\n# Filter by multiple albums (OR logic)\nFILTER_ALBUM_IDS=album-1,Vacation Photos,Family Events\n\n# Filter by date range\nFILTER_TAKEN_AFTER=2024-01-01T00:00:00Z\nFILTER_TAKEN_BEFORE=2024-12-31T23:59:59Z\n\n# Combined: specific album and date range\nFILTER_ALBUM_IDS=My Photos\nFILTER_TAKEN_AFTER=2024-06-01T00:00:00Z\n</code></pre>"},{"location":"api-reference/environment-variables/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Security</p> </li> <li> <p>Never commit API keys to version control</p> </li> <li>Use environment-specific .env files</li> <li> <p>Rotate API keys regularly</p> </li> <li> <p>Configuration</p> </li> <li> <p>Use specific versions in production</p> </li> <li>Document all custom configurations</li> <li> <p>Test changes in development first</p> </li> <li> <p>Monitoring</p> </li> <li> <p>Enable debug logging when needed</p> </li> <li>Monitor cron job execution</li> <li> <p>Check stack operation results</p> </li> <li> <p>Maintenance</p> </li> <li> <p>Review and update configurations regularly</p> </li> <li>Clean up old stacks periodically</li> <li>Monitor API usage and limits</li> </ol>"},{"location":"api-reference/grouping/","title":"Grouping Operations","text":"<p>The grouping operations are implemented in <code>internal/grouping/grouping.go</code>.</p>"},{"location":"api-reference/grouping/#group-structure","title":"Group Structure","text":"<pre><code>type Group struct {\n    ID        string    `json:\"id\"`\n    Name      string    `json:\"name\"`\n    Assets    []Asset   `json:\"assets\"`\n    CreatedAt time.Time `json:\"createdAt\"`\n    UpdatedAt time.Time `json:\"updatedAt\"`\n}\n</code></pre>"},{"location":"api-reference/grouping/#available-operations","title":"Available Operations","text":""},{"location":"api-reference/grouping/#group-assets","title":"Group Assets","text":"<pre><code>func GroupAssets(ctx context.Context, client *immich.Client, assets []Asset, criteria []Criterion) ([]Group, error)\n</code></pre> <p>Groups assets based on specified criteria.</p> <p>Parameters:</p> <ul> <li><code>ctx</code>: Context for the operation</li> <li><code>client</code>: Immich API client</li> <li><code>assets</code>: Array of assets to group</li> <li><code>criteria</code>: Array of grouping criteria</li> </ul> <p>Returns:</p> <ul> <li><code>[]Group</code>: Array of groups</li> <li><code>error</code>: Any error that occurred</li> </ul>"},{"location":"api-reference/grouping/#get-group","title":"Get Group","text":"<pre><code>func GetGroup(ctx context.Context, client *immich.Client, groupID string) (*Group, error)\n</code></pre> <p>Retrieves a group by ID.</p> <p>Parameters:</p> <ul> <li><code>ctx</code>: Context for the operation</li> <li><code>client</code>: Immich API client</li> <li><code>groupID</code>: ID of the group to retrieve</li> </ul> <p>Returns:</p> <ul> <li><code>*Group</code>: Retrieved group</li> <li><code>error</code>: Any error that occurred</li> </ul>"},{"location":"api-reference/grouping/#update-group","title":"Update Group","text":"<pre><code>func UpdateGroup(ctx context.Context, client *immich.Client, group *Group) error\n</code></pre> <p>Updates an existing group.</p> <p>Parameters:</p> <ul> <li><code>ctx</code>: Context for the operation</li> <li><code>client</code>: Immich API client</li> <li><code>group</code>: Group to update</li> </ul> <p>Returns:</p> <ul> <li><code>error</code>: Any error that occurred</li> </ul>"},{"location":"api-reference/grouping/#delete-group","title":"Delete Group","text":"<pre><code>func DeleteGroup(ctx context.Context, client *immich.Client, groupID string) error\n</code></pre> <p>Deletes a group by ID.</p> <p>Parameters:</p> <ul> <li><code>ctx</code>: Context for the operation</li> <li><code>client</code>: Immich API client</li> <li><code>groupID</code>: ID of the group to delete</li> </ul> <p>Returns:</p> <ul> <li><code>error</code>: Any error that occurred</li> </ul>"},{"location":"api-reference/grouping/#grouping-criteria","title":"Grouping Criteria","text":"<pre><code>type Criterion struct {\n    Key    string      `json:\"key\"`\n    Split  *SplitConfig `json:\"split,omitempty\"`\n    Delta  *DeltaConfig `json:\"delta,omitempty\"`\n}\n\ntype SplitConfig struct {\n    Delimiters []string `json:\"delimiters\"`\n    Index      int      `json:\"index\"`\n}\n\ntype DeltaConfig struct {\n    Milliseconds int64 `json:\"milliseconds\"`\n}\n</code></pre>"},{"location":"api-reference/grouping/#error-handling","title":"Error Handling","text":"<p>All operations handle the following error cases:</p> <ul> <li>Invalid group ID</li> <li>Group not found</li> <li>API errors</li> <li>Network errors</li> <li>Invalid group data</li> <li>Invalid criteria</li> </ul>"},{"location":"api-reference/grouping/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Error Handling</p> </li> <li> <p>Always check returned errors</p> </li> <li>Use appropriate error handling strategies</li> <li> <p>Log errors for debugging</p> </li> <li> <p>Context Usage</p> </li> <li> <p>Pass context through all operations</p> </li> <li>Use context for cancellation</li> <li> <p>Set appropriate timeouts</p> </li> <li> <p>Group Management</p> </li> <li> <p>Validate groups before operations</p> </li> <li>Handle missing groups gracefully</li> <li> <p>Maintain group consistency</p> </li> <li> <p>Criteria Usage</p> </li> <li> <p>Use appropriate criteria</p> </li> <li>Handle edge cases</li> <li>Consider performance implications</li> </ol>"},{"location":"api-reference/grouping/#example-usage","title":"Example Usage","text":"<pre><code>// Group assets with criteria\ncriteria := []Criterion{\n    {\n        Key: \"originalFileName\",\n        Split: &amp;SplitConfig{\n            Delimiters: []string{\"~\", \".\"},\n            Index:      0,\n        },\n    },\n    {\n        Key: \"localDateTime\",\n        Delta: &amp;DeltaConfig{\n            Milliseconds: 1000,\n        },\n    },\n}\ngroups, err := GroupAssets(ctx, client, assets, criteria)\nif err != nil {\n    log.Printf(\"Error grouping assets: %v\", err)\n    return\n}\n\n// Get single group\ngroup, err := GetGroup(ctx, client, \"group-id\")\nif err != nil {\n    log.Printf(\"Error getting group: %v\", err)\n    return\n}\n\n// Update group\ngroup.Name = \"New Name\"\nerr = UpdateGroup(ctx, client, group)\nif err != nil {\n    log.Printf(\"Error updating group: %v\", err)\n    return\n}\n\n// Delete group\nerr = DeleteGroup(ctx, client, \"group-id\")\nif err != nil {\n    log.Printf(\"Error deleting group: %v\", err)\n    return\n}\n</code></pre>"},{"location":"api-reference/stack-operations/","title":"API Operations Reference","text":"<p>All API operations are implemented in <code>pkg/immich/client.go</code>. The client provides a high-level interface to the Immich API with built-in retry logic, error handling, and dry-run support.</p>"},{"location":"api-reference/stack-operations/#client-structure","title":"Client Structure","text":"<p>The <code>Client</code> struct handles all API interactions:</p> <pre><code>type Client struct {\n    client                  *http.Client\n    apiURL                  string\n    apiKey                  string\n    resetStacks             bool\n    replaceStacks           bool\n    dryRun                  bool\n    withArchived            bool\n    withDeleted             bool\n    removeSingleAssetStacks bool\n    logger                  *logrus.Logger\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#client-configuration","title":"Client Configuration","text":""},{"location":"api-reference/stack-operations/#creating-a-client","title":"Creating a Client","text":"<pre><code>client := immich.NewClient(\n    apiURL,                    // Base URL of Immich API\n    apiKey,                    // API key for authentication\n    resetStacks,               // Delete all existing stacks\n    replaceStacks,             // Replace stacks for new groups\n    dryRun,                    // Simulate without making changes\n    withArchived,              // Include archived assets\n    withDeleted,               // Include deleted assets\n    removeSingleAssetStacks,   // Remove single-asset stacks\n    logger,                    // Logger instance\n)\n</code></pre>"},{"location":"api-reference/stack-operations/#client-settings","title":"Client Settings","text":"<ul> <li>Timeout: 600 seconds for all requests</li> <li>Retry Logic: Up to 3 retries with 500ms base delay</li> <li>Connection Pool: 100 max idle connections</li> <li>Idle Timeout: 90 seconds</li> </ul>"},{"location":"api-reference/stack-operations/#stack-operations","title":"Stack Operations","text":""},{"location":"api-reference/stack-operations/#fetchallstacks","title":"FetchAllStacks","text":"<p>Retrieves all existing stacks from Immich.</p> <pre><code>func (c *Client) FetchAllStacks() (map[string]utils.TStack, error)\n</code></pre> <p>Returns:</p> <ul> <li><code>map[string]utils.TStack</code>: Map of stack IDs to stack objects</li> <li><code>error</code>: Any error that occurred</li> </ul> <p>Usage:</p> <pre><code>stacks, err := client.FetchAllStacks()\nif err != nil {\n    log.Fatalf(\"Error fetching stacks: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#modifystack","title":"ModifyStack","text":"<p>Creates or updates a stack with the given asset IDs. The first asset in the array becomes the stack parent.</p> <pre><code>func (c *Client) ModifyStack(assetIDs []string) error\n</code></pre> <p>Parameters:</p> <ul> <li><code>assetIDs</code>: Array of asset IDs (first is parent, rest are children)</li> </ul> <p>Returns:</p> <ul> <li><code>error</code>: Any error that occurred</li> </ul> <p>Behavior:</p> <ul> <li>Respects <code>dryRun</code> flag (no-op if enabled)</li> <li>Automatically retries on failure</li> <li>Logs debug message on success</li> </ul> <p>Usage:</p> <pre><code>assetIDs := []string{parentID, child1ID, child2ID}\nerr := client.ModifyStack(assetIDs)\nif err != nil {\n    log.Errorf(\"Error modifying stack: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#deletestack","title":"DeleteStack","text":"<p>Deletes a stack by its ID.</p> <pre><code>func (c *Client) DeleteStack(stackID string, reason string) error\n</code></pre> <p>Parameters:</p> <ul> <li><code>stackID</code>: ID of the stack to delete</li> <li><code>reason</code>: Reason constant for logging (e.g., <code>utils.REASON_REPLACE_CHILD_STACK_WITH_NEW_ONE</code>)</li> </ul> <p>Returns:</p> <ul> <li><code>error</code>: Any error that occurred</li> </ul> <p>Behavior:</p> <ul> <li>Respects <code>dryRun</code> flag (no-op if enabled)</li> <li>Logs the deletion reason</li> <li>Automatically retries on failure</li> </ul> <p>Usage:</p> <pre><code>err := client.DeleteStack(stackID, utils.REASON_REPLACE_CHILD_STACK_WITH_NEW_ONE)\nif err != nil {\n    log.Errorf(\"Error deleting stack: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#asset-operations","title":"Asset Operations","text":""},{"location":"api-reference/stack-operations/#fetchassets","title":"FetchAssets","text":"<p>Fetches all assets from Immich with pagination support.</p> <pre><code>func (c *Client) FetchAssets(size int, stacksMap map[string]utils.TStack) ([]utils.TAsset, error)\n</code></pre> <p>Parameters:</p> <ul> <li><code>size</code>: Page size for pagination (e.g., 1000)</li> <li><code>stacksMap</code>: Map of existing stacks to associate with assets</li> </ul> <p>Returns:</p> <ul> <li><code>[]utils.TAsset</code>: Array of all assets</li> <li><code>error</code>: Any error that occurred</li> </ul> <p>Behavior:</p> <ul> <li>Fetches assets in pages until all are retrieved</li> <li>Filters based on <code>withArchived</code> and <code>withDeleted</code> flags</li> <li>Associates assets with their stacks from stacksMap</li> </ul> <p>Usage:</p> <pre><code>assets, err := client.FetchAssets(1000, stacksMap)\nif err != nil {\n    log.Fatalf(\"Error fetching assets: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#listduplicates","title":"ListDuplicates","text":"<p>Identifies and lists duplicate assets based on filename and timestamp.</p> <pre><code>func (c *Client) ListDuplicates(allAssets []utils.TAsset) error\n</code></pre> <p>Parameters:</p> <ul> <li><code>allAssets</code>: Array of all assets to check for duplicates</li> </ul> <p>Returns:</p> <ul> <li><code>error</code>: Any error that occurred</li> </ul> <p>Behavior:</p> <ul> <li>Groups assets by original filename and local datetime</li> <li>Logs duplicate groups with details</li> <li>Does not modify any assets</li> </ul> <p>Usage:</p> <pre><code>err := client.ListDuplicates(assets)\nif err != nil {\n    log.Errorf(\"Error listing duplicates: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#fetchtrashedassets","title":"FetchTrashedAssets","text":"<p>Retrieves all assets in the trash.</p> <pre><code>func (c *Client) FetchTrashedAssets(size int) ([]utils.TAsset, error)\n</code></pre> <p>Parameters:</p> <ul> <li><code>size</code>: Page size for pagination</li> </ul> <p>Returns:</p> <ul> <li><code>[]utils.TAsset</code>: Array of trashed assets</li> <li><code>error</code>: Any error that occurred</li> </ul> <p>Usage:</p> <pre><code>trashedAssets, err := client.FetchTrashedAssets(1000)\nif err != nil {\n    log.Errorf(\"Error fetching trashed assets: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#trashassets","title":"TrashAssets","text":"<p>Moves assets to the trash.</p> <pre><code>func (c *Client) TrashAssets(assetIDs []string) error\n</code></pre> <p>Parameters:</p> <ul> <li><code>assetIDs</code>: Array of asset IDs to trash</li> </ul> <p>Returns:</p> <ul> <li><code>error</code>: Any error that occurred</li> </ul> <p>Behavior:</p> <ul> <li>Respects <code>dryRun</code> flag</li> <li>Processes in batches</li> <li>Automatically retries on failure</li> </ul> <p>Usage:</p> <pre><code>err := client.TrashAssets([]string{assetID1, assetID2})\nif err != nil {\n    log.Errorf(\"Error trashing assets: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#album-operations","title":"Album Operations","text":""},{"location":"api-reference/stack-operations/#fetchalbums","title":"FetchAlbums","text":"<p>Retrieves all albums.</p> <pre><code>func (c *Client) FetchAlbums() ([]utils.TAlbum, error)\n</code></pre> <p>Returns:</p> <ul> <li><code>[]utils.TAlbum</code>: Array of all albums</li> <li><code>error</code>: Any error that occurred</li> </ul> <p>Usage:</p> <pre><code>albums, err := client.FetchAlbums()\nif err != nil {\n    log.Errorf(\"Error fetching albums: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#fetchalbumassets","title":"FetchAlbumAssets","text":"<p>Retrieves all assets in a specific album.</p> <pre><code>func (c *Client) FetchAlbumAssets(albumID string) ([]utils.TAsset, error)\n</code></pre> <p>Parameters:</p> <ul> <li><code>albumID</code>: ID of the album</li> </ul> <p>Returns:</p> <ul> <li><code>[]utils.TAsset</code>: Array of assets in the album</li> <li><code>error</code>: Any error that occurred</li> </ul> <p>Usage:</p> <pre><code>assets, err := client.FetchAlbumAssets(albumID)\nif err != nil {\n    log.Errorf(\"Error fetching album assets: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#createalbum","title":"CreateAlbum","text":"<p>Creates a new album.</p> <pre><code>func (c *Client) CreateAlbum(name, description string) (*utils.TAlbum, error)\n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code>: Album name</li> <li><code>description</code>: Album description</li> </ul> <p>Returns:</p> <ul> <li><code>*utils.TAlbum</code>: Created album</li> <li><code>error</code>: Any error that occurred</li> </ul> <p>Behavior:</p> <ul> <li>Respects <code>dryRun</code> flag</li> <li>Returns mock album in dry-run mode</li> </ul> <p>Usage:</p> <pre><code>album, err := client.CreateAlbum(\"Vacation 2024\", \"Summer vacation photos\")\nif err != nil {\n    log.Errorf(\"Error creating album: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#addassetstoalbum","title":"AddAssetsToAlbum","text":"<p>Adds assets to an existing album.</p> <pre><code>func (c *Client) AddAssetsToAlbum(albumID string, assetIDs []string) error\n</code></pre> <p>Parameters:</p> <ul> <li><code>albumID</code>: ID of the album</li> <li><code>assetIDs</code>: Array of asset IDs to add</li> </ul> <p>Returns:</p> <ul> <li><code>error</code>: Any error that occurred</li> </ul> <p>Behavior:</p> <ul> <li>Respects <code>dryRun</code> flag</li> <li>Automatically retries on failure</li> </ul> <p>Usage:</p> <pre><code>err := client.AddAssetsToAlbum(albumID, []string{assetID1, assetID2})\nif err != nil {\n    log.Errorf(\"Error adding assets to album: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#removeassetsfromalbum","title":"RemoveAssetsFromAlbum","text":"<p>Removes assets from an album.</p> <pre><code>func (c *Client) RemoveAssetsFromAlbum(albumID string, assetIDs []string) error\n</code></pre> <p>Parameters:</p> <ul> <li><code>albumID</code>: ID of the album</li> <li><code>assetIDs</code>: Array of asset IDs to remove</li> </ul> <p>Returns:</p> <ul> <li><code>error</code>: Any error that occurred</li> </ul> <p>Behavior:</p> <ul> <li>Respects <code>dryRun</code> flag</li> <li>Automatically retries on failure</li> </ul> <p>Usage:</p> <pre><code>err := client.RemoveAssetsFromAlbum(albumID, []string{assetID1})\nif err != nil {\n    log.Errorf(\"Error removing assets from album: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#updatealbum","title":"UpdateAlbum","text":"<p>Updates album properties.</p> <pre><code>func (c *Client) UpdateAlbum(albumID string, updates map[string]interface{}) error\n</code></pre> <p>Parameters:</p> <ul> <li><code>albumID</code>: ID of the album to update</li> <li><code>updates</code>: Map of properties to update (e.g., <code>{\"albumName\": \"New Name\"}</code>)</li> </ul> <p>Returns:</p> <ul> <li><code>error</code>: Any error that occurred</li> </ul> <p>Behavior:</p> <ul> <li>Respects <code>dryRun</code> flag</li> <li>Automatically retries on failure</li> </ul> <p>Usage:</p> <pre><code>updates := map[string]interface{}{\n    \"albumName\": \"Vacation 2024 - Updated\",\n    \"description\": \"Updated description\",\n}\nerr := client.UpdateAlbum(albumID, updates)\nif err != nil {\n    log.Errorf(\"Error updating album: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#user-operations","title":"User Operations","text":""},{"location":"api-reference/stack-operations/#getcurrentuser","title":"GetCurrentUser","text":"<p>Retrieves information about the authenticated user.</p> <pre><code>func (c *Client) GetCurrentUser() (utils.TUserResponse, error)\n</code></pre> <p>Returns:</p> <ul> <li><code>utils.TUserResponse</code>: User information</li> <li><code>error</code>: Any error that occurred</li> </ul> <p>Usage:</p> <pre><code>user, err := client.GetCurrentUser()\nif err != nil {\n    log.Errorf(\"Error fetching user: %v\", err)\n}\nlog.Infof(\"User: %s (%s)\", user.Name, user.Email)\n</code></pre>"},{"location":"api-reference/stack-operations/#error-handling","title":"Error Handling","text":"<p>All operations implement consistent error handling:</p>"},{"location":"api-reference/stack-operations/#retry-logic","title":"Retry Logic","text":"<ul> <li>Maximum retries: 3 attempts</li> <li>Base delay: 500ms</li> <li>Backoff: Exponential (500ms, 1s, 2s)</li> <li>Automatic retry: Network errors, 5xx responses, 429 rate limit</li> </ul>"},{"location":"api-reference/stack-operations/#error-types","title":"Error Types","text":"<pre><code>// Request errors\nfmt.Errorf(\"error creating request: %w\", err)\nfmt.Errorf(\"error marshaling request body: %w\", err)\n\n// Response errors\nfmt.Errorf(\"API request failed with status %d: %s\", resp.StatusCode, string(body))\nfmt.Errorf(\"error reading response body: %w\", err)\nfmt.Errorf(\"error decoding response: %w\", err)\n</code></pre>"},{"location":"api-reference/stack-operations/#dry-run-behavior","title":"Dry-Run Behavior","text":"<p>When <code>dryRun</code> is enabled:</p> <ul> <li>All write operations (create, update, delete) return success without making changes</li> <li>Read operations work normally</li> <li>Logging indicates dry-run mode</li> </ul>"},{"location":"api-reference/stack-operations/#best-practices","title":"Best Practices","text":""},{"location":"api-reference/stack-operations/#error-handling_1","title":"Error Handling","text":"<pre><code>assets, err := client.FetchAssets(1000, stacksMap)\nif err != nil {\n    logger.Fatalf(\"Critical error: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#batch-operations","title":"Batch Operations","text":"<pre><code>// Process in batches for large datasets\nconst batchSize = 1000\nfor i := 0; i &lt; len(assetIDs); i += batchSize {\n    end := i + batchSize\n    if end &gt; len(assetIDs) {\n        end = len(assetIDs)\n    }\n    batch := assetIDs[i:end]\n    err := client.TrashAssets(batch)\n    if err != nil {\n        logger.Errorf(\"Batch failed: %v\", err)\n    }\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#dry-run-testing","title":"Dry-Run Testing","text":"<pre><code>// Test operations without making changes\nclient := immich.NewClient(\n    apiURL, apiKey,\n    false,  // resetStacks\n    true,   // replaceStacks\n    true,   // dryRun - ENABLE FOR TESTING\n    false,  // withArchived\n    false,  // withDeleted\n    false,  // removeSingleAssetStacks\n    logger,\n)\n</code></pre>"},{"location":"api-reference/stack-operations/#multi-user-support","title":"Multi-User Support","text":"<pre><code>// Process multiple users sequentially\napiKeys := strings.Split(os.Getenv(\"API_KEYS\"), \",\")\nfor _, key := range apiKeys {\n    client := immich.NewClient(apiURL, key, ...)\n    user, err := client.GetCurrentUser()\n    if err != nil {\n        logger.Errorf(\"Failed for key %s: %v\", key, err)\n        continue\n    }\n    logger.Infof(\"Processing user: %s\", user.Name)\n    // ... perform operations\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#type-definitions","title":"Type Definitions","text":"<p>Key types from <code>pkg/utils/types.go</code>:</p> <pre><code>type TAsset struct {\n    ID               string\n    OriginalFileName string\n    LocalDateTime    time.Time\n    OriginalPath     string\n    Stack            *TStack\n    IsArchived       bool\n    IsTrashed        bool\n    // ... other fields\n}\n\ntype TStack struct {\n    ID             string\n    PrimaryAssetID string\n    Assets         []TAsset\n}\n\ntype TAlbum struct {\n    ID          string\n    AlbumName   string\n    Description string\n    AssetCount  int\n    // ... other fields\n}\n\ntype TUserResponse struct {\n    ID    string\n    Email string\n    Name  string\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#common-patterns","title":"Common Patterns","text":""},{"location":"api-reference/stack-operations/#complete-stack-workflow","title":"Complete Stack Workflow","text":"<pre><code>// 1. Fetch existing stacks\nstacks, err := client.FetchAllStacks()\nif err != nil {\n    log.Fatalf(\"Error: %v\", err)\n}\n\n// 2. Fetch all assets\nassets, err := client.FetchAssets(1000, stacks)\nif err != nil {\n    log.Fatalf(\"Error: %v\", err)\n}\n\n// 3. Group assets into new stacks\ngroups := stacker.StackBy(assets, criteria, ...)\n\n// 4. Delete old conflicting stacks\nfor _, group := range groups {\n    if needsReplacement(group) {\n        err := client.DeleteStack(oldStackID, utils.REASON_REPLACE)\n        if err != nil {\n            log.Errorf(\"Delete failed: %v\", err)\n        }\n    }\n}\n\n// 5. Create/update stacks\nfor _, group := range groups {\n    assetIDs := extractIDs(group)\n    err := client.ModifyStack(assetIDs)\n    if err != nil {\n        log.Errorf(\"Modify failed: %v\", err)\n    }\n}\n</code></pre>"},{"location":"api-reference/stack-operations/#album-management","title":"Album Management","text":"<pre><code>// Create album\nalbum, err := client.CreateAlbum(\"Best Photos\", \"Top selections\")\nif err != nil {\n    log.Fatalf(\"Error: %v\", err)\n}\n\n// Add assets\nassetIDs := []string{id1, id2, id3}\nerr = client.AddAssetsToAlbum(album.ID, assetIDs)\nif err != nil {\n    log.Errorf(\"Error: %v\", err)\n}\n\n// Update metadata\nupdates := map[string]interface{}{\n    \"description\": \"Updated: Top 50 photos\",\n}\nerr = client.UpdateAlbum(album.ID, updates)\n</code></pre>"},{"location":"commands/","title":"Commands Overview","text":"<p>Immich Stack provides multiple commands for different photo management operations.</p>"},{"location":"commands/#available-commands","title":"Available Commands","text":""},{"location":"commands/#main-stacking-command","title":"Main Stacking Command","text":"<pre><code>immich-stack [flags]\n</code></pre> <p>The default command that processes your photo library and creates stacks based on your configured criteria. This is the primary functionality of the tool.</p> <p>Learn more about stacking \u2192</p>"},{"location":"commands/#duplicates-detection","title":"Duplicates Detection","text":"<pre><code>immich-stack duplicates [flags]\n</code></pre> <p>Finds and reports duplicate assets in your library based on filename and timestamp matching.</p> <p>Full documentation \u2192</p>"},{"location":"commands/#fix-trash-operations","title":"Fix Trash Operations","text":"<pre><code>immich-stack fix-trash [flags]\n</code></pre> <p>Maintains stack consistency by moving related assets to trash when their stack members have been deleted.</p> <p>Full documentation \u2192</p>"},{"location":"commands/#common-workflows","title":"Common Workflows","text":""},{"location":"commands/#1-initial-library-organization","title":"1. Initial Library Organization","text":"<pre><code># First, check for duplicates\nimmich-stack duplicates --api-key your_key\n\n# Then create stacks\nimmich-stack --api-key your_key --dry-run\n\n# If satisfied, run without dry-run\nimmich-stack --api-key your_key\n</code></pre>"},{"location":"commands/#2-regular-maintenance","title":"2. Regular Maintenance","text":"<pre><code># Weekly maintenance routine\nimmich-stack duplicates --api-key your_key\nimmich-stack fix-trash --api-key your_key\nimmich-stack --api-key your_key\n</code></pre>"},{"location":"commands/#3-post-deletion-cleanup","title":"3. Post-Deletion Cleanup","text":"<pre><code># After deleting photos in Immich UI\nimmich-stack fix-trash --api-key your_key --dry-run\nimmich-stack fix-trash --api-key your_key\n</code></pre>"},{"location":"commands/#global-flags","title":"Global Flags","text":"<p>All commands share these common flags:</p> <ul> <li><code>--api-key</code> - Immich API key (required)</li> <li><code>--api-url</code> - Immich server URL</li> <li><code>--dry-run</code> - Preview changes without applying</li> <li><code>--log-level</code> - Set logging verbosity</li> <li><code>--with-archived</code> - Include archived assets</li> <li><code>--with-deleted</code> - Include deleted assets</li> </ul> <p>See CLI Usage for complete flag documentation.</p>"},{"location":"commands/#best-practices","title":"Best Practices","text":"<ol> <li>Always use dry-run first - Preview changes before applying them</li> <li>Regular maintenance - Run commands periodically to keep library organized</li> <li>Check duplicates before stacking - Avoid creating stacks with duplicate assets</li> <li>Fix trash after deletions - Maintain consistency when deleting stacked photos</li> </ol>"},{"location":"commands/#see-also","title":"See Also","text":"<ul> <li>Environment Variables - Configure via environment</li> <li>Stacking Logic - Understand grouping criteria</li> <li>Custom Criteria - Advanced configuration</li> </ul>"},{"location":"commands/duplicates/","title":"Duplicates Command","text":"<p>The <code>duplicates</code> command helps you identify duplicate assets in your Immich library based on filename and timestamp.</p>"},{"location":"commands/duplicates/#overview","title":"Overview","text":"<p>This command scans your entire Immich library and groups assets that have identical:</p> <ul> <li>Original filename</li> <li>Local date/time</li> </ul> <p>This is useful for finding:</p> <ul> <li>Multiple uploads of the same photo</li> <li>Photos that were accidentally imported multiple times</li> <li>Duplicate files from different sources that have the same name and timestamp</li> </ul>"},{"location":"commands/duplicates/#usage","title":"Usage","text":"<pre><code>immich-stack duplicates [flags]\n</code></pre>"},{"location":"commands/duplicates/#examples","title":"Examples","text":""},{"location":"commands/duplicates/#basic-usage","title":"Basic Usage","text":"<p>Find duplicates in your library:</p> <pre><code>immich-stack duplicates --api-key your_key --api-url http://immich:2283\n</code></pre>"},{"location":"commands/duplicates/#include-archived-assets","title":"Include Archived Assets","text":"<pre><code>immich-stack duplicates --api-key your_key --with-archived\n</code></pre>"},{"location":"commands/duplicates/#multi-user-scan","title":"Multi-User Scan","text":"<p>Check duplicates for multiple users:</p> <pre><code>immich-stack duplicates --api-key \"user1_key,user2_key\"\n</code></pre>"},{"location":"commands/duplicates/#with-debug-logging","title":"With Debug Logging","text":"<p>Get detailed information during the scan:</p> <pre><code>immich-stack duplicates --api-key your_key --log-level debug\n</code></pre>"},{"location":"commands/duplicates/#output","title":"Output","text":"<p>The command will output groups of duplicate assets. For example:</p> <pre><code>Duplicate group: IMG_1234.jpg|2024-01-15T10:30:00 (3 assets)\n  - ID: abc123, FileName: IMG_1234.jpg, LocalDateTime: 2024-01-15T10:30:00\n  - ID: def456, FileName: IMG_1234.jpg, LocalDateTime: 2024-01-15T10:30:00\n  - ID: ghi789, FileName: IMG_1234.jpg, LocalDateTime: 2024-01-15T10:30:00\n</code></pre> <p>If no duplicates are found:</p> <pre><code>No duplicates found based on OriginalFileName and LocalDateTime.\n</code></pre>"},{"location":"commands/duplicates/#flags","title":"Flags","text":"<p>The <code>duplicates</code> command inherits all global flags, particularly:</p> <ul> <li><code>--api-key</code> - Required for authentication</li> <li><code>--api-url</code> - Immich server URL</li> <li><code>--with-archived</code> - Include archived assets in the scan</li> <li><code>--with-deleted</code> - Include deleted assets in the scan</li> <li><code>--log-level</code> - Control verbosity of output</li> </ul>"},{"location":"commands/duplicates/#use-cases","title":"Use Cases","text":""},{"location":"commands/duplicates/#1-pre-cleanup-audit","title":"1. Pre-Cleanup Audit","text":"<p>Before running cleanup operations, identify duplicates:</p> <pre><code># First, find duplicates\nimmich-stack duplicates --api-key your_key\n\n# Then manually review and delete duplicates in Immich UI\n</code></pre>"},{"location":"commands/duplicates/#2-regular-maintenance","title":"2. Regular Maintenance","text":"<p>Run periodically to check for new duplicates:</p> <pre><code># Add to a monthly maintenance script\nimmich-stack duplicates --api-key your_key --log-level warn\n</code></pre>"},{"location":"commands/duplicates/#3-migration-verification","title":"3. Migration Verification","text":"<p>After migrating photos from another system:</p> <pre><code># Check if migration created duplicates\nimmich-stack duplicates --api-key your_key --with-archived --with-deleted\n</code></pre>"},{"location":"commands/duplicates/#important-notes","title":"Important Notes","text":"<ol> <li>Read-Only Operation: This command only reports duplicates; it does not delete or modify any assets</li> <li>Exact Matching: Only assets with identical filename AND timestamp are considered duplicates</li> <li>Performance: For large libraries, this command may take several minutes to complete</li> <li>Stack-Aware: The command fetches stack information but duplicates are detected independently of stack membership</li> </ol>"},{"location":"commands/duplicates/#see-also","title":"See Also","text":"<ul> <li>Main Stacking Command - Create stacks from your assets</li> <li>Fix-Trash Command - Maintain stack consistency when deleting</li> <li>Environment Variables - Configuration options</li> </ul>"},{"location":"commands/fix-trash/","title":"Fix-Trash Command","text":"<p>The <code>fix-trash</code> command ensures stack consistency by moving related assets to trash when their stack members have been deleted.</p>"},{"location":"commands/fix-trash/#overview","title":"Overview","text":"<p>When you delete a photo in Immich that's part of a stack (e.g., one photo from a burst sequence), the other photos in that stack should typically be deleted too. However, if photos are deleted through the Immich UI or other means, related stack members might remain in your library.</p> <p>This command:</p> <ol> <li>Scans your trash for deleted assets</li> <li>Identifies which active assets would stack with the trashed ones</li> <li>Moves those related assets to trash to maintain consistency</li> </ol>"},{"location":"commands/fix-trash/#how-it-works","title":"How It Works","text":"<p>The command uses the same stacking criteria as the main stacking command. For each trashed asset:</p> <ol> <li>It combines the trashed asset with all active assets</li> <li>Runs the stacking algorithm to find matches</li> <li>Any active assets that would group with the trashed asset are marked for deletion</li> </ol>"},{"location":"commands/fix-trash/#usage","title":"Usage","text":"<pre><code>immich-stack fix-trash [flags]\n</code></pre>"},{"location":"commands/fix-trash/#examples","title":"Examples","text":""},{"location":"commands/fix-trash/#basic-usage","title":"Basic Usage","text":"<pre><code>immich-stack fix-trash --api-key your_key --api-url http://immich:2283\n</code></pre>"},{"location":"commands/fix-trash/#dry-run-mode","title":"Dry Run Mode","text":"<p>See what would be deleted without making changes:</p> <pre><code>immich-stack fix-trash --api-key your_key --dry-run\n</code></pre>"},{"location":"commands/fix-trash/#with-custom-criteria","title":"With Custom Criteria","text":"<p>Use specific stacking criteria for matching:</p> <pre><code>immich-stack fix-trash --api-key your_key --criteria '[{\"key\":\"originalFileName\",\"regex\":{\"pattern\":\"BURST(\\\\d+)\",\"index\":1}}]'\n</code></pre>"},{"location":"commands/fix-trash/#debug-mode","title":"Debug Mode","text":"<p>Get detailed information about the matching process:</p> <pre><code>immich-stack fix-trash --api-key your_key --log-level debug\n</code></pre>"},{"location":"commands/fix-trash/#output","title":"Output","text":"<p>The command provides detailed feedback:</p> <pre><code>\ud83d\uddd1\ufe0f  Found 5 trashed assets\n\ud83d\udcca Analyzing against 1000 active assets...\n\u2705 Analysis complete: 5 trashed \u2192 15 related assets to trash\n\n\ud83d\udcc1 Assets to trash by type:\n   - JPG files: 10\n   - DNG files: 5\n\n\ud83d\uddd1\ufe0f  Moving 15 assets to trash... done\n</code></pre> <p>In debug mode, you'll see detailed stack information:</p> <pre><code>\ud83d\udccb Summary of assets to trash:\nStack with DSC_0001_BURST.jpg (in trash): DSC_0002_BURST.jpg, DSC_0003_BURST.jpg\nStack with IMG_1234.jpg (in trash): IMG_1234.dng\n</code></pre>"},{"location":"commands/fix-trash/#flags","title":"Flags","text":"<p>The command uses all global flags, particularly:</p> <ul> <li><code>--dry-run</code> - Preview what would be deleted without making changes</li> <li><code>--criteria</code> - Custom stacking criteria (uses same format as main command)</li> <li><code>--parent-filename-promote</code> - Filename patterns for stacking</li> <li><code>--log-level</code> - Set to <code>debug</code> for detailed matching information</li> </ul>"},{"location":"commands/fix-trash/#use-cases","title":"Use Cases","text":""},{"location":"commands/fix-trash/#1-post-deletion-cleanup","title":"1. Post-Deletion Cleanup","text":"<p>After deleting photos through Immich UI:</p> <pre><code># Clean up related assets after manual deletion\nimmich-stack fix-trash --api-key your_key\n</code></pre>"},{"location":"commands/fix-trash/#2-burst-photo-management","title":"2. Burst Photo Management","text":"<p>When you delete one photo from a burst sequence:</p> <pre><code># Ensure all burst photos are deleted together\nimmich-stack fix-trash --api-key your_key --parent-filename-promote \"sequence\"\n</code></pre>"},{"location":"commands/fix-trash/#3-rawjpeg-cleanup","title":"3. RAW+JPEG Cleanup","text":"<p>After deleting JPEG files, remove orphaned RAW files:</p> <pre><code># First check what would be deleted\nimmich-stack fix-trash --api-key your_key --dry-run\n\n# Then execute if correct\nimmich-stack fix-trash --api-key your_key\n</code></pre>"},{"location":"commands/fix-trash/#4-scheduled-maintenance","title":"4. Scheduled Maintenance","text":"<p>Add to a cron job for automatic cleanup:</p> <pre><code># Run weekly to maintain consistency\n0 2 * * 0 immich-stack fix-trash --api-key your_key --log-level warn\n</code></pre>"},{"location":"commands/fix-trash/#important-notes","title":"Important Notes","text":"<ol> <li>Uses Stacking Criteria: The command uses the same criteria as the main stacking command</li> <li>Irreversible: Moving assets to trash cannot be undone through this tool</li> <li>Performance: For large libraries, analysis may take several minutes</li> <li>Safety First: Always use <code>--dry-run</code> first to preview changes</li> </ol>"},{"location":"commands/fix-trash/#best-practices","title":"Best Practices","text":"<ol> <li>Test with Dry Run: Always run with <code>--dry-run</code> first</li> <li>Review Debug Output: Use <code>--log-level debug</code> to understand matching logic</li> <li>Backup Important Data: Ensure you have backups before running</li> <li>Regular Maintenance: Run periodically to maintain library consistency</li> </ol>"},{"location":"commands/fix-trash/#common-scenarios","title":"Common Scenarios","text":""},{"location":"commands/fix-trash/#incomplete-burst-deletion","title":"Incomplete Burst Deletion","text":"<pre><code># You deleted DSC_0001_BURST but DSC_0002_BURST remains\nimmich-stack fix-trash --api-key your_key\n# Output: Will move DSC_0002_BURST to trash\n</code></pre>"},{"location":"commands/fix-trash/#orphaned-raw-files","title":"Orphaned RAW Files","text":"<pre><code># You deleted IMG_1234.jpg but IMG_1234.dng remains\nimmich-stack fix-trash --api-key your_key\n# Output: Will move IMG_1234.dng to trash\n</code></pre>"},{"location":"commands/fix-trash/#see-also","title":"See Also","text":"<ul> <li>Main Stacking Command - Create stacks from your assets</li> <li>Duplicates Command - Find duplicate assets</li> <li>Stacking Logic - Understand how assets are grouped</li> <li>Custom Criteria - Configure matching rules</li> </ul>"},{"location":"contributing/development/","title":"Development Guide","text":""},{"location":"contributing/development/#directory-structure","title":"Directory Structure","text":"<pre><code>immich-auto-stack/\n\u251c\u2500\u2500 cmd/                # CLI entrypoint (main.go)\n\u251c\u2500\u2500 pkg/\n\u2502   \u251c\u2500\u2500 stacker/        # Stacking logic, types, and tests\n\u2502   \u251c\u2500\u2500 immich/         # Immich API client and integration\n\u2502   \u2514\u2500\u2500 utils/          # Utility helpers and logging\n</code></pre>"},{"location":"contributing/development/#building-locally","title":"Building Locally","text":"<pre><code># Build locally\ndocker build -t immich-stack .\n\n# Run locally\ndocker run -d \\\n  --name immich-stack \\\n  --env-file .env \\\n  -v ./logs:/app/logs \\\n  immich-stack\n</code></pre>"},{"location":"contributing/development/#code-style","title":"Code Style","text":"<ul> <li>Follow the code style and comment conventions (see code for examples)</li> <li>Add tests for new features</li> <li>Document all exported functions and types</li> </ul>"},{"location":"contributing/development/#extending","title":"Extending","text":"<ul> <li>Custom Grouping: Edit or override criteria via command-line flags or environment variables</li> <li>Custom Promotion: Set <code>--parent-filename-promote</code> and/or <code>--parent-ext-promote</code> for your workflow</li> <li>API Integration: Extend <code>pkg/immich/client.go</code> for new Immich endpoints</li> </ul>"},{"location":"contributing/development/#library-structure","title":"Library Structure","text":""},{"location":"contributing/development/#pkgstacker","title":"pkg/stacker","text":"<ul> <li>StackBy: Groups assets into stacks and sorts them based on promotion rules</li> <li>SortStack: Sorts assets in a stack by promotion and extension rules</li> <li>Types: <code>Asset</code>, <code>Stack</code>, <code>Criteria</code>, etc.</li> </ul>"},{"location":"contributing/development/#pkgimmich","title":"pkg/immich","text":"<ul> <li>Client: Handles all Immich API interactions (fetch, modify, delete stacks/assets)</li> <li>FetchAllStacks: Retrieves all stacks, with reset and cleanup logic</li> <li>FetchAssets: Retrieves all assets, paginated</li> <li>ModifyStack/DeleteStack: Stack management</li> <li>ListDuplicates: Finds and logs duplicate assets</li> </ul>"},{"location":"contributing/development/#pkgutils","title":"pkg/utils","text":"<ul> <li>helper.go: Array comparison, string cleaning</li> <li>logs.go: Colorful, structured logging helpers (info, error, debug, pretty-print)</li> </ul>"},{"location":"contributing/testing/","title":"Testing Guide","text":""},{"location":"contributing/testing/#running-tests","title":"Running Tests","text":"<p>Run all tests with:</p> <pre><code>go test ./pkg/...\n</code></pre>"},{"location":"contributing/testing/#test-structure","title":"Test Structure","text":"<p>The project uses table-driven tests for all major logic in:</p> <ul> <li><code>pkg/stacker/stacker_test.go</code></li> <li><code>pkg/immich/client_test.go</code></li> </ul>"},{"location":"contributing/testing/#test-coverage","title":"Test Coverage","text":"<p>To check test coverage:</p> <pre><code>go test -cover ./pkg/...\n</code></pre> <p>For a detailed coverage report:</p> <pre><code>go test -coverprofile=coverage.out ./pkg/...\ngo tool cover -html=coverage.out\n</code></pre>"},{"location":"contributing/testing/#writing-tests","title":"Writing Tests","text":"<p>When writing new tests:</p> <ol> <li>Use table-driven tests for similar test cases</li> <li>Test both success and failure scenarios</li> <li>Include edge cases</li> <li>Mock external dependencies</li> <li>Use descriptive test names</li> </ol> <p>Example test structure:</p> <pre><code>func TestStackBy(t *testing.T) {\n    tests := []struct {\n        name     string\n        input    []Asset\n        expected []Stack\n    }{\n        {\n            name: \"basic stacking\",\n            input: []Asset{\n                // test data\n            },\n            expected: []Stack{\n                // expected results\n            },\n        },\n        // more test cases\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            result := StackBy(tt.input)\n            // assertions\n        })\n    }\n}\n</code></pre>"},{"location":"development/command-architecture/","title":"Command Architecture","text":"<p>Immich Stack uses the Cobra framework to provide a modular, extensible command-line interface.</p>"},{"location":"development/command-architecture/#architecture-overview","title":"Architecture Overview","text":"<p>The application is structured as a multi-command CLI tool with the following hierarchy:</p> <pre><code>immich-stack (root command)\n\u251c\u2500\u2500 stack (default command)\n\u251c\u2500\u2500 duplicates\n\u251c\u2500\u2500 fix-trash\n\u251c\u2500\u2500 help\n\u2514\u2500\u2500 version\n</code></pre>"},{"location":"development/command-architecture/#file-structure","title":"File Structure","text":"<pre><code>cmd/\n\u251c\u2500\u2500 main.go          # Entry point and root command setup\n\u251c\u2500\u2500 config.go        # Shared configuration and environment loading\n\u251c\u2500\u2500 stack.go         # Main stacking command implementation\n\u251c\u2500\u2500 duplicates.go    # Duplicate detection command\n\u2514\u2500\u2500 fixtrash.go      # Fix trash consistency command\n</code></pre>"},{"location":"development/command-architecture/#command-implementation-pattern","title":"Command Implementation Pattern","text":"<p>Each command follows a consistent pattern:</p>"},{"location":"development/command-architecture/#1-command-definition","title":"1. Command Definition","text":"<pre><code>var duplicatesCmd = &amp;cobra.Command{\n    Use:   \"duplicates\",\n    Short: \"Find duplicate assets\",\n    Long:  `Detailed description...`,\n    Run:   runDuplicates,\n}\n</code></pre>"},{"location":"development/command-architecture/#2-flag-registration","title":"2. Flag Registration","text":"<pre><code>func init() {\n    duplicatesCmd.Flags().BoolVar(&amp;withArchived, \"with-archived\", false, \"Include archived assets\")\n    // ... more flags\n}\n</code></pre>"},{"location":"development/command-architecture/#3-execution-function","title":"3. Execution Function","text":"<pre><code>func runDuplicates(cmd *cobra.Command, args []string) {\n    logger := loadEnv()\n\n    // Multi-user support\n    apiKeys := parseAPIKeys(apiKey)\n\n    for _, key := range apiKeys {\n        client := immich.NewClient(...)\n        // Command-specific logic\n    }\n}\n</code></pre>"},{"location":"development/command-architecture/#shared-components","title":"Shared Components","text":""},{"location":"development/command-architecture/#configuration-loading","title":"Configuration Loading","text":"<p>The <code>loadEnv()</code> function in <code>config.go</code> handles:</p> <ul> <li>Environment variable loading</li> <li>Logger initialization</li> <li>Configuration validation</li> <li>Flag/environment precedence</li> </ul>"},{"location":"development/command-architecture/#multi-user-support","title":"Multi-User Support","text":"<p>All commands support processing multiple users:</p> <ul> <li>API keys are comma-separated</li> <li>Each user is processed sequentially</li> <li>Errors for one user don't affect others</li> </ul>"},{"location":"development/command-architecture/#client-initialization","title":"Client Initialization","text":"<p>Each command creates its own Immich client with appropriate settings:</p> <pre><code>client := immich.NewClient(\n    apiURL,\n    key,\n    resetStacks,      // Command-specific\n    replaceStacks,    // Command-specific\n    dryRun,          // Global option\n    withArchived,    // Global option\n    withDeleted,     // Global option\n    withPartners,    // Command-specific\n    logger\n)\n</code></pre>"},{"location":"development/command-architecture/#adding-new-commands","title":"Adding New Commands","text":"<p>To add a new command:</p>"},{"location":"development/command-architecture/#1-create-command-file","title":"1. Create Command File","text":"<p>Create <code>cmd/newcommand.go</code>:</p> <pre><code>package main\n\nimport (\n    \"github.com/spf13/cobra\"\n    \"github.com/majorfi/immich-stack/pkg/immich\"\n)\n\nvar newCmd = &amp;cobra.Command{\n    Use:   \"new-command\",\n    Short: \"Brief description\",\n    Long:  `Detailed description`,\n    Run:   runNewCommand,\n}\n\nfunc init() {\n    // Register command-specific flags\n    newCmd.Flags().StringVar(&amp;someFlag, \"some-flag\", \"\", \"Flag description\")\n}\n\nfunc runNewCommand(cmd *cobra.Command, args []string) {\n    logger := loadEnv()\n\n    // Implementation\n}\n</code></pre>"},{"location":"development/command-architecture/#2-register-command","title":"2. Register Command","text":"<p>In <code>cmd/main.go</code>, add to <code>init()</code>:</p> <pre><code>func init() {\n    // ... existing commands\n    rootCmd.AddCommand(newCmd)\n}\n</code></pre>"},{"location":"development/command-architecture/#3-update-documentation","title":"3. Update Documentation","text":"<ul> <li>Add command documentation in <code>docs/commands/</code></li> <li>Update <code>docs/api-reference/cli-usage.md</code></li> <li>Update <code>docs/commands/index.md</code></li> <li>Add to changelog</li> </ul>"},{"location":"development/command-architecture/#best-practices","title":"Best Practices","text":""},{"location":"development/command-architecture/#1-command-design","title":"1. Command Design","text":"<ul> <li>Keep commands focused on a single purpose</li> <li>Use descriptive names and help text</li> <li>Follow existing flag naming conventions</li> <li>Support dry-run where applicable</li> </ul>"},{"location":"development/command-architecture/#2-error-handling","title":"2. Error Handling","text":"<ul> <li>Log errors with appropriate levels</li> <li>Continue processing other users on error</li> <li>Return meaningful error messages</li> <li>Use structured logging</li> </ul>"},{"location":"development/command-architecture/#3-code-reuse","title":"3. Code Reuse","text":"<ul> <li>Use shared configuration loading</li> <li>Leverage common client initialization</li> <li>Share utility functions via packages</li> <li>Avoid duplicating logic</li> </ul>"},{"location":"development/command-architecture/#4-testing","title":"4. Testing","text":"<ul> <li>Unit test command logic separately</li> <li>Test flag parsing and validation</li> <li>Mock API calls for integration tests</li> <li>Test multi-user scenarios</li> </ul>"},{"location":"development/command-architecture/#environment-variables","title":"Environment Variables","text":"<p>All commands respect environment variables with flag precedence:</p> <pre><code>viper.BindEnv(\"api_key\", \"API_KEY\")\nviper.BindEnv(\"api_url\", \"API_URL\")\n// ... more bindings\n\n// Flags take precedence over environment\nif cmd.Flags().Changed(\"api-key\") {\n    viper.Set(\"api_key\", apiKey)\n}\n</code></pre>"},{"location":"development/command-architecture/#logging","title":"Logging","text":"<p>Commands use the shared logger configuration:</p> <pre><code>logger := loadEnv() // Initializes logger with LOG_LEVEL and LOG_FORMAT\nlogger.Info(\"Starting command...\")\nlogger.Debug(\"Detailed information...\")\nlogger.Error(\"Error occurred: %v\", err)\n</code></pre>"},{"location":"development/command-architecture/#future-considerations","title":"Future Considerations","text":""},{"location":"development/command-architecture/#potential-enhancements","title":"Potential Enhancements","text":"<ol> <li>Interactive Mode: Add interactive prompts for configuration</li> <li>Config Files: Support for configuration files</li> <li>Plugin System: Allow external command plugins</li> <li>Parallel Processing: Process multiple users concurrently</li> <li>Progress Indicators: Add progress bars for long operations</li> </ol>"},{"location":"development/command-architecture/#command-ideas","title":"Command Ideas","text":"<ul> <li><code>immich-stack stats</code> - Show stacking statistics</li> <li><code>immich-stack validate</code> - Validate stack integrity</li> <li><code>immich-stack export</code> - Export stack information</li> <li><code>immich-stack migrate</code> - Migrate from other stacking solutions</li> </ul>"},{"location":"features/cron-mode/","title":"Cron Mode","text":"<p>Cron mode enables continuous, automated stacking operations that run periodically without manual intervention. This mode is ideal for production deployments where you want to keep stacks synchronized automatically.</p>"},{"location":"features/cron-mode/#configuration","title":"Configuration","text":"<p>Enable cron mode with environment variables or CLI flags:</p> <pre><code>RUN_MODE=cron\nCRON_INTERVAL=3600  # Interval in seconds (1 hour)\n</code></pre> <p>Or using CLI flags:</p> <pre><code>./immich-stack --run-mode=cron --cron-interval=3600\n</code></pre>"},{"location":"features/cron-mode/#how-it-works","title":"How It Works","text":""},{"location":"features/cron-mode/#execution-loop","title":"Execution Loop","text":"<p>When cron mode is enabled:</p> <ol> <li>Application starts and immediately runs the first stacking operation</li> <li>After completion, waits for <code>CRON_INTERVAL</code> seconds</li> <li>Runs the next stacking operation</li> <li>Repeats indefinitely until stopped</li> </ol> <pre><code>[Start] \u2192 [Run Stacker] \u2192 [Wait CRON_INTERVAL] \u2192 [Run Stacker] \u2192 [Wait] \u2192 ...\n</code></pre>"},{"location":"features/cron-mode/#state-management","title":"State Management","text":"<p>Important: Cron mode is stateless between runs. Each execution:</p> <ul> <li>Fetches fresh data from Immich API</li> <li>Recalculates all groupings from scratch</li> <li>Makes independent stacking decisions</li> <li>Does not remember previous runs</li> </ul> <p>This stateless design ensures:</p> <ul> <li>Resilience to Immich API changes</li> <li>Self-healing from transient errors</li> <li>Consistency with manually created stacks</li> <li>No risk of state corruption</li> </ul>"},{"location":"features/cron-mode/#timing-behavior","title":"Timing Behavior","text":"<p>The interval timer starts after each run completes, not from the start time:</p> <pre><code>Run 1: [12:00:00 - 12:02:15] \u2192 Wait 3600s \u2192 Run 2: [13:02:15 - 13:04:30] \u2192 Wait 3600s \u2192 ...\n</code></pre> <p>If a run takes longer than the interval:</p> <ul> <li>The next run starts immediately after completion</li> <li>No runs are skipped</li> <li>A warning is logged if processing time exceeds 50% of the interval</li> </ul> <p>Example with long processing:</p> <pre><code>CRON_INTERVAL=3600 (1 hour)\n\nRun 1: 12:00:00 - 13:30:00 (90 minutes)\n\u26a0\ufe0f  Warning: Processing took 5400s, which exceeds interval of 3600s\nRun 2: 13:30:00 - 15:00:00 (90 minutes)\n\u26a0\ufe0f  Warning: Processing took 5400s, which exceeds interval of 3600s\n</code></pre> <p>Recommendation: Set <code>CRON_INTERVAL</code> to at least 2\u00d7 your expected processing time.</p>"},{"location":"features/cron-mode/#logging-behavior","title":"Logging Behavior","text":""},{"location":"features/cron-mode/#structured-logging","title":"Structured Logging","text":"<p>Cron mode maintains the same logging format as once mode:</p> <pre><code>LOG_LEVEL=info    # Standard log level\nLOG_FORMAT=text   # or \"json\" for structured logs\nLOG_FILE=/app/logs/immich-stack.log  # Optional file logging\n</code></pre>"},{"location":"features/cron-mode/#run-cycle-logging","title":"Run Cycle Logging","text":"<p>Each cron cycle logs:</p> <pre><code>[12:00:00] INFO Starting cron cycle\n[12:00:00] INFO Running for user: John Doe (john@example.com)\n[12:00:05] INFO Processing 5,234 assets\n...\n[12:02:15] INFO Cron cycle completed in 2m 15s\n[12:02:15] INFO Sleeping for 3600 seconds until next run\n</code></pre>"},{"location":"features/cron-mode/#multi-user-logging","title":"Multi-User Logging","text":"<p>When using multiple API keys (comma-separated), each user is processed sequentially in each cycle:</p> <pre><code>API_KEYS=key1,key2,key3\n</code></pre> <p>Logs show clear separation:</p> <pre><code>[12:00:00] INFO Running for user: Alice (alice@example.com)\n[12:01:30] INFO User Alice completed\n\n[12:01:30] INFO Running for user: Bob (bob@example.com)\n[12:03:00] INFO User Bob completed\n\n[12:03:00] INFO Running for user: Carol (carol@example.com)\n[12:04:15] INFO User Carol completed\n\n[12:04:15] INFO Sleeping for 3600 seconds until next run\n</code></pre>"},{"location":"features/cron-mode/#signal-handling","title":"Signal Handling","text":""},{"location":"features/cron-mode/#graceful-shutdown","title":"Graceful Shutdown","text":"<p>Cron mode supports graceful shutdown via signals:</p> Signal Behavior <code>SIGTERM</code> Completes current operation, then exits <code>SIGINT</code> (Ctrl+C) Completes current operation, then exits <code>SIGKILL</code> Immediate termination (not graceful) <p>Example graceful shutdown:</p> <pre><code>[12:00:00] INFO Running cron cycle\n[12:01:30] Received SIGTERM\n[12:01:30] INFO Finishing current operation before shutdown\n[12:02:15] INFO Operation completed\n[12:02:15] INFO Shutting down gracefully\n</code></pre> <p>The application:</p> <ol> <li>Receives the signal</li> <li>Completes the current stacking operation</li> <li>Does not start the next sleep cycle</li> <li>Exits cleanly</li> </ol> <p>Note: If you need immediate shutdown, use <code>SIGKILL</code> (not recommended):</p> <pre><code>docker kill -s SIGKILL immich-stack\n</code></pre>"},{"location":"features/cron-mode/#docker-signal-handling","title":"Docker Signal Handling","text":"<p>When running in Docker, ensure proper signal forwarding:</p> <p>Docker Compose (recommended):</p> <pre><code>services:\n  immich-stack:\n    image: majorfi/immich-stack:latest\n    init: true # Ensures proper signal handling\n    stop_grace_period: 5m # Allow time to finish current operation\n</code></pre> <p>Docker run:</p> <pre><code>docker run --init --stop-timeout 300 majorfi/immich-stack:latest\n</code></pre> <p>The <code>--init</code> flag ensures that the container properly forwards signals to the application.</p>"},{"location":"features/cron-mode/#operational-considerations","title":"Operational Considerations","text":""},{"location":"features/cron-mode/#monitoring","title":"Monitoring","text":"<p>Monitor cron mode health by:</p> <ol> <li>Log watching: Track completion messages and error rates</li> <li>Process health: Ensure container stays running</li> <li>API availability: Verify Immich API is reachable</li> <li>Run duration: Alert if processing time increases significantly</li> </ol> <p>Example monitoring script:</p> <pre><code># Check last successful run timestamp\ndocker logs immich-stack 2&gt;&amp;1 | grep \"Cron cycle completed\" | tail -1\n\n# Alert if no completion in last 2 hours\nif [ $(docker logs immich-stack 2&gt;&amp;1 | grep \"Cron cycle completed\" | tail -1 | cut -d' ' -f1) -lt $(date -d \"2 hours ago\" +%s) ]; then\n  echo \"ALERT: Cron hasn't completed in 2 hours\"\nfi\n</code></pre>"},{"location":"features/cron-mode/#resource-usage","title":"Resource Usage","text":"<p>Cron mode resource usage patterns:</p> <ul> <li>CPU: Spikes during processing, idle during sleep</li> <li>Memory: Constant (holds asset data during processing)</li> <li>Network: Burst during API calls, idle during sleep</li> <li>Disk: Minimal (only for optional log files)</li> </ul> <p>Expected resource usage:</p> Library Size Peak CPU Memory Network (per run) 10k assets 20-30% 200MB 50MB 50k assets 40-60% 800MB 250MB 100k assets 60-80% 1.5GB 500MB"},{"location":"features/cron-mode/#error-handling","title":"Error Handling","text":"<p>Cron mode is resilient to transient errors:</p> <p>Recoverable errors (continues running):</p> <ul> <li>API connection failures</li> <li>Rate limiting (429 responses)</li> <li>Temporary network issues</li> <li>Invalid asset data</li> </ul> <p>Fatal errors (stops running):</p> <ul> <li>Invalid API key</li> <li>Missing required configuration</li> <li>Out of memory</li> <li>Unrecoverable API errors</li> </ul> <p>Error logging:</p> <pre><code>[12:00:00] ERROR Failed to fetch assets: connection timeout\n[12:00:00] INFO Will retry in next cycle (3600s)\n[13:00:00] INFO Retrying stacking operation\n</code></pre> <p>Errors are logged but don't stop the cron loop. The next cycle will retry the operation.</p>"},{"location":"features/cron-mode/#recommended-intervals","title":"Recommended Intervals","text":"<p>Choose <code>CRON_INTERVAL</code> based on your needs:</p> Use Case Recommended Interval Reasoning Active photography studio 300-600s (5-10 min) Frequent uploads need quick stacking Personal library 3600s (1 hour) Balance freshness and resource usage Archival library 86400s (24 hours) Minimal changes, reduce API load Large library (100k+ assets) 43200s (12 hours) Long processing time, avoid overlap <p>Formula: <code>CRON_INTERVAL = (expected_processing_time \u00d7 2) + buffer</code></p> <p>Example: If processing takes 10 minutes, set interval to at least 1800s (30 minutes).</p>"},{"location":"features/cron-mode/#best-practices","title":"Best Practices","text":""},{"location":"features/cron-mode/#1-start-with-dry-run","title":"1. Start with Dry-Run","text":"<p>Test your configuration before enabling actual stacking:</p> <pre><code>RUN_MODE=cron\nCRON_INTERVAL=600\nDRY_RUN=true  # Test first!\n</code></pre> <p>Monitor logs to verify expected behavior, then disable dry-run:</p> <pre><code>DRY_RUN=false\n</code></pre>"},{"location":"features/cron-mode/#2-use-file-logging","title":"2. Use File Logging","text":"<p>Enable persistent logs for troubleshooting:</p> <pre><code>environment:\n  - LOG_FILE=/app/logs/immich-stack.log\n  - LOG_FORMAT=json # Easier to parse for monitoring\nvolumes:\n  - ./logs:/app/logs\n</code></pre>"},{"location":"features/cron-mode/#3-set-appropriate-timeouts","title":"3. Set Appropriate Timeouts","text":"<p>Ensure your interval accounts for processing time:</p> <pre><code># Bad: Interval shorter than processing time\nCRON_INTERVAL=300  # 5 minutes\n# If processing takes 10 minutes, runs overlap!\n\n# Good: Interval &gt; 2x processing time\nCRON_INTERVAL=1800  # 30 minutes for 10-minute processing\n</code></pre>"},{"location":"features/cron-mode/#4-monitor-resource-limits","title":"4. Monitor Resource Limits","text":"<p>Set Docker resource limits to prevent runaway memory usage:</p> <pre><code>services:\n  immich-stack:\n    deploy:\n      resources:\n        limits:\n          memory: 2G # Adjust based on library size\n          cpus: \"1.0\"\n</code></pre>"},{"location":"features/cron-mode/#5-plan-for-maintenance","title":"5. Plan for Maintenance","text":"<p>Schedule maintenance windows for:</p> <ul> <li>Application updates</li> <li>Configuration changes</li> <li>Immich server maintenance</li> </ul> <p>Use <code>docker stop</code> (not <code>docker kill</code>) for graceful shutdowns:</p> <pre><code># Graceful stop (waits for current operation)\ndocker stop immich-stack\n\n# Forced stop (immediate, may cause issues)\ndocker kill immich-stack  # Avoid if possible\n</code></pre>"},{"location":"features/cron-mode/#6-separate-concerns","title":"6. Separate Concerns","text":"<p>Don't combine cron mode with one-time operations:</p> <pre><code># Bad: Mixing modes\nRUN_MODE=cron\nRESET_STACKS=true  # This only works in \"once\" mode!\n\n# Good: Use once mode for resets\nRUN_MODE=once\nRESET_STACKS=true\nCONFIRM_RESET_STACK=\"I acknowledge...\"\n</code></pre> <p>After reset completes, switch back to cron mode.</p>"},{"location":"features/cron-mode/#troubleshooting","title":"Troubleshooting","text":""},{"location":"features/cron-mode/#issue-cron-runs-too-frequently","title":"Issue: Cron runs too frequently","text":"<p>Symptom: Logs show runs starting immediately after previous completion</p> <p>Cause: Processing time exceeds <code>CRON_INTERVAL</code></p> <p>Solution: Increase the interval:</p> <pre><code>CRON_INTERVAL=7200  # Double the interval\n</code></pre>"},{"location":"features/cron-mode/#issue-cron-stops-running","title":"Issue: Cron stops running","text":"<p>Symptom: No new log entries after initial runs</p> <p>Possible causes:</p> <ol> <li>Container crashed (check <code>docker ps</code>)</li> <li>Fatal error occurred (check logs: <code>docker logs immich-stack</code>)</li> <li>API key became invalid (verify key in Immich settings)</li> </ol> <p>Solution: Check logs and restart with <code>docker restart immich-stack</code></p>"},{"location":"features/cron-mode/#issue-high-memory-usage","title":"Issue: High memory usage","text":"<p>Symptom: Container OOM killed or system slowdown</p> <p>Cause: Library too large for available memory</p> <p>Solutions:</p> <ol> <li>Increase Docker memory limit</li> <li>Use simpler criteria (Legacy mode instead of Expression mode)</li> <li>Filter assets with <code>WITH_ARCHIVED=false</code> and <code>WITH_DELETED=false</code></li> <li>Increase interval to reduce memory pressure</li> </ol>"},{"location":"features/cron-mode/#issue-inconsistent-stacking-results","title":"Issue: Inconsistent stacking results","text":"<p>Symptom: Same assets grouped differently across runs</p> <p>Cause: Non-deterministic criteria or race conditions</p> <p>Solution: Ensure criteria are deterministic:</p> <ul> <li>Use specific time deltas (not relative times)</li> <li>Avoid criteria that depend on external state</li> <li>Use <code>--replace-stacks=true</code> for consistency</li> </ul>"},{"location":"features/cron-mode/#example-configurations","title":"Example Configurations","text":""},{"location":"features/cron-mode/#basic-cron-setup","title":"Basic Cron Setup","text":"<pre><code>version: \"3\"\nservices:\n  immich-stack:\n    image: majorfi/immich-stack:latest\n    init: true\n    environment:\n      - API_KEY=your_key_here\n      - API_URL=http://immich:2283/api\n      - RUN_MODE=cron\n      - CRON_INTERVAL=3600\n      - REPLACE_STACKS=true\n      - LOG_LEVEL=info\n    restart: unless-stopped\n</code></pre>"},{"location":"features/cron-mode/#advanced-cron-with-logging","title":"Advanced Cron with Logging","text":"<pre><code>version: \"3\"\nservices:\n  immich-stack:\n    image: majorfi/immich-stack:latest\n    init: true\n    stop_grace_period: 5m\n    environment:\n      - API_KEY=your_key_here\n      - API_URL=http://immich:2283/api\n      - RUN_MODE=cron\n      - CRON_INTERVAL=1800\n      - REPLACE_STACKS=true\n      - LOG_LEVEL=info\n      - LOG_FORMAT=json\n      - LOG_FILE=/app/logs/immich-stack.log\n    volumes:\n      - ./logs:/app/logs\n    deploy:\n      resources:\n        limits:\n          memory: 1G\n          cpus: \"0.5\"\n    restart: unless-stopped\n</code></pre>"},{"location":"features/cron-mode/#multi-user-cron","title":"Multi-User Cron","text":"<pre><code>version: \"3\"\nservices:\n  immich-stack:\n    image: majorfi/immich-stack:latest\n    init: true\n    environment:\n      - API_KEY=user1_key,user2_key,user3_key\n      - API_URL=http://immich:2283/api\n      - RUN_MODE=cron\n      - CRON_INTERVAL=3600\n      - REPLACE_STACKS=true\n      - LOG_LEVEL=info\n      - PARENT_FILENAME_PROMOTE=edit,raw\n    restart: unless-stopped\n</code></pre>"},{"location":"features/custom-criteria/","title":"Custom Criteria","text":"<p>Immich Stack allows you to define custom criteria for grouping photos using a JSON configuration. This gives you fine-grained control over how photos are grouped into stacks.</p>"},{"location":"features/custom-criteria/#criteria-formats","title":"Criteria Formats","text":"<p>The <code>CRITERIA</code> environment variable supports three formats with increasing complexity and power:</p>"},{"location":"features/custom-criteria/#1-legacy-array-format-simple","title":"1. Legacy Array Format (Simple)","text":"<p>Basic format where ALL criteria must match (AND logic):</p> <pre><code>[\n  {\n    \"key\": \"originalFileName\",\n    \"split\": {\n      \"delimiters\": [\"~\", \".\"],\n      \"index\": 0\n    }\n  },\n  {\n    \"key\": \"localDateTime\",\n    \"delta\": {\n      \"milliseconds\": 1000\n    }\n  }\n]\n</code></pre>"},{"location":"features/custom-criteria/#2-advanced-groups-format-medium-complexity","title":"2. Advanced Groups Format (Medium Complexity)","text":"<p>Supports multiple grouping strategies with configurable AND/OR logic per group:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"groups\": [\n    {\n      \"operator\": \"AND\",\n      \"criteria\": [\n        { \"key\": \"originalFileName\", \"regex\": { \"key\": \"PXL_\", \"index\": 0 } },\n        { \"key\": \"localDateTime\", \"delta\": { \"milliseconds\": 1000 } }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"features/custom-criteria/#3-advanced-expression-format-maximum-power","title":"3. Advanced Expression Format (Maximum Power)","text":"<p>Supports unlimited nested logical expressions with AND, OR, and NOT operations:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"operator\": \"OR\",\n        \"children\": [\n          {\n            \"criteria\": {\n              \"key\": \"originalFileName\",\n              \"regex\": { \"key\": \"PXL_\", \"index\": 0 }\n            }\n          },\n          {\n            \"criteria\": {\n              \"key\": \"originalPath\",\n              \"split\": { \"delimiters\": [\"/\"], \"index\": 2 }\n            }\n          }\n        ]\n      },\n      {\n        \"criteria\": {\n          \"key\": \"localDateTime\",\n          \"delta\": { \"milliseconds\": 1000 }\n        }\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"features/custom-criteria/#available-keys","title":"Available Keys","text":"<p>You can use any of these keys in your criteria:</p> Key Description <code>originalFileName</code> Original filename of the asset <code>originalPath</code> Original path of the asset <code>localDateTime</code> Local capture time <code>fileCreatedAt</code> File creation time <code>fileModifiedAt</code> File modification time <code>updatedAt</code> Last update time"},{"location":"features/custom-criteria/#split-configuration","title":"Split Configuration","text":"<p>The <code>split</code> configuration allows you to extract parts of string values using delimiters:</p> <pre><code>{\n  \"key\": \"originalFileName\",\n  \"split\": {\n    \"delimiters\": [\"~\", \".\"], // Array of delimiters to split on\n    \"index\": 0 // Which part to use (0-based)\n  }\n}\n</code></pre> <p>For example, with a file named <code>IMG_1234~edit.jpg</code>:</p> <ol> <li>Split on <code>~</code> and <code>.</code> gives <code>[\"IMG_1234\", \"edit\", \"jpg\"]</code></li> <li>Using <code>index: 0</code> selects <code>\"IMG_1234\"</code></li> </ol> <p>For paths, you can split by directory separators:</p> <pre><code>{\n  \"key\": \"originalPath\",\n  \"split\": {\n    \"delimiters\": [\"/\"],\n    \"index\": 2\n  }\n}\n</code></pre> <p>For a path like <code>photos/2023/vacation/IMG_001.jpg</code>:</p> <ol> <li>Split on <code>/</code> gives <code>[\"photos\", \"2023\", \"vacation\", \"IMG_001.jpg\"]</code></li> <li>Using <code>index: 2</code> selects <code>\"vacation\"</code></li> </ol> <p>Note: The <code>originalPath</code> splitter automatically normalizes Windows-style backslashes (<code>\\</code>) to forward slashes (<code>/</code>).</p>"},{"location":"features/custom-criteria/#regex-configuration","title":"Regex Configuration","text":"<p>The <code>regex</code> configuration allows you to extract parts of string values using regular expressions. This provides more powerful pattern matching than simple delimiter splitting:</p> <pre><code>{\n  \"key\": \"originalFileName\",\n  \"regex\": {\n    \"key\": \"PXL_(\\\\d{8})_(\\\\d{9})\", // Regular expression pattern\n    \"index\": 1 // Which capture group to use (0 = full match, 1+ = capture groups)\n  }\n}\n</code></pre>"},{"location":"features/custom-criteria/#regex-with-promotion","title":"Regex with Promotion","text":"<p>Regex can also be used to control the promotion order within a stack. By specifying <code>promote_index</code> and <code>promote_keys</code>, you can extract a different capture group for promotion:</p> <pre><code>{\n  \"key\": \"originalFileName\",\n  \"regex\": {\n    \"key\": \"PXL_(\\\\d{8})_(\\\\d{9})(_\\\\w+)?\", // Pattern with optional suffix\n    \"index\": 1, // Group by date (capture group 1)\n    \"promote_index\": 3, // Use suffix for promotion (capture group 3)\n    \"promote_keys\": [\"_MP\", \"_edit\", \"_crop\", \"\"] // Order of promotion (first = highest priority)\n  }\n}\n</code></pre> <p>This configuration:</p> <ul> <li>Groups files by date (capture group 1: <code>20230503</code>)</li> <li>Promotes files based on suffix (capture group 3: <code>_MP</code>, <code>_edit</code>, etc.)</li> <li>Files with <code>_MP</code> suffix become the primary asset</li> <li>Files with no suffix (empty string) have lowest priority</li> </ul> <p>For example, with a file named <code>PXL_20230503_152823814.jpg</code>:</p> <ol> <li>The regex <code>PXL_(\\\\d{8})_(\\\\d{9})</code> matches and creates capture groups:</li> <li>Index 0 (full match): <code>\"PXL_20230503_152823814\"</code></li> <li>Index 1 (first group): <code>\"20230503\"</code> (date)</li> <li>Index 2 (second group): <code>\"152823814\"</code> (time)</li> <li>Using <code>index: 1</code> selects the date <code>\"20230503\"</code></li> </ol>"},{"location":"features/custom-criteria/#regex-examples","title":"Regex Examples","text":"<p>Extract date from filename:</p> <pre><code>{\n  \"key\": \"originalFileName\",\n  \"regex\": {\n    \"key\": \"IMG_(\\\\d{8})_\\\\d{6}\",\n    \"index\": 1\n  }\n}\n</code></pre> <p>Extract year from path:</p> <pre><code>{\n  \"key\": \"originalPath\",\n  \"regex\": {\n    \"key\": \"photos/(\\\\d{4})/\",\n    \"index\": 1\n  }\n}\n</code></pre> <p>Extract camera model from filename:</p> <pre><code>{\n  \"key\": \"originalFileName\",\n  \"regex\": {\n    \"key\": \"(IMG|PXL|DSC)(\\\\d+)\",\n    \"index\": 1\n  }\n}\n</code></pre> <p>Complex path pattern matching:</p> <pre><code>{\n  \"key\": \"originalPath\",\n  \"regex\": {\n    \"key\": \"camera_uploads/(\\\\d{4}-\\\\d{2}-\\\\d{2})/DCIM/([^/]+)/\",\n    \"index\": 1\n  }\n}\n</code></pre>"},{"location":"features/custom-criteria/#regex-vs-split","title":"Regex vs Split","text":"Feature Split Regex Complexity Simple delimiter-based Powerful pattern matching Use Case Fixed delimiters Complex patterns, validation Performance Faster Slightly slower Learning Easy Requires regex knowledge <p>Choose split for simple cases like separating by <code>~</code>, <code>.</code>, or <code>/</code>. Choose regex for complex patterns like extracting dates, validating formats, or advanced text processing.</p>"},{"location":"features/custom-criteria/#expression-format-deep-dive","title":"Expression Format Deep Dive","text":"<p>The advanced expression format provides the most powerful grouping capabilities through recursive logical expressions.</p>"},{"location":"features/custom-criteria/#expression-structure","title":"Expression Structure","text":"<p>Each expression node has one of two forms:</p> <p>Criteria Node (Leaf):</p> <pre><code>{\n  \"criteria\": {\n    \"key\": \"originalFileName\",\n    \"regex\": { \"key\": \"PXL_\", \"index\": 0 }\n  }\n}\n</code></pre> <p>Operator Node (Branch):</p> <pre><code>{\n  \"operator\": \"AND\",\n  \"children\": [\n    // Array of child expressions\n  ]\n}\n</code></pre>"},{"location":"features/custom-criteria/#supported-operators","title":"Supported Operators","text":"Operator Description Children Required <code>AND</code> All children must match 1 or more <code>OR</code> At least one child must match 1 or more <code>NOT</code> Child must NOT match Exactly 1"},{"location":"features/custom-criteria/#expression-examples","title":"Expression Examples","text":"<p>Simple AND condition:</p> <pre><code>{\n  \"operator\": \"AND\",\n  \"children\": [\n    {\n      \"criteria\": {\n        \"key\": \"originalFileName\",\n        \"regex\": { \"key\": \"PXL_\", \"index\": 0 }\n      }\n    },\n    {\n      \"criteria\": { \"key\": \"localDateTime\", \"delta\": { \"milliseconds\": 1000 } }\n    }\n  ]\n}\n</code></pre> <p>OR condition for multiple camera types:</p> <pre><code>{\n  \"operator\": \"OR\",\n  \"children\": [\n    {\n      \"criteria\": {\n        \"key\": \"originalFileName\",\n        \"regex\": { \"key\": \"PXL_\", \"index\": 0 }\n      }\n    },\n    {\n      \"criteria\": {\n        \"key\": \"originalFileName\",\n        \"regex\": { \"key\": \"IMG_\", \"index\": 0 }\n      }\n    },\n    {\n      \"criteria\": {\n        \"key\": \"originalFileName\",\n        \"regex\": { \"key\": \"DSC\", \"index\": 0 }\n      }\n    }\n  ]\n}\n</code></pre> <p>NOT condition to exclude archived photos:</p> <pre><code>{\n  \"operator\": \"NOT\",\n  \"children\": [{ \"criteria\": { \"key\": \"isArchived\" } }]\n}\n</code></pre> <p>Complex nested expression:</p> <pre><code>{\n  \"operator\": \"AND\",\n  \"children\": [\n    {\n      \"operator\": \"OR\",\n      \"children\": [\n        {\n          \"criteria\": {\n            \"key\": \"originalFileName\",\n            \"regex\": { \"key\": \"PXL_\", \"index\": 0 }\n          }\n        },\n        {\n          \"criteria\": {\n            \"key\": \"originalFileName\",\n            \"regex\": { \"key\": \"IMG_\", \"index\": 0 }\n          }\n        }\n      ]\n    },\n    {\n      \"operator\": \"NOT\",\n      \"children\": [{ \"criteria\": { \"key\": \"isArchived\" } }]\n    },\n    {\n      \"criteria\": { \"key\": \"localDateTime\", \"delta\": { \"milliseconds\": 2000 } }\n    }\n  ]\n}\n</code></pre> <p>This complex example groups assets that:</p> <ol> <li>Have filenames starting with \"PXL*\" OR \"IMG*\"</li> <li>AND are NOT archived</li> <li>AND were taken within 2 seconds of each other</li> </ol>"},{"location":"features/custom-criteria/#delta-configuration","title":"Delta Configuration","text":"<p>The <code>delta</code> configuration allows for flexible time matching:</p> <pre><code>{\n  \"key\": \"localDateTime\",\n  \"delta\": {\n    \"milliseconds\": 1000 // Time difference to allow (in milliseconds)\n  }\n}\n</code></pre> <p>This is useful for:</p> <ul> <li>Burst photos</li> <li>Photos taken in quick succession</li> <li>Different time zones</li> <li>Camera clock differences</li> </ul>"},{"location":"features/custom-criteria/#examples-by-format","title":"Examples by Format","text":""},{"location":"features/custom-criteria/#legacy-array-format-examples","title":"Legacy Array Format Examples","text":"<p>Basic Filename Grouping:</p> <pre><code>[\n  {\n    \"key\": \"originalFileName\",\n    \"split\": {\n      \"delimiters\": [\"~\", \".\"],\n      \"index\": 0\n    }\n  }\n]\n</code></pre> <p>Regex-Based Date Grouping:</p> <pre><code>[\n  {\n    \"key\": \"originalFileName\",\n    \"regex\": {\n      \"key\": \"PXL_(\\\\d{8})_\\\\d{9}\",\n      \"index\": 1\n    }\n  }\n]\n</code></pre> <p>Combined Path and Time Criteria:</p> <pre><code>[\n  {\n    \"key\": \"originalPath\",\n    \"split\": {\n      \"delimiters\": [\"/\"],\n      \"index\": 2\n    }\n  },\n  {\n    \"key\": \"localDateTime\",\n    \"delta\": {\n      \"milliseconds\": 1000\n    }\n  }\n]\n</code></pre>"},{"location":"features/custom-criteria/#advanced-groups-format-examples","title":"Advanced Groups Format Examples","text":"<p>Multiple Camera Types with OR Logic:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"groups\": [\n    {\n      \"operator\": \"OR\",\n      \"criteria\": [\n        { \"key\": \"originalFileName\", \"regex\": { \"key\": \"PXL_\", \"index\": 0 } },\n        { \"key\": \"originalFileName\", \"regex\": { \"key\": \"IMG_\", \"index\": 0 } },\n        { \"key\": \"originalFileName\", \"regex\": { \"key\": \"DSC\", \"index\": 0 } }\n      ]\n    }\n  ]\n}\n</code></pre> <p>Group by Directory OR Timestamp:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"groups\": [\n    {\n      \"operator\": \"OR\",\n      \"criteria\": [\n        { \"key\": \"originalPath\", \"split\": { \"delimiters\": [\"/\"], \"index\": 2 } },\n        { \"key\": \"localDateTime\", \"delta\": { \"milliseconds\": 1000 } }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"features/custom-criteria/#advanced-expression-format-examples","title":"Advanced Expression Format Examples","text":"<p>Complex Multi-Camera Setup:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"operator\": \"OR\",\n        \"children\": [\n          {\n            \"criteria\": {\n              \"key\": \"originalFileName\",\n              \"regex\": { \"key\": \"PXL_(\\\\d{8})\", \"index\": 1 }\n            }\n          },\n          {\n            \"criteria\": {\n              \"key\": \"originalFileName\",\n              \"regex\": { \"key\": \"IMG_(\\\\d{8})\", \"index\": 1 }\n            }\n          }\n        ]\n      },\n      {\n        \"criteria\": {\n          \"key\": \"localDateTime\",\n          \"delta\": { \"milliseconds\": 2000 }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>This groups photos from Pixel or iPhone cameras that were taken on the same date AND within 2 seconds of each other.</p> <p>Exclude Archived Photos from Grouping:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"criteria\": {\n          \"key\": \"originalFileName\",\n          \"split\": { \"delimiters\": [\"~\", \".\"], \"index\": 0 }\n        }\n      },\n      {\n        \"operator\": \"NOT\",\n        \"children\": [{ \"criteria\": { \"key\": \"isArchived\" } }]\n      }\n    ]\n  }\n}\n</code></pre> <p>Advanced Professional Workflow:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"operator\": \"OR\",\n        \"children\": [\n          {\n            \"operator\": \"AND\",\n            \"children\": [\n              {\n                \"criteria\": {\n                  \"key\": \"originalPath\",\n                  \"regex\": { \"key\": \"/RAW/\", \"index\": 0 }\n                }\n              },\n              {\n                \"criteria\": {\n                  \"key\": \"originalFileName\",\n                  \"regex\": { \"key\": \"\\\\.(CR3|NEF|ARW)$\", \"index\": 0 }\n                }\n              }\n            ]\n          },\n          {\n            \"operator\": \"AND\",\n            \"children\": [\n              {\n                \"criteria\": {\n                  \"key\": \"originalPath\",\n                  \"regex\": { \"key\": \"/JPEG/\", \"index\": 0 }\n                }\n              },\n              {\n                \"criteria\": {\n                  \"key\": \"originalFileName\",\n                  \"regex\": { \"key\": \"\\\\.jpe?g$\", \"index\": 0 }\n                }\n              }\n            ]\n          }\n        ]\n      },\n      {\n        \"criteria\": {\n          \"key\": \"localDateTime\",\n          \"delta\": { \"milliseconds\": 5000 }\n        }\n      },\n      {\n        \"operator\": \"NOT\",\n        \"children\": [{ \"criteria\": { \"key\": \"isTrashed\" } }]\n      }\n    ]\n  }\n}\n</code></pre> <p>This complex professional workflow:</p> <ol> <li>Groups either (RAW files in /RAW/ folder) OR (JPEG files in /JPEG/ folder)</li> <li>AND taken within 5 seconds</li> <li>AND NOT in trash</li> </ol>"},{"location":"features/custom-criteria/#advanced-grouping-behavior","title":"Advanced Grouping Behavior","text":""},{"location":"features/custom-criteria/#expression-based-grouping","title":"Expression-Based Grouping","text":"<p>Advanced mode with expressions performs both filtering and grouping based on the leaf criteria values that actually match for each asset:</p> <ol> <li>Filter phase: Only assets that match the expression are considered for stacking</li> <li>Grouping phase: Matching assets are grouped by the specific criteria values that contributed to their match</li> <li>Sorting phase: Each group is sorted using the same promotion/delimiter rules as legacy mode</li> </ol> <p>Key differences from legacy mode:</p> <ul> <li>Regex criteria: Use the matched portion as the grouping key (e.g., <code>PXL_</code> instead of full filename)</li> <li>OR branches: Only values from the first matching branch are included in the grouping key</li> <li>NOT operations: Contribute no values to grouping keys (used purely for filtering)</li> </ul> <p>Note: In OR expressions, only the first matching branch contributes to the grouping key. Branch order matters\u2014criteria are evaluated in the order they appear in the expression.</p>"},{"location":"features/custom-criteria/#or-branch-order-impact","title":"OR Branch Order Impact","text":"<p>When using OR expressions, the order of branches is critical because only the first matching branch contributes values to the grouping key. This means assets will be grouped differently depending on which branch matches first.</p> <p>Example - Order affects grouping:</p> <p>Consider these assets:</p> <ul> <li><code>IMG_001.jpg</code> (in <code>/photos/2023/</code> folder)</li> <li><code>IMG_002.jpg</code> (in <code>/photos/2023/</code> folder)</li> <li><code>PXL_001.jpg</code> (in <code>/photos/2024/</code> folder)</li> </ul> <p>Configuration A (filename first):</p> <pre><code>{\n  \"operator\": \"OR\",\n  \"children\": [\n    {\n      \"criteria\": {\n        \"key\": \"originalFileName\",\n        \"regex\": { \"key\": \"^([A-Z]+)_\", \"index\": 1 }\n      }\n    },\n    {\n      \"criteria\": {\n        \"key\": \"originalPath\",\n        \"regex\": { \"key\": \"(\\\\d{4})\", \"index\": 1 }\n      }\n    }\n  ]\n}\n</code></pre> <p>Resulting grouping keys:</p> <ul> <li><code>IMG_001.jpg</code> \u2192 <code>originalFileName=IMG</code> (first branch matched)</li> <li><code>IMG_002.jpg</code> \u2192 <code>originalFileName=IMG</code> (first branch matched)</li> <li><code>PXL_001.jpg</code> \u2192 <code>originalFileName=PXL</code> (first branch matched)</li> </ul> <p>Result: 2 stacks (IMG group + PXL group)</p> <p>Configuration B (path first):</p> <pre><code>{\n  \"operator\": \"OR\",\n  \"children\": [\n    {\n      \"criteria\": {\n        \"key\": \"originalPath\",\n        \"regex\": { \"key\": \"(\\\\d{4})\", \"index\": 1 }\n      }\n    },\n    {\n      \"criteria\": {\n        \"key\": \"originalFileName\",\n        \"regex\": { \"key\": \"^([A-Z]+)_\", \"index\": 1 }\n      }\n    }\n  ]\n}\n</code></pre> <p>Resulting grouping keys:</p> <ul> <li><code>IMG_001.jpg</code> \u2192 <code>originalPath=2023</code> (first branch matched)</li> <li><code>IMG_002.jpg</code> \u2192 <code>originalPath=2023</code> (first branch matched)</li> <li><code>PXL_001.jpg</code> \u2192 <code>originalPath=2024</code> (first branch matched)</li> </ul> <p>Result: 2 different stacks (2023 group + 2024 group)</p> <p>\ud83d\udca1 Best Practice: Put your most specific/preferred grouping criteria first in OR expressions. For example, if you want to primarily group by camera model but fall back to date, put the camera model criterion first.</p> <p>Example - Multiple stacks from one expression:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"operator\": \"OR\",\n        \"children\": [\n          {\n            \"criteria\": {\n              \"key\": \"originalFileName\",\n              \"regex\": { \"key\": \"^PXL_\", \"index\": 0 }\n            }\n          },\n          {\n            \"criteria\": {\n              \"key\": \"originalFileName\",\n              \"regex\": { \"key\": \"^IMG_\", \"index\": 0 }\n            }\n          }\n        ]\n      },\n      {\n        \"criteria\": {\n          \"key\": \"localDateTime\",\n          \"delta\": { \"milliseconds\": 1000 }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>This creates separate stacks for:</p> <ul> <li>All PXL photos taken within the same time window: <code>originalFileName=PXL_|localDateTime=2023-01-01T12:00:00.000000000Z</code></li> <li>All IMG photos taken within the same time window: <code>originalFileName=IMG_|localDateTime=2023-01-01T12:00:00.000000000Z</code></li> </ul>"},{"location":"features/custom-criteria/#or-groups-union-semantics","title":"OR Groups Union Semantics","text":"<p>In groups-based advanced mode, OR groups use \"union\" semantics instead of \"exact match\" semantics:</p> <ul> <li>Legacy behavior: Assets must share identical matching criteria to be grouped</li> <li>Advanced behavior: Assets are grouped if they share ANY matching criteria from OR groups</li> </ul> <p>This creates connected components where assets that share any criteria keys are linked together.</p> <p>Example:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"groups\": [\n    {\n      \"operator\": \"OR\",\n      \"criteria\": [\n        { \"key\": \"originalPath\", \"split\": { \"delimiters\": [\"/\"], \"index\": 2 } },\n        { \"key\": \"localDateTime\", \"delta\": { \"milliseconds\": 1000 } }\n      ]\n    }\n  ]\n}\n</code></pre> <p>Assets that share either the same folder OR the same time window will be connected and grouped together, even if they don't share both criteria.</p>"},{"location":"features/custom-criteria/#biggestnumber-support-in-advanced-mode","title":"BiggestNumber Support in Advanced Mode","text":"<p>For <code>biggestNumber</code> sorting to work in advanced mode, you must specify <code>delimiters</code> in the <code>originalFileName.split.delimiters</code> configuration:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"criteria\": {\n      \"key\": \"originalFileName\",\n      \"split\": { \"delimiters\": [\"~\", \".\"], \"index\": 0 }\n    }\n  }\n}\n</code></pre> <p>Without delimiters specified, <code>biggestNumber</code> sorting falls back to alphabetical ordering.</p>"},{"location":"features/custom-criteria/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Start Simple:</p> </li> <li> <p>Begin with basic filename grouping</p> </li> <li>Add time-based criteria if needed</li> <li> <p>Test with small sets first</p> </li> <li> <p>Delta Values:</p> </li> <li> <p>Use smaller deltas for burst photos (1000ms)</p> </li> <li>Use larger deltas for time zone differences (3600000ms = 1 hour)</li> <li> <p>Consider your camera's burst mode settings</p> </li> <li> <p>Regex Considerations:</p> </li> <li> <p>Escape special characters properly (<code>\\\\d</code> for digits, <code>\\\\.</code> for literal dots)</p> </li> <li>Test your regex patterns with sample filenames first</li> <li>Use online regex testers to validate patterns</li> <li> <p>Remember that index 0 is the full match, capture groups start at index 1</p> </li> <li> <p>Boolean Criteria (Advanced Mode):</p> </li> <li> <p>Boolean criteria (<code>isArchived</code>, <code>isFavorite</code>, <code>isTrashed</code>, etc.) are filter-only</p> </li> <li>They don't contribute values to grouping keys\u2014used purely for inclusion/exclusion</li> <li> <p>Use them to filter assets before applying other grouping criteria</p> </li> <li> <p>Testing:</p> </li> <li> <p>Use <code>DRY_RUN=true</code> to test configurations</p> </li> <li>Check logs for grouping results</li> <li>Adjust criteria based on results</li> </ol>"},{"location":"features/custom-criteria/#common-gotchas","title":"Common Gotchas","text":"<p>\u26a0\ufe0f Important Behaviors to Remember:</p> <ul> <li>OR branch order matters: Only the first matching OR branch contributes to grouping keys</li> <li>Boolean criteria are filter-only: <code>isArchived</code>, <code>isFavorite</code>, etc. don't contribute grouping values</li> <li>biggestNumber in advanced mode: Requires <code>filename.split.delimiters</code> to be specified in the expression/criteria</li> </ul>"},{"location":"features/custom-criteria/#common-regex-patterns","title":"Common Regex Patterns","text":"<p>Here are some useful regex patterns for common filename formats:</p> <pre><code>// Google Pixel photos: PXL_20230503_152823814.jpg\n{\n  \"key\": \"originalFileName\",\n  \"regex\": {\n    \"key\": \"PXL_(\\\\d{8})_(\\\\d{9})\",\n    \"index\": 1  // Extract date: 20230503\n  }\n}\n\n// iPhone photos: IMG_20230503_152823.jpg\n{\n  \"key\": \"originalFileName\",\n  \"regex\": {\n    \"key\": \"IMG_(\\\\d{8})_(\\\\d{6})\",\n    \"index\": 1  // Extract date: 20230503\n  }\n}\n\n// Canon photos: DSC01234.jpg\n{\n  \"key\": \"originalFileName\",\n  \"regex\": {\n    \"key\": \"(DSC)(\\\\d+)\",\n    \"index\": 2  // Extract number: 01234\n  }\n}\n\n// Date-time from path: photos/2023-05-03/\n{\n  \"key\": \"originalPath\",\n  \"regex\": {\n    \"key\": \"photos/(\\\\d{4}-\\\\d{2}-\\\\d{2})/\",\n    \"index\": 1  // Extract date: 2023-05-03\n  }\n}\n</code></pre>"},{"location":"features/custom-criteria/#complete-example-regex-promotion-for-pixel-photos","title":"Complete Example: Regex Promotion for Pixel Photos","text":"<p>Imagine you have Google Pixel photos with different processing suffixes:</p> <pre><code>photos/\n\u251c\u2500\u2500 PXL_20230503_152823814.jpg        # Original\n\u251c\u2500\u2500 PXL_20230503_152823814_MP.jpg     # Motion Photo\n\u251c\u2500\u2500 PXL_20230503_152823814_edit.jpg   # Edited version\n\u251c\u2500\u2500 PXL_20230503_152823814_crop.jpg   # Cropped version\n\u251c\u2500\u2500 PXL_20230504_091234567.jpg        # Different photo\n\u2514\u2500\u2500 PXL_20230504_091234567_MP.jpg     # Its Motion Photo\n</code></pre> <p>You want to:</p> <ol> <li>Group photos by date and time</li> <li>Prioritize Motion Photos (_MP) as primary assets</li> <li>Then edited versions, then cropped, then originals</li> </ol> <p>Configuration:</p> <pre><code>[\n  {\n    \"key\": \"originalFileName\",\n    \"regex\": {\n      \"key\": \"(PXL_\\\\d{8}_\\\\d{9})(_\\\\w+)?\\\\.(jpg|JPG)\",\n      \"index\": 1, // Group by base filename\n      \"promote_index\": 2, // Use suffix for promotion\n      \"promote_keys\": [\"_MP\", \"_edit\", \"_crop\", \"\"]\n    }\n  }\n]\n</code></pre> <p>Result:</p> <ul> <li>Stack 1: Primary: <code>PXL_20230503_152823814_MP.jpg</code>, Others: <code>_edit</code>, <code>_crop</code>, original</li> <li>Stack 2: Primary: <code>PXL_20230504_091234567_MP.jpg</code>, Others: original</li> </ul>"},{"location":"features/custom-criteria/#complete-example-multi-camera-setup","title":"Complete Example: Multi-Camera Setup","text":"<p>Imagine you have photos from multiple cameras with different naming conventions, all organized in date-based folders:</p> <pre><code>photos/\n\u251c\u2500\u2500 2023-05-03/\n\u2502   \u251c\u2500\u2500 PXL_20230503_152823814.jpg       # Google Pixel\n\u2502   \u251c\u2500\u2500 PXL_20230503_152823814.dng       # Pixel RAW\n\u2502   \u251c\u2500\u2500 IMG_20230503_152830.jpg          # iPhone\n\u2502   \u251c\u2500\u2500 IMG_20230503_152830.heic         # iPhone RAW\n\u2502   \u2514\u2500\u2500 DSC01234.jpg                     # Canon\n\u2514\u2500\u2500 2023-05-04/\n    \u251c\u2500\u2500 PXL_20230504_091234567.jpg\n    \u2514\u2500\u2500 IMG_20230504_091240.jpg\n</code></pre> <p>You want to:</p> <ol> <li>Group Pixel photos (JPG + DNG) by date</li> <li>Group iPhone photos (JPG + HEIC) by date</li> <li>Group photos within the same date folder</li> </ol> <p>Configuration:</p> <pre><code>[\n  {\n    \"key\": \"originalFileName\",\n    \"regex\": {\n      \"key\": \"(PXL|IMG)_(\\\\d{8})_\\\\d+\",\n      \"index\": 2\n    }\n  },\n  {\n    \"key\": \"originalPath\",\n    \"regex\": {\n      \"key\": \"photos/(\\\\d{4}-\\\\d{2}-\\\\d{2})/\",\n      \"index\": 1\n    }\n  }\n]\n</code></pre> <p>Result:</p> <ul> <li><code>PXL_20230503_152823814.jpg</code> and <code>PXL_20230503_152823814.dng</code> \u2192 grouped by date \"20230503\" and folder \"2023-05-03\"</li> <li><code>IMG_20230503_152830.jpg</code> and <code>IMG_20230503_152830.heic</code> \u2192 grouped by date \"20230503\" and folder \"2023-05-03\"</li> <li>Photos from different dates remain separate even if taken at similar times</li> </ul> <p>This approach gives you precise control over grouping logic while handling multiple camera formats automatically.</p>"},{"location":"features/custom-criteria/#advanced-examples-and-patterns","title":"Advanced Examples and Patterns","text":""},{"location":"features/custom-criteria/#complex-nested-logic-with-multiple-operators","title":"Complex Nested Logic with Multiple Operators","text":"<p>This example shows a 4-level nested expression combining AND, OR, and NOT operators for a professional photography workflow:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"operator\": \"OR\",\n        \"children\": [\n          {\n            \"operator\": \"AND\",\n            \"children\": [\n              {\n                \"criteria\": {\n                  \"key\": \"originalFileName\",\n                  \"regex\": { \"key\": \"^(PXL|IMG)_\", \"index\": 1 }\n                }\n              },\n              {\n                \"criteria\": {\n                  \"key\": \"localDateTime\",\n                  \"delta\": { \"milliseconds\": 1000 }\n                }\n              }\n            ]\n          },\n          {\n            \"operator\": \"AND\",\n            \"children\": [\n              {\n                \"criteria\": {\n                  \"key\": \"originalPath\",\n                  \"regex\": { \"key\": \"/burst/\", \"index\": 0 }\n                }\n              },\n              {\n                \"criteria\": {\n                  \"key\": \"localDateTime\",\n                  \"delta\": { \"milliseconds\": 500 }\n                }\n              }\n            ]\n          }\n        ]\n      },\n      {\n        \"operator\": \"NOT\",\n        \"children\": [\n          {\n            \"criteria\": {\n              \"key\": \"originalFileName\",\n              \"regex\": { \"key\": \"_draft|_test\", \"index\": 0 }\n            }\n          }\n        ]\n      },\n      {\n        \"operator\": \"NOT\",\n        \"children\": [{ \"criteria\": { \"key\": \"isTrashed\" } }]\n      }\n    ]\n  }\n}\n</code></pre> <p>This expression groups photos that:</p> <ol> <li>(Match smartphone camera patterns within 1 second) OR (are in burst folder within 500ms)</li> <li>AND do NOT have \"draft\" or \"test\" in the filename</li> <li>AND are NOT trashed</li> </ol>"},{"location":"features/custom-criteria/#sequence-detection-with-non-numeric-files","title":"Sequence Detection with Non-Numeric Files","text":"<p>Use the <code>sequence</code> keyword to handle sequence detection even with complex non-numeric patterns:</p> <p>Scenario 1: Files with alphanumeric sequences</p> <pre><code>Files:\n- photo_a001_final.jpg\n- photo_a002_final.jpg\n- photo_a003_final.jpg\n- photo_b001_final.jpg\n</code></pre> <pre><code>PARENT_FILENAME_PROMOTE=sequence\n</code></pre> <p>Result: Sequences are detected by numeric portions regardless of surrounding text.</p> <p>Scenario 2: Mixed sequence patterns with specific prefix</p> <pre><code>Files:\n- burst_IMG_0001.jpg\n- burst_IMG_0002.jpg\n- burst_PXL_0001.jpg\n</code></pre> <pre><code># Only order IMG sequences\nPARENT_FILENAME_PROMOTE=sequence:IMG_\n</code></pre> <p>Result: Only IMG sequences are ordered numerically; PXL files follow standard promotion rules.</p> <p>Scenario 3: Complex filenames with embedded sequences</p> <pre><code>Files:\n- 2023-05-03_0001_vacation.jpg\n- 2023-05-03_0002_vacation.jpg\n- 2023-05-03_0010_vacation.jpg\n- 2023-05-03_0100_vacation.jpg\n</code></pre> <pre><code>[\n  {\n    \"key\": \"originalFileName\",\n    \"regex\": {\n      \"key\": \"(\\\\d{4}-\\\\d{2}-\\\\d{2})_(\\\\d+)_\",\n      \"index\": 1\n    }\n  },\n  {\n    \"key\": \"localDateTime\",\n    \"delta\": { \"milliseconds\": 2000 }\n  }\n]\n</code></pre> <pre><code>PARENT_FILENAME_PROMOTE=sequence\n</code></pre> <p>Result: Photos are grouped by date, then ordered by sequence number.</p>"},{"location":"features/custom-criteria/#custom-error-handling-patterns","title":"Custom Error Handling Patterns","text":"<p>Pattern 1: Graceful Degradation with OR</p> <p>If primary grouping fails, fall back to secondary criteria:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"OR\",\n    \"children\": [\n      {\n        \"criteria\": {\n          \"key\": \"originalFileName\",\n          \"regex\": { \"key\": \"^PXL_(\\\\d{8})_\", \"index\": 1 }\n        }\n      },\n      {\n        \"criteria\": {\n          \"key\": \"localDateTime\",\n          \"delta\": { \"milliseconds\": 5000 }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>Behavior: If filename doesn't match pattern (corrupted or renamed files), group by timestamp instead.</p> <p>Pattern 2: Safe Filtering with NOT</p> <p>Exclude problematic assets from processing:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"criteria\": {\n          \"key\": \"originalFileName\",\n          \"split\": { \"delimiters\": [\".\"], \"index\": 0 }\n        }\n      },\n      {\n        \"operator\": \"NOT\",\n        \"children\": [\n          {\n            \"criteria\": {\n              \"key\": \"originalFileName\",\n              \"regex\": { \"key\": \"\\\\.(tmp|bak|~)$\", \"index\": 0 }\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> <p>Behavior: Process all files EXCEPT temporary/backup files that might cause errors.</p> <p>Pattern 3: Validated Processing</p> <p>Ensure assets meet minimum requirements before grouping:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"criteria\": {\n          \"key\": \"originalFileName\",\n          \"regex\": { \"key\": \"^[A-Z]{3,4}_\\\\d{8}_\\\\d{6,9}\\\\.\", \"index\": 0 }\n        }\n      },\n      {\n        \"operator\": \"NOT\",\n        \"children\": [{ \"criteria\": { \"key\": \"isTrashed\" } }]\n      },\n      {\n        \"criteria\": {\n          \"key\": \"localDateTime\",\n          \"delta\": { \"milliseconds\": 1000 }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>Behavior: Only group files with valid camera filename format, not trashed, and with proper timestamps.</p>"},{"location":"features/custom-criteria/#performance-tuning-for-large-libraries","title":"Performance Tuning for Large Libraries","text":"<p>Pattern 1: Optimized for 100k+ Assets</p> <p>For very large libraries, use Legacy mode with simple criteria:</p> <pre><code>[\n  {\n    \"key\": \"originalFileName\",\n    \"split\": {\n      \"delimiters\": [\".\"],\n      \"index\": 0\n    }\n  }\n]\n</code></pre> <p>Performance: O(n) complexity, ~100-150 assets/second on typical hardware.</p> <p>Pattern 2: Balanced Performance and Flexibility (50k-100k assets)</p> <p>Use Groups mode with limited criteria:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"groups\": [\n    {\n      \"operator\": \"AND\",\n      \"criteria\": [\n        {\n          \"key\": \"originalFileName\",\n          \"split\": { \"delimiters\": [\".\"], \"index\": 0 }\n        },\n        { \"key\": \"localDateTime\", \"delta\": { \"milliseconds\": 2000 } }\n      ]\n    }\n  ]\n}\n</code></pre> <p>Performance: O(n \u00d7 2) complexity, ~75-100 assets/second.</p> <p>Pattern 3: Optimized Regex for Performance</p> <p>Use anchored regex patterns to reduce backtracking:</p> <pre><code>{\n  \"key\": \"originalFileName\",\n  \"regex\": {\n    \"key\": \"^PXL_(\\\\d{8})_\",\n    \"index\": 1\n  }\n}\n</code></pre> <p>Fast (anchored with <code>^</code>):</p> <ul> <li>Immediately fails on non-matching files</li> <li>No backtracking through entire filename</li> </ul> <p>Slow (unanchored):</p> <pre><code>{\n  \"key\": \"originalFileName\",\n  \"regex\": {\n    \"key\": \".*PXL.*\",\n    \"index\": 0\n  }\n}\n</code></pre> <ul> <li>Tests every position in filename</li> <li>Creates many backtracking points</li> </ul> <p>Pattern 4: Chunked Processing for Memory Constraints</p> <p>For libraries &gt; 200k assets with limited RAM, process in date-based chunks:</p> <pre><code>[\n  {\n    \"key\": \"originalFileName\",\n    \"regex\": {\n      \"key\": \"^[A-Z]{3}_2025\",\n      \"index\": 0\n    }\n  },\n  {\n    \"key\": \"localDateTime\",\n    \"delta\": { \"milliseconds\": 1000 }\n  }\n]\n</code></pre> <p>Process one year at a time:</p> <pre><code># First run: 2025 photos\nCRITERIA='[{\"key\":\"originalFileName\",\"regex\":{\"key\":\"^[A-Z]{3}_2025\",\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]'\n\n# Second run: 2024 photos\nCRITERIA='[{\"key\":\"originalFileName\",\"regex\":{\"key\":\"^[A-Z]{3}_2024\",\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]'\n</code></pre> <p>Result: Lower memory usage, more manageable processing.</p> <p>Pattern 5: Time Delta Optimization</p> <p>Choose delta based on use case and library size:</p> <pre><code>// Small library (&lt; 10k), tight grouping\n{\"key\": \"localDateTime\", \"delta\": {\"milliseconds\": 500}}\n\n// Medium library (10k-50k), balanced\n{\"key\": \"localDateTime\", \"delta\": {\"milliseconds\": 1000}}\n\n// Large library (50k-100k), loose grouping\n{\"key\": \"localDateTime\", \"delta\": {\"milliseconds\": 2000}}\n\n// Very large library (&gt; 100k), performance-focused\n{\"key\": \"localDateTime\", \"delta\": {\"milliseconds\": 5000}}\n</code></pre> <p>Trade-off: Larger deltas = fewer groups = faster processing, but less precise grouping.</p>"},{"location":"features/custom-criteria/#real-world-scenario-examples","title":"Real-World Scenario Examples","text":"<p>Scenario 1: Event Photography Studio</p> <p>Mixing multiple cameras, burst photos, and RAW+JPEG pairs:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"operator\": \"OR\",\n        \"children\": [\n          {\n            \"criteria\": {\n              \"key\": \"originalFileName\",\n              \"regex\": { \"key\": \"^(DSC|IMG|PXL)_\", \"index\": 1 }\n            }\n          },\n          {\n            \"criteria\": {\n              \"key\": \"originalPath\",\n              \"regex\": { \"key\": \"/events/\\\\d{4}-\\\\d{2}-\\\\d{2}/\", \"index\": 0 }\n            }\n          }\n        ]\n      },\n      {\n        \"criteria\": {\n          \"key\": \"localDateTime\",\n          \"delta\": { \"milliseconds\": 2000 }\n        }\n      },\n      {\n        \"operator\": \"NOT\",\n        \"children\": [{ \"criteria\": { \"key\": \"isArchived\" } }]\n      }\n    ]\n  }\n}\n</code></pre> <pre><code>PARENT_FILENAME_PROMOTE=edit,final,sequence\nPARENT_EXT_PROMOTE=.jpg,.jpeg,.raw,.cr3\n</code></pre> <p>Scenario 2: Travel Photography with Multiple Locations</p> <p>Group by location folder and date, prioritize edited versions:</p> <pre><code>[\n  {\n    \"key\": \"originalPath\",\n    \"split\": {\n      \"delimiters\": [\"/\"],\n      \"index\": 3\n    }\n  },\n  {\n    \"key\": \"originalFileName\",\n    \"regex\": {\n      \"key\": \"(\\\\d{8})\",\n      \"index\": 1\n    }\n  },\n  {\n    \"key\": \"localDateTime\",\n    \"delta\": { \"milliseconds\": 3600000 }\n  }\n]\n</code></pre> <pre><code>PARENT_FILENAME_PROMOTE=edit,lightroom,final,,sequence\n</code></pre> <p>Result: Photos grouped by location folder and date, with 1-hour time window, edited versions prioritized.</p> <p>Scenario 3: Social Media Content Creator</p> <p>Mix of smartphone photos, screenshots, and edited versions:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"operator\": \"OR\",\n        \"children\": [\n          {\n            \"criteria\": {\n              \"key\": \"originalFileName\",\n              \"regex\": { \"key\": \"^(Screenshot|IMG_|PXL_)\", \"index\": 0 }\n            }\n          },\n          {\n            \"criteria\": {\n              \"key\": \"originalPath\",\n              \"regex\": { \"key\": \"/content/\", \"index\": 0 }\n            }\n          }\n        ]\n      },\n      {\n        \"criteria\": {\n          \"key\": \"localDateTime\",\n          \"delta\": { \"milliseconds\": 5000 }\n        }\n      },\n      {\n        \"operator\": \"NOT\",\n        \"children\": [\n          {\n            \"criteria\": {\n              \"key\": \"originalFileName\",\n              \"regex\": { \"key\": \"_draft\", \"index\": 0 }\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> <pre><code>PARENT_FILENAME_PROMOTE=final,edit,crop,sequence\n</code></pre> <p>Result: Content grouped by capture time, excluding drafts, prioritizing finalized versions.</p>"},{"location":"features/custom-criteria/#performance-benchmarks","title":"Performance Benchmarks","text":"<p>Real-world performance data for different configurations:</p> Library Size Criteria Complexity Processing Time Memory Usage 10k assets Legacy (split) 35 seconds 80MB 10k assets Groups (2 criteria) 48 seconds 120MB 10k assets Expression (3 levels) 65 seconds 180MB 50k assets Legacy (split) 2m 45s 420MB 50k assets Groups (2 criteria) 4m 15s 680MB 50k assets Expression (3 levels) 7m 30s 1.1GB 100k assets Legacy (split) 6m 20s 850MB 100k assets Legacy (regex) 9m 45s 920MB 100k assets Groups (2 criteria) 14m 30s 1.4GB <p>Key Takeaways:</p> <ul> <li>Split-based criteria are 30-40% faster than regex</li> <li>Expression mode adds 50-100% overhead vs Legacy mode</li> <li>Memory usage scales linearly with asset count</li> <li>Regex complexity impacts processing time significantly</li> </ul>"},{"location":"features/custom-criteria/#troubleshooting-advanced-criteria","title":"Troubleshooting Advanced Criteria","text":"<p>Issue: Expression not matching any assets</p> <p>Debug:</p> <pre><code>LOG_LEVEL=debug\nDRY_RUN=true\n./immich-stack\n</code></pre> <p>Check: Logs will show which criteria matched and grouping keys.</p> <p>Issue: OR expressions creating unexpected groups</p> <p>Solution: Remember only first matching branch contributes to grouping key. Reorder branches to prioritize desired grouping criteria.</p> <p>Issue: Performance too slow</p> <p>Solution:</p> <ol> <li>Simplify criteria (Legacy mode instead of Expression)</li> <li>Optimize regex patterns (use anchors)</li> <li>Increase time deltas to reduce group count</li> <li>Process in chunks with filters</li> </ol> <p>Issue: NOT operator not working as expected</p> <p>Remember: NOT operators are filter-only, they don't contribute to grouping keys.</p>"},{"location":"features/custom-criteria/#see-also","title":"See Also","text":"<ul> <li>Optimize Performance Guide - Detailed performance tuning strategies</li> <li>Architecture Documentation - Technical implementation details</li> <li>Troubleshooting Guide - Common issues and solutions</li> </ul>"},{"location":"features/edited-photo-promotion/","title":"Edited Photo Promotion","text":"<p>This document explains how to properly configure Immich Stack to promote edited photos (with <code>~</code> or <code>.</code> suffixes) over original photos.</p>"},{"location":"features/edited-photo-promotion/#problem-description","title":"Problem Description","text":"<p>When you edit a photo and save it with a numeric suffix (like <code>~2</code> for the second version), the edited version should typically be preferred over the original. For example:</p> <ul> <li>Original photo: <code>PXL_20250823_193751711.jpg</code></li> <li>Edited photo: <code>PXL_20250823_193751711~2.jpg</code></li> </ul> <p>By default, without proper configuration, the original photo might be promoted as the stack parent instead of the edited version.</p>"},{"location":"features/edited-photo-promotion/#solution","title":"Solution","text":"<p>To ensure edited photos are promoted over originals, you need to include <code>biggestNumber</code> in your <code>PARENT_FILENAME_PROMOTE</code> configuration.</p>"},{"location":"features/edited-photo-promotion/#configuration-options","title":"Configuration Options","text":""},{"location":"features/edited-photo-promotion/#option-1-use-default-configuration-recommended","title":"Option 1: Use Default Configuration (Recommended)","text":"<p>The default configuration already includes <code>biggestNumber</code>:</p> <pre><code># Default value (no need to set if using defaults)\nPARENT_FILENAME_PROMOTE=cover,edit,crop,hdr,biggestNumber\n</code></pre> <p>If you're not setting <code>PARENT_FILENAME_PROMOTE</code> explicitly, the defaults will handle edited photos correctly.</p>"},{"location":"features/edited-photo-promotion/#option-2-explicit-configuration","title":"Option 2: Explicit Configuration","text":"<p>If you're customizing the promote list, ensure you include <code>biggestNumber</code>:</p> <pre><code># Example custom configuration that handles edited photos\nPARENT_FILENAME_PROMOTE=cover,edit,biggestNumber\n</code></pre>"},{"location":"features/edited-photo-promotion/#option-3-only-prioritize-edited-photos","title":"Option 3: Only Prioritize Edited Photos","text":"<p>If you only care about promoting edited photos with numeric suffixes:</p> <pre><code>PARENT_FILENAME_PROMOTE=biggestNumber\n</code></pre>"},{"location":"features/edited-photo-promotion/#how-it-works","title":"How It Works","text":"<p>The <code>biggestNumber</code> keyword tells the stacker to:</p> <ol> <li>Split filenames by delimiters (default: <code>~</code> and <code>.</code>)</li> <li>Look for numeric suffixes in the last part</li> <li>Promote files with higher numbers first</li> </ol>"},{"location":"features/edited-photo-promotion/#example-sorting","title":"Example Sorting","text":"<p>With <code>PARENT_FILENAME_PROMOTE=biggestNumber</code>:</p> <pre><code>Files:\n- PXL_20250823_193751711.jpg\n- PXL_20250823_193751711~2.jpg\n- PXL_20250823_193751711~3.jpg\n- PXL_20250823_193751711~5.jpg\n\nSorted order (parent first):\n1. PXL_20250823_193751711~5.jpg  (highest edit)\n2. PXL_20250823_193751711~3.jpg\n3. PXL_20250823_193751711~2.jpg\n4. PXL_20250823_193751711.jpg     (original)\n</code></pre>"},{"location":"features/edited-photo-promotion/#common-configurations","title":"Common Configurations","text":""},{"location":"features/edited-photo-promotion/#for-photos-with-numeric-edits","title":"For Photos with Numeric Edits","text":"<pre><code># Prioritizes edits, crops, HDR, and then numbered versions\nPARENT_FILENAME_PROMOTE=cover,edit,crop,hdr,biggestNumber\n</code></pre>"},{"location":"features/edited-photo-promotion/#for-rawjpeg-with-edits","title":"For RAW+JPEG with Edits","text":"<pre><code># Prioritizes edited JPEGs over everything\nPARENT_FILENAME_PROMOTE=biggestNumber\nPARENT_EXT_PROMOTE=.jpg,.jpeg,.dng,.raw\n</code></pre>"},{"location":"features/edited-photo-promotion/#mixed-priority","title":"Mixed Priority","text":"<pre><code># COVER files first, then edited versions, then regular edits\nPARENT_FILENAME_PROMOTE=COVER,biggestNumber,edit\n</code></pre>"},{"location":"features/edited-photo-promotion/#verification","title":"Verification","text":"<p>To verify your configuration is working:</p> <ol> <li>Run with <code>--dry-run</code> flag to see what would happen:</li> </ol> <pre><code>immich-stack --dry-run --parent-filename-promote=biggestNumber\n</code></pre> <ol> <li>Check the logs for parent selection:</li> </ol> <pre><code>[INFO] Stack created with parent: PXL_20250823_193751711~2.jpg\n</code></pre>"},{"location":"features/edited-photo-promotion/#troubleshooting","title":"Troubleshooting","text":""},{"location":"features/edited-photo-promotion/#edited-photos-not-being-promoted","title":"Edited photos not being promoted?","text":"<ol> <li>Check your configuration: Ensure <code>biggestNumber</code> is in your <code>PARENT_FILENAME_PROMOTE</code> list</li> <li>Check delimiters: The default delimiters are <code>~</code> and <code>.</code>. If your edited photos use different separators, you may need to adjust</li> <li>Check for conflicts: If you have other promote patterns that match before <code>biggestNumber</code>, they take priority</li> </ol>"},{"location":"features/edited-photo-promotion/#want-originals-promoted-instead","title":"Want originals promoted instead?","text":"<p>Simply remove <code>biggestNumber</code> from your promote list:</p> <pre><code>PARENT_FILENAME_PROMOTE=edit,crop,hdr\n</code></pre>"},{"location":"features/edited-photo-promotion/#technical-details","title":"Technical Details","text":"<p>The <code>biggestNumber</code> feature:</p> <ul> <li>Splits filenames by delimiters to find numeric parts (default delimiters: <code>~</code> and <code>.</code>)</li> <li>Compares numeric values (not string comparison)</li> <li>Works with numeric suffixes after the delimiters (e.g., <code>photo~2</code>, <code>image.3</code>)</li> <li>Falls back to alphabetical sorting if no numbers are found</li> </ul> <p>Note: The delimiters are configurable via the <code>CRITERIA</code> environment variable if you need to use different separators like <code>_</code> or <code>-</code>.</p>"},{"location":"features/multi-user/","title":"Multi-User Support","text":"<p>Immich Stack supports processing multiple users' photos by accepting multiple API keys. This is useful for:</p> <ul> <li>Family accounts</li> <li>Shared photo libraries</li> <li>Multiple user management</li> </ul>"},{"location":"features/multi-user/#configuration","title":"Configuration","text":"<p>To use multiple API keys, separate them with commas in the <code>API_KEY</code> environment variable:</p> <pre><code>API_KEY=key1,key2,key3\n</code></pre> <p>Or when using Docker:</p> <pre><code>environment:\n  - API_KEY=key1,key2,key3\n</code></pre>"},{"location":"features/multi-user/#processing-flow","title":"Processing Flow","text":"<ol> <li>The stacker will process each user sequentially</li> <li>Each user's name and email are logged before processing</li> <li>Stacks are created and managed separately for each user</li> <li>Logs clearly indicate which user is being processed</li> </ol>"},{"location":"features/multi-user/#example","title":"Example","text":"<pre><code># .env file\nAPI_KEY=abc123,def456,ghi789\nAPI_URL=http://immich-server:2283/api\n</code></pre> <p>When running, you'll see logs like:</p> <pre><code>Processing user: John Doe (john@example.com)\nFound 1000 assets\nCreated 50 stacks\n...\n\nProcessing user: Jane Doe (jane@example.com)\nFound 800 assets\nCreated 40 stacks\n...\n\nProcessing user: Bob Smith (bob@example.com)\nFound 1200 assets\nCreated 60 stacks\n...\n</code></pre>"},{"location":"features/multi-user/#best-practices","title":"Best Practices","text":"<ol> <li> <p>API Key Management:</p> </li> <li> <p>Keep API keys secure</p> </li> <li>Rotate keys periodically</li> <li> <p>Use different keys for different users</p> </li> <li> <p>Resource Usage:</p> </li> <li> <p>Consider running during off-peak hours</p> </li> <li>Monitor system resources</li> <li> <p>Adjust cron interval based on library size</p> </li> <li> <p>Error Handling:</p> </li> <li> <p>If one user fails, others will still be processed</p> </li> <li>Check logs for any user-specific issues</li> <li>Retry failed users if needed</li> </ol>"},{"location":"features/stacking-logic/","title":"Stacking Logic","text":""},{"location":"features/stacking-logic/#grouping-modes","title":"Grouping Modes","text":"<p>Immich Stack supports three grouping modes with increasing complexity and power:</p>"},{"location":"features/stacking-logic/#1-legacy-mode-default","title":"1. Legacy Mode (Default)","text":"<ul> <li>Default Criteria: Groups by base filename (before extension) and local capture time</li> <li>Logic: Simple AND operation - all criteria must match</li> <li>Configuration: Array format in <code>CRITERIA</code> environment variable</li> </ul>"},{"location":"features/stacking-logic/#2-advanced-groups-mode","title":"2. Advanced Groups Mode","text":"<ul> <li>Multiple Strategies: Support for multiple grouping approaches</li> <li>Logic: Configurable AND/OR operations per group</li> <li>Configuration: Object format with <code>\"mode\": \"advanced\"</code> and <code>groups</code> array</li> </ul>"},{"location":"features/stacking-logic/#3-advanced-expression-mode","title":"3. Advanced Expression Mode","text":"<ul> <li>Maximum Flexibility: Unlimited nested logical expressions</li> <li>Logic: Full support for AND, OR, and NOT operations with unlimited nesting</li> <li>Configuration: Object format with <code>\"mode\": \"advanced\"</code> and <code>expression</code> tree</li> </ul>"},{"location":"features/stacking-logic/#custom-criteria","title":"Custom Criteria","text":"<p>Override default grouping behavior with the <code>--criteria</code> flag or <code>CRITERIA</code> environment variable using any of the three supported formats. See Custom Criteria for complete documentation.</p>"},{"location":"features/stacking-logic/#sorting","title":"Sorting","text":"<ul> <li>Parent Promotion: Use <code>--parent-filename-promote</code> or <code>PARENT_FILENAME_PROMOTE</code> (comma-separated substrings) to promote files as stack parents</li> <li>Empty String for Negative Matching: Use an empty string in the promote list to prioritize files that DON'T contain any of the other substrings (e.g., <code>,edit</code> promotes unedited files first)</li> <li>Sequence Keyword: Use the <code>sequence</code> keyword for flexible sequential file handling (e.g., <code>sequence</code>, <code>sequence:4</code>, <code>sequence:IMG_</code>)</li> <li>Sequence Detection: Automatically detects numeric sequences in promote lists (e.g., <code>0000,0001,0002</code>) and uses intelligent matching for burst photos</li> <li>Extension Promotion: Use <code>--parent-ext-promote</code> or <code>PARENT_EXT_PROMOTE</code> (comma-separated extensions) to further prioritize</li> <li>Extension Rank: Built-in priority: <code>.jpeg</code> &gt; <code>.jpg</code> &gt; <code>.png</code> &gt; others</li> <li>Alphabetical: Final tiebreaker</li> </ul>"},{"location":"features/stacking-logic/#examples","title":"Examples","text":""},{"location":"features/stacking-logic/#standard-promotion-example","title":"Standard Promotion Example","text":"<p>For files: <code>L1010229.JPG</code>, <code>L1010229.edit.jpg</code>, <code>L1010229.DNG</code></p> <p>With <code>PARENT_FILENAME_PROMOTE=edit</code> and <code>PARENT_EXT_PROMOTE=.jpg,.dng</code> in your .env file, or with <code>--parent-filename-promote=edit</code> and <code>--parent-ext-promote=.jpg,.dng</code>, the order will be:</p> <pre><code>L1010229.edit.jpg\nL1010229.JPG\nL1010229.DNG\n</code></pre>"},{"location":"features/stacking-logic/#empty-string-negative-matching-example","title":"Empty String (Negative Matching) Example","text":"<p>For files that lack EXIF data after editing, you can prioritize unedited files using empty string matching:</p> <p>For files: <code>IMG_1234.jpg</code>, <code>IMG_1234_edited.jpg</code>, <code>IMG_1234_crop.jpg</code></p> <p>With <code>PARENT_FILENAME_PROMOTE=,_edited,_crop</code>, the empty string matches files WITHOUT \"_edited\" or \"_crop\":</p> <pre><code>IMG_1234.jpg          # Promoted first (doesn't contain _edited or _crop)\nIMG_1234_edited.jpg   # Second priority\nIMG_1234_crop.jpg     # Third priority\n</code></pre> <p>This is particularly useful when edited JPGs lose their EXIF data and would otherwise appear in the wrong timeline position.</p>"},{"location":"features/stacking-logic/#burst-photo-sequence-example","title":"Burst Photo Sequence Example","text":"<p>For burst photo files: <code>DSCPDC_0000_BURST20180828114700954.JPG</code>, <code>DSCPDC_0001_BURST20180828114700954.JPG</code>, <code>DSCPDC_0002_BURST20180828114700954.JPG</code>, <code>DSCPDC_0003_BURST20180828114700954_COVER.JPG</code></p> <p>With <code>PARENT_FILENAME_PROMOTE=0000,0001,0002,0003</code>, the system automatically detects this as a numeric sequence and orders them correctly:</p> <pre><code>DSCPDC_0000_BURST20180828114700954.JPG\nDSCPDC_0001_BURST20180828114700954.JPG\nDSCPDC_0002_BURST20180828114700954.JPG\nDSCPDC_0003_BURST20180828114700954_COVER.JPG\n</code></pre> <p>The sequence detection works even with numbers beyond your promote list. For example, if you have <code>PARENT_FILENAME_PROMOTE=0000,0001,0002,0003</code> but your files include <code>DSCPDC_0999_BURST...</code>, it will be sorted at position 999 automatically.</p>"},{"location":"features/stacking-logic/#sequence-keyword-examples","title":"Sequence Keyword Examples","text":"<p>The <code>sequence</code> keyword provides powerful and flexible sequence handling:</p> <pre><code># Order any numeric sequence (1, 2, 10, 100, etc.)\nPARENT_FILENAME_PROMOTE=sequence\n\n# Order only 4-digit sequences (0001, 0002, 0010, 0100, etc.)\nPARENT_FILENAME_PROMOTE=sequence:4\n\n# Order sequences with specific prefix\nPARENT_FILENAME_PROMOTE=sequence:IMG_\n\n# Mix with other promote values - COVER files first, then sequence\nPARENT_FILENAME_PROMOTE=COVER,sequence\n\n# Multiple criteria - edited files first, then sequences\nPARENT_FILENAME_PROMOTE=edit,hdr,sequence\n</code></pre>"},{"location":"features/stacking-logic/#supported-sequence-patterns-legacy-method","title":"Supported Sequence Patterns (Legacy Method)","text":"<p>The system can detect various sequence patterns when using comma-separated numbers:</p> <ul> <li>Pure numbers: <code>0000,0001,0002,0003</code></li> <li>Prefixed numbers: <code>img1,img2,img3</code> or <code>IMG_0001,IMG_0002,IMG_0003</code></li> <li>Suffixed numbers: <code>1a,2a,3a</code> or <code>001_final,002_final,003_final</code></li> <li>Complex patterns: <code>photo_001_v2,photo_002_v2,photo_003_v2</code></li> </ul> <p>Note: The <code>sequence</code> keyword is more flexible and recommended over listing individual sequence numbers.</p>"},{"location":"features/stacking-logic/#stacking-process","title":"Stacking Process","text":"<ol> <li>Fetch all stacks and assets from Immich</li> <li>Determine grouping mode based on <code>CRITERIA</code> configuration:</li> <li>Legacy Mode: Apply simple AND logic to array of criteria</li> <li>Groups Mode: Process each criteria group with configured AND/OR logic</li> <li>Expression Mode: Recursively evaluate nested logical expressions</li> <li>Group assets into stacks using the selected mode and criteria</li> <li>Sort each stack to determine the parent and children using promotion rules</li> <li>Apply changes via the Immich API (create, update, or delete stacks as needed)</li> <li>Log all actions and optionally run in dry-run mode for safety</li> </ol>"},{"location":"features/stacking-logic/#safe-operations","title":"Safe Operations","text":"<p>The stacker includes several safety features:</p> <ul> <li>Dry Run Mode: Use <code>--dry-run</code> or <code>DRY_RUN=true</code> to simulate actions without making changes</li> <li>Stack Replacement: Use <code>--replace-stacks</code> or <code>REPLACE_STACKS=true</code> to replace existing stacks</li> <li>Stack Reset: Use <code>--reset-stacks</code> or <code>RESET_STACKS=true</code> with confirmation to delete all stacks (requires <code>RUN_MODE=once</code>)</li> <li>Confirmation Required: Stack reset requires explicit confirmation via <code>CONFIRM_RESET_STACK</code></li> </ul>"},{"location":"features/stacking-logic/#parent-selection-edge-cases","title":"Parent Selection Edge Cases","text":""},{"location":"features/stacking-logic/#multiple-promotion-rules","title":"Multiple Promotion Rules","text":"<p>When multiple promotion rules apply to different files in a group, the selection follows this strict precedence order:</p> <ol> <li>PARENT_FILENAME_PROMOTE list order (left to right)</li> <li>PARENT_EXT_PROMOTE list order (left to right)</li> <li>Built-in extension rank (<code>.jpeg</code> &gt; <code>.jpg</code> &gt; <code>.png</code> &gt; others)</li> <li>Alphabetical order (case-insensitive)</li> </ol> <p>Example with multiple matches:</p> <p>Files: <code>IMG_1234_edited.jpg</code>, <code>IMG_1234_raw.dng</code>, <code>IMG_1234_edited.dng</code></p> <p>With <code>PARENT_FILENAME_PROMOTE=edited,raw</code> and <code>PARENT_EXT_PROMOTE=.jpg,.dng</code>:</p> <pre><code>IMG_1234_edited.jpg  # Wins: \"edited\" matches first in filename list, .jpg matches first in ext list\nIMG_1234_edited.dng  # Second: \"edited\" matches first in filename list, .dng second in ext list\nIMG_1234_raw.dng     # Third: \"raw\" is second in filename list\n</code></pre>"},{"location":"features/stacking-logic/#sequence-keyword-behavior","title":"Sequence Keyword Behavior","text":"<p>When multiple <code>sequence</code> keywords appear in the promote list, only the first occurrence is used. Additional sequence keywords are ignored.</p> <pre><code># Only the first \"sequence\" is processed\nPARENT_FILENAME_PROMOTE=COVER,sequence,edited,sequence:4\n# Result: COVER files first, then all sequences, then \"edited\", then everything else\n</code></pre> <p>To use specific sequence patterns, place them strategically:</p> <pre><code># Correct: specific pattern first, general sequence later\nPARENT_FILENAME_PROMOTE=sequence:IMG_,COVER,sequence\n\n# This orders IMG_ sequences first, then COVER files, then other sequences\n</code></pre>"},{"location":"features/stacking-logic/#mixed-case-filenames","title":"Mixed Case Filenames","text":"<p>Filename matching is case-insensitive for promotion rules:</p> <pre><code>PARENT_FILENAME_PROMOTE=EDIT,HDR\n</code></pre> <p>This will match: <code>edit</code>, <code>Edit</code>, <code>EDIT</code>, <code>eDiT</code>, <code>hdr</code>, <code>HDR</code>, etc.</p> <p>However, alphabetical tie-breaking is also case-insensitive, so <code>IMG_123.jpg</code> and <code>img_123.jpg</code> sort together regardless of case.</p>"},{"location":"features/stacking-logic/#unicode-and-special-characters","title":"Unicode and Special Characters","text":"<ul> <li>Unicode characters are supported in filename matching</li> <li>Special regex characters in promote strings are treated as literals (no regex escaping needed)</li> <li>Whitespace in filenames is preserved and matched exactly</li> </ul> <p>Example:</p> <pre><code>PARENT_FILENAME_PROMOTE=\u7de8\u96c6,\u2605favorites,caf\u00e9\n</code></pre> <p>This will match files containing these exact Unicode strings.</p>"},{"location":"features/stacking-logic/#tie-breaking-logic","title":"Tie-Breaking Logic","text":"<p>When two files have equal rank after all promotion rules, the final tie-breaker is:</p> <ol> <li>Original filename (alphabetically, case-insensitive)</li> <li>If filenames are identical: Local date/time (earliest first)</li> <li>If both are identical: Asset ID (lexicographic order)</li> </ol> <p>This ensures deterministic, reproducible parent selection across multiple runs.</p>"},{"location":"features/stacking-logic/#empty-string-edge-cases","title":"Empty String Edge Cases","text":"<p>When using empty string (<code>,</code>) for negative matching:</p> <pre><code>PARENT_FILENAME_PROMOTE=,_edited,_crop\n</code></pre> <p>A file matches the empty string rule if it contains none of the other non-empty substrings in the list:</p> <ul> <li><code>IMG_1234.jpg</code> \u2192 Matches empty string (no <code>_edited</code>, no <code>_crop</code>)</li> <li><code>IMG_1234_final.jpg</code> \u2192 Matches empty string (no <code>_edited</code>, no <code>_crop</code>)</li> <li><code>IMG_1234_edited.jpg</code> \u2192 Does NOT match empty string (contains <code>_edited</code>)</li> <li><code>IMG_1234_crop.jpg</code> \u2192 Does NOT match empty string (contains <code>_crop</code>)</li> <li><code>IMG_1234_edited_crop.jpg</code> \u2192 Does NOT match empty string (contains both)</li> </ul>"},{"location":"features/stacking-logic/#performance-implications","title":"Performance Implications","text":""},{"location":"features/stacking-logic/#expression-mode-complexity","title":"Expression Mode Complexity","text":"<p>Expression mode with deep nesting can impact performance:</p> Nesting Level Performance Impact Recommendation 1-2 levels Negligible Safe for all use cases 3-4 levels Slight increase Acceptable for most libraries 5+ levels Noticeable impact Consider simplifying criteria <p>Example of deep nesting:</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"operator\": \"OR\",\n        \"children\": [\n          {\n            \"operator\": \"AND\",\n            \"children\": [\n              {\n                \"criteria\": {\n                  \"key\": \"originalFileName\",\n                  \"regex\": { \"key\": \"PXL_\", \"index\": 0 }\n                }\n              },\n              {\n                \"criteria\": {\n                  \"key\": \"localDateTime\",\n                  \"delta\": { \"milliseconds\": 1000 }\n                }\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> <p>This has 3 levels of nesting. Each additional level multiplies the evaluation cost.</p>"},{"location":"features/stacking-logic/#memory-usage","title":"Memory Usage","text":"<p>Memory usage scales with:</p> <ol> <li>Asset count: ~1KB per asset in memory</li> <li>Criteria complexity: Expression trees consume additional memory per evaluation</li> <li>Stack size: Larger stacks (more assets per group) increase memory overhead</li> </ol> <p>Guidelines:</p> Library Size Recommended Mode Expected Memory &lt; 10,000 assets Any mode &lt; 100MB 10,000-50,000 assets Legacy or Groups 100-500MB 50,000-100,000 assets Legacy preferred 500MB-1GB &gt; 100,000 assets Legacy only &gt; 1GB <p>For very large libraries (100k+ assets), consider:</p> <ul> <li>Using simpler criteria (Legacy mode)</li> <li>Processing in batches using <code>WITH_ARCHIVED</code> and <code>WITH_DELETED</code> filters</li> <li>Running during off-peak hours</li> </ul>"},{"location":"features/stacking-logic/#regex-performance","title":"Regex Performance","text":"<p>Regex-based criteria (<code>\"regex\": {\"key\": \"...\"}</code>) are evaluated for each asset. Complex regex patterns can slow processing:</p> <p>Fast regex patterns:</p> <pre><code>{ \"key\": \"PXL_\", \"index\": 0 }          // Simple prefix match\n{ \"key\": \"IMG_\\\\d{4}\", \"index\": 0 }     // Simple digit pattern\n</code></pre> <p>Slow regex patterns:</p> <pre><code>{ \"key\": \".*photo.*\\\\d+.*edited.*\", \"index\": 0 }  // Multiple wildcards and backtracking\n{ \"key\": \"(IMG|DSC|PXL)_\\\\d{4,6}_.*\", \"index\": 0 } // Complex alternation\n</code></pre> <p>Optimize regex by:</p> <ul> <li>Using anchors (<code>^</code>, <code>$</code>) when possible</li> <li>Avoiding unnecessary wildcards (<code>.*</code>)</li> <li>Using character classes instead of alternation when possible</li> </ul>"},{"location":"features/stacking-logic/#time-delta-performance","title":"Time Delta Performance","text":"<p>Time-based criteria with small deltas create smaller, more numerous groups:</p> <pre><code>{ \"key\": \"localDateTime\", \"delta\": { \"milliseconds\": 100 } }   // Very tight grouping, more groups\n{ \"key\": \"localDateTime\", \"delta\": { \"milliseconds\": 5000 } }  // Looser grouping, fewer groups\n</code></pre> <p>Recommendation: Use the largest delta that still achieves your grouping goals. 1000ms (1 second) is a good starting point for most burst photos.</p>"},{"location":"features/stacking-logic/#logging","title":"Logging","text":"<p>The stacker provides comprehensive logging:</p> <ul> <li>Colorful, structured logs for all operations</li> <li>Clear indication of actions taken</li> <li>Error reporting with context</li> <li>Progress updates for long-running operations</li> </ul>"},{"location":"features/whats-new-advanced-filtering/","title":"What\u2019s New: Advanced Filtering &amp; Safer Grouping","text":"<p>This branch introduces easier, more powerful ways to tell Immich Stack how to group your photos into stacks \u2014 with simple, copy\u2011pasteable examples. It focuses on new capabilities; no test/refactor details here.</p>"},{"location":"features/whats-new-advanced-filtering/#highlights","title":"Highlights","text":"<ul> <li>Expression\u2011based criteria: combine rules with AND / OR / NOT</li> <li>Flexible groups: per\u2011group AND/OR logic (independent OR criteria)</li> <li>Safer regex: no match = not grouped by that rule (prevents stray stacks)</li> <li>CLI flag precedence: <code>--criteria</code> overrides <code>CRITERIA</code> env</li> <li>Better logs: clearer mode banners and per\u2011asset context when debugging</li> </ul>"},{"location":"features/whats-new-advanced-filtering/#1-expressionbased-criteria-and-or-not","title":"1) Expression\u2011Based Criteria (AND / OR / NOT)","text":"<p>You can now describe complex logic for grouping in one place. Expressions let you nest conditions and mix operators.</p> <p>Example: group photos if the filename starts with PXL or IMG, and were taken within 2 seconds of each other.</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"operator\": \"OR\",\n        \"children\": [\n          {\n            \"criteria\": {\n              \"key\": \"originalFileName\",\n              \"regex\": { \"key\": \"^PXL_\", \"index\": 0 }\n            }\n          },\n          {\n            \"criteria\": {\n              \"key\": \"originalFileName\",\n              \"regex\": { \"key\": \"^IMG_\", \"index\": 0 }\n            }\n          }\n        ]\n      },\n      {\n        \"criteria\": {\n          \"key\": \"localDateTime\",\n          \"delta\": { \"milliseconds\": 2000 }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>Why it\u2019s useful:</p> <ul> <li>Mix camera types and time windows in one rule</li> <li>Exclude things with <code>NOT</code> (e.g., not archived)</li> <li>Build exactly the grouping logic you want</li> </ul>"},{"location":"features/whats-new-advanced-filtering/#2-flexible-groups-independent-or-criteria","title":"2) Flexible Groups (Independent OR Criteria)","text":"<p>Prefer simpler building blocks? You can still use \u201cgroups\u201d with an operator for that group. This is great for \u201cmatch any of these patterns\u201d cases.</p> <p>Example: group by directory OR by being close in time.</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"groups\": [\n    {\n      \"operator\": \"OR\",\n      \"criteria\": [\n        { \"key\": \"originalPath\", \"split\": { \"delimiters\": [\"/\"], \"index\": 2 } },\n        { \"key\": \"localDateTime\", \"delta\": { \"milliseconds\": 1000 } }\n      ]\n    }\n  ]\n}\n</code></pre> <p>Why it\u2019s useful:</p> <ul> <li>Keep rules readable while still allowing OR logic</li> <li>Works well for \u201ceither same folder OR taken close in time\u201d</li> </ul>"},{"location":"features/whats-new-advanced-filtering/#3-safer-regex-matching-no-surprise-grouping","title":"3) Safer Regex Matching (No Surprise Grouping)","text":"<p>When a regex doesn\u2019t match, that rule contributes no value. Assets won\u2019t get grouped by an unmatched pattern. This prevents accidental stacking from partial or wrong matches.</p> <p>Tip: Use <code>index</code> to grab exactly the part you want (full match = 0; capture group = 1+).</p> <pre><code>{ \"key\": \"originalFileName\", \"regex\": { \"key\": \"PXL_(\\\\d{8})\", \"index\": 1 } }\n</code></pre>"},{"location":"features/whats-new-advanced-filtering/#4-cli-env-explicit-criteria-wins","title":"4) CLI &gt; Env: Explicit Criteria Wins","text":"<p>The <code>--criteria</code> flag now wins over the <code>CRITERIA</code> environment variable. This makes quick experiments easy.</p> <p>Examples:</p> <ul> <li>One\u2011off run with CLI flag:</li> </ul> <pre><code>immich-stack \\\n  --api-url \"http://immich:3001/api\" \\\n  --api-key \"$API_KEY\" \\\n  --criteria '{\"mode\":\"advanced\",\"groups\":[{\"operator\":\"OR\",\"criteria\":[{\"key\":\"originalPath\",\"split\":{\"delimiters\":[\"/\"],\"index\":2}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]}]}'\n</code></pre> <ul> <li>Using <code>.env</code>, but override on the command line:</li> </ul> <pre><code>CRITERIA='{\"mode\":\"advanced\",\"expression\":{\"operator\":\"AND\",\"children\":[{\"criteria\":{\"key\":\"originalFileName\",\"regex\":{\"key\":\"^IMG_\",\"index\":0}}},{\"criteria\":{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1500}}}]}}' \\\nimmich-stack --criteria '{\"mode\":\"advanced\",\"expression\":{\"operator\":\"OR\",\"children\":[{\"criteria\":{\"key\":\"originalFileName\",\"regex\":{\"key\":\"^PXL_\",\"index\":0}}},{\"criteria\":{\"key\":\"originalFileName\",\"regex\":{\"key\":\"^DSC\",\"index\":0}}}]}}'\n</code></pre>"},{"location":"features/whats-new-advanced-filtering/#5-debugging-is-clearer","title":"5) Debugging Is Clearer","text":"<p>Turn on debug logging to see how assets are grouped and why.</p> <pre><code>LOG_LEVEL=debug immich-stack --api-url \"$API_URL\" --api-key \"$API_KEY\" --criteria '&lt;your json here&gt;'\n</code></pre> <p>What you\u2019ll notice:</p> <ul> <li>A banner indicating which mode you\u2019re using (expression vs groups)</li> <li>Per\u2011asset logs with filenames, IDs, and timestamps</li> <li>Clear \u201cparent\u201d vs \u201cchild\u201d lines for each stack</li> </ul>"},{"location":"features/whats-new-advanced-filtering/#quick-copypaste-recipes","title":"Quick Copy/Paste Recipes","text":"<ul> <li>Group by base filename before a <code>~</code> or <code>.</code>:</li> </ul> <pre><code>[\n  {\n    \"key\": \"originalFileName\",\n    \"split\": { \"delimiters\": [\"~\", \".\"], \"index\": 0 }\n  }\n]\n</code></pre> <ul> <li>Group PXL photos taken within 1 second:</li> </ul> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"criteria\": {\n          \"key\": \"originalFileName\",\n          \"regex\": { \"key\": \"^PXL_\", \"index\": 0 }\n        }\n      },\n      {\n        \"criteria\": {\n          \"key\": \"localDateTime\",\n          \"delta\": { \"milliseconds\": 1000 }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <ul> <li>Group by folder name OR within 2 seconds:</li> </ul> <pre><code>{\n  \"mode\": \"advanced\",\n  \"groups\": [\n    {\n      \"operator\": \"OR\",\n      \"criteria\": [\n        {\n          \"key\": \"originalPath\",\n          \"split\": { \"delimiters\": [\"/\"], \"index\": 2 }\n        },\n        { \"key\": \"localDateTime\", \"delta\": { \"milliseconds\": 2000 } }\n      ]\n    }\n  ]\n}\n</code></pre> <ul> <li>One\u2011liner <code>.env</code> example (paste into your terminal for a single run):</li> </ul> <pre><code>CRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\"~\",\".\"],\"index\":0}}]' immich-stack --api-url \"$API_URL\" --api-key \"$API_KEY\"\n</code></pre>"},{"location":"features/whats-new-advanced-filtering/#backward-compatibility","title":"Backward Compatibility","text":"<ul> <li>Legacy array format still works as before</li> <li>Advanced mode is opt\u2011in (<code>{\"mode\":\"advanced\": ...}</code>)</li> <li>If you don\u2019t set <code>mode</code>, legacy behavior applies</li> </ul> <p>That\u2019s it \u2014 more control, safer grouping, and easier runs from the CLI.</p>"},{"location":"getting-started/configuration/","title":"Configuration","text":""},{"location":"getting-started/configuration/#basic-configuration","title":"Basic Configuration","text":"<p>The basic configuration requires two environment variables:</p> <pre><code>API_KEY=your_immich_api_key\nAPI_URL=http://your_immich_server:3001/api\n</code></pre>"},{"location":"getting-started/configuration/#run-modes","title":"Run Modes","text":"<p>Immich Stack supports two run modes:</p> <ol> <li> <p>Once Mode (default)</p> </li> <li> <p>Runs once and exits</p> </li> <li>Good for manual runs or scheduled tasks</li> <li> <p>Use: <code>RUN_MODE=once</code></p> </li> <li> <p>Cron Mode</p> </li> <li> <p>Runs periodically</p> </li> <li>Good for continuous operation</li> <li>Use: <code>RUN_MODE=cron</code></li> <li>Configure interval with <code>CRON_INTERVAL</code> (in seconds)</li> </ol> <p>Example cron configuration:</p> <pre><code>RUN_MODE=cron\nCRON_INTERVAL=3600  # Run every hour\n</code></pre> <p>For detailed information about cron mode including state management, signal handling, monitoring, and best practices, see the Cron Mode documentation.</p>"},{"location":"getting-started/configuration/#stack-management","title":"Stack Management","text":""},{"location":"getting-started/configuration/#parent-selection","title":"Parent Selection","text":"<p>Control which files become stack parents using:</p> <ol> <li>Filename Promotion:</li> </ol> <pre><code>PARENT_FILENAME_PROMOTE=edit,raw,original\n</code></pre> <p>Files containing these substrings will be promoted</p> <ol> <li>Extension Promotion:</li> </ol> <pre><code>PARENT_EXT_PROMOTE=.jpg,.dng\n</code></pre> <p>Files with these extensions will be promoted</p>"},{"location":"getting-started/configuration/#stack-operations","title":"Stack Operations","text":"<ol> <li>Dry Run:</li> </ol> <pre><code>DRY_RUN=true\n</code></pre> <p>Simulates actions without making changes</p> <ol> <li>Reset Stacks:</li> </ol> <pre><code>RESET_STACKS=true\nCONFIRM_RESET_STACK=\"I acknowledge all my current stacks will be deleted and new one will be created\"\n</code></pre> <p>Deletes all existing stacks before processing. This requires <code>RUN_MODE=once</code>; using it in <code>cron</code> mode results in an error. The confirmation text must match exactly as shown above.</p> <ol> <li>Replace Stacks: <pre><code>REPLACE_STACKS=true\n</code></pre>    Replaces existing stacks with new groups</li> </ol>"},{"location":"getting-started/configuration/#asset-inclusion","title":"Asset Inclusion","text":"<p>Control which assets are processed:</p> <pre><code>WITH_ARCHIVED=true  # Include archived assets\nWITH_DELETED=true   # Include deleted assets\n</code></pre>"},{"location":"getting-started/configuration/#asset-filtering","title":"Asset Filtering","text":"<p>Limit which assets are processed using album and date filters:</p>"},{"location":"getting-started/configuration/#filter-by-album","title":"Filter by Album","text":"<pre><code># Single album by UUID\nFILTER_ALBUM_IDS=550e8400-e29b-41d4-a716-446655440000\n\n# Single album by name\nFILTER_ALBUM_IDS=Vacation Photos\n\n# Multiple albums (OR logic - processes assets from any of these)\nFILTER_ALBUM_IDS=album-uuid-1,Vacation Photos,Family Events\n</code></pre>"},{"location":"getting-started/configuration/#filter-by-date-range","title":"Filter by Date Range","text":"<pre><code># Process only assets from 2024\nFILTER_TAKEN_AFTER=2024-01-01T00:00:00Z\nFILTER_TAKEN_BEFORE=2024-12-31T23:59:59Z\n</code></pre> <p>Dates must use ISO 8601 format (e.g., <code>2024-01-15T10:30:00Z</code>).</p>"},{"location":"getting-started/configuration/#logging","title":"Logging","text":"<p>Configure logging output and verbosity:</p> <pre><code>LOG_LEVEL=info      # Options: trace, debug, info, warn, error\nLOG_FORMAT=text     # Options: text, json\nLOG_FILE=/app/logs/immich-stack.log  # Optional: enable dual logging (stdout + file)\n</code></pre>"},{"location":"getting-started/configuration/#file-logging-with-docker","title":"File Logging with Docker","text":"<p>When using Docker, you can persist logs to a file by setting <code>LOG_FILE</code> and mounting a volume:</p> <pre><code>services:\n  immich-stack:\n    image: majorfi/immich-stack:latest\n    environment:\n      - LOG_FILE=/app/logs/immich-stack.log\n      - LOG_LEVEL=info\n      - LOG_FORMAT=text\n    volumes:\n      - ./logs:/app/logs\n</code></pre> <p>The application automatically creates the log directory if it doesn't exist. If file logging fails (e.g., permission issues), it gracefully falls back to stdout-only logging.</p>"},{"location":"getting-started/configuration/#custom-criteria","title":"Custom Criteria","text":"<p>Configure custom grouping criteria using the <code>CRITERIA</code> environment variable. See Custom Criteria for details.</p>"},{"location":"getting-started/configuration/#example-configuration","title":"Example Configuration","text":"<pre><code># Required\nAPI_KEY=your_immich_api_key\nAPI_URL=http://immich-server:2283/api\n\n# Run mode\nRUN_MODE=cron\nCRON_INTERVAL=3600\n\n# Stack management\nPARENT_FILENAME_PROMOTE=edit,raw\nPARENT_EXT_PROMOTE=.jpg,.dng\nDRY_RUN=false\nRESET_STACKS=false\nREPLACE_STACKS=true\n\n# Asset inclusion\nWITH_ARCHIVED=false\nWITH_DELETED=false\n\n# Asset filtering (optional)\nFILTER_ALBUM_IDS=\nFILTER_TAKEN_AFTER=\nFILTER_TAKEN_BEFORE=\n\n# Logging\nLOG_LEVEL=info\nLOG_FORMAT=text\nLOG_FILE=/app/logs/immich-stack.log\n\n# Custom criteria\nCRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\"~\",\".\"],\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]'\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go (version 1.21 or later)</li> <li>Git</li> </ul>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/majorfi/immich-stack.git\ncd immich-stack\n</code></pre> <ol> <li>Build the binary:</li> </ol> <pre><code>go build -o immich-stack ./cmd/...\n</code></pre> <ol> <li>Move the binary to your PATH (optional):</li> </ol> <pre><code>sudo mv immich-stack /usr/local/bin/\n</code></pre>"},{"location":"getting-started/installation/#using-pre-built-binaries","title":"Using Pre-built Binaries","text":"<ol> <li>Download the latest release from the Releases page</li> <li>Extract the archive</li> <li>Move the binary to your PATH (optional)</li> </ol>"},{"location":"getting-started/installation/#docker-installation","title":"Docker Installation","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/majorfi/immich-stack.git\ncd immich-stack\n</code></pre> <ol> <li>Create a <code>.env</code> file from the example:</li> </ol> <pre><code>cp .env.example .env\n</code></pre> <ol> <li>Edit the <code>.env</code> file with your Immich credentials and preferences:</li> </ol> <pre><code># Required\nAPI_KEY=your_immich_api_key\nAPI_URL=http://your_immich_server:3001/api\n\n# Optional - Default values shown\nDRY_RUN=false\nRESET_STACKS=false\nREPLACE_STACKS=false\nPARENT_FILENAME_PROMOTE=edit\nPARENT_EXT_PROMOTE=.jpg,.dng\nWITH_ARCHIVED=false\nWITH_DELETED=false\n\n# Run mode settings\nRUN_MODE=once  # Options: once, cron\nCRON_INTERVAL=86400  # in seconds, only used if RUN_MODE=cron\n</code></pre> <ol> <li>Start the service:</li> </ol> <pre><code>docker compose up -d\n</code></pre> <ol> <li>To run in cron mode, set <code>RUN_MODE=cron</code> in your <code>.env</code> file and restart:</li> </ol> <pre><code>docker compose down\ndocker compose up -d\n</code></pre> <ol> <li>To view logs:</li> </ol> <pre><code>docker compose logs -f\n</code></pre> <ol> <li>To stop the service:</li> </ol> <pre><code>docker compose down\n</code></pre>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":""},{"location":"getting-started/quick-start/#basic-usage","title":"Basic Usage","text":"<ol> <li>Create a <code>.env</code> file:</li> </ol> <pre><code>cat &gt; .env &lt;&lt; EOL\nAPI_KEY=your_immich_api_key\nAPI_URL=http://immich-server:2283/api\nRUN_MODE=cron\nCRON_INTERVAL=60\n# Optional: Enable file logging for persistent logs\n# LOG_FILE=/app/logs/immich-stack.log\nEOL\n</code></pre> <ol> <li>Run with Docker (using Docker Hub):</li> </ol> <pre><code>docker run -d --name immich-stack --env-file .env -v ./logs:/app/logs majorfi/immich-stack:latest\n</code></pre> <p>Or using GitHub Container Registry:</p> <pre><code>docker run -d --name immich-stack --env-file .env -v ./logs:/app/logs ghcr.io/majorfi/immich-stack:latest\n</code></pre>"},{"location":"getting-started/quick-start/#running-locally","title":"Running Locally","text":"<ol> <li>Create a <code>.env</code> file in your working directory with your Immich credentials:</li> </ol> <pre><code>API_KEY=your_immich_api_key\nAPI_URL=http://your_immich_server:3001/api\n</code></pre> <ol> <li>Run the stacker:</li> </ol> <pre><code># Using the binary\n./immich-stack\n\n# Or if installed in PATH\nimmich-stack\n</code></pre>"},{"location":"getting-started/quick-start/#available-commands","title":"Available Commands","text":""},{"location":"getting-started/quick-start/#create-stacks-default","title":"Create Stacks (Default)","text":"<pre><code># Run the main stacking operation\nimmich-stack\n# Or explicitly:\nimmich-stack stack\n</code></pre>"},{"location":"getting-started/quick-start/#find-duplicates","title":"Find Duplicates","text":"<pre><code># Identify duplicate assets in your library\nimmich-stack duplicates\n</code></pre>"},{"location":"getting-started/quick-start/#fix-trash-consistency","title":"Fix Trash Consistency","text":"<pre><code># Move related assets to trash when their companions are trashed\nimmich-stack fix-trash --dry-run  # Preview first\nimmich-stack fix-trash             # Execute\n</code></pre> <ol> <li>Optional: Configure additional options via environment variables or flags:</li> </ol> <pre><code># Example with flags\n./immich-stack --dry-run --parent-filename-promote=edit --parent-ext-promote=.jpg,.dng --with-archived --with-deleted\n\n# Or using environment variables\nexport DRY_RUN=true\nexport PARENT_FILENAME_PROMOTE=edit\nexport PARENT_EXT_PROMOTE=.jpg,.dng\nexport WITH_ARCHIVED=true\nexport WITH_DELETED=true\n./immich-stack\n</code></pre>"},{"location":"getting-started/quick-start/#burst-photo-example","title":"Burst Photo Example","text":"<p>For burst photos from cameras like Sony, Canon, etc., you can use the flexible <code>sequence</code> keyword or numeric sequences:</p>"},{"location":"getting-started/quick-start/#using-the-sequence-keyword-recommended","title":"Using the Sequence Keyword (Recommended)","text":"<pre><code># Order any burst photos by their numeric sequence\nexport PARENT_FILENAME_PROMOTE=sequence\n\n# For Sony burst photos with COVER priority\nexport PARENT_FILENAME_PROMOTE=COVER,sequence\n\n# For Canon burst photos with specific 4-digit format\nexport PARENT_FILENAME_PROMOTE=sequence:4\n\n# For files with specific prefix\nexport PARENT_FILENAME_PROMOTE=sequence:IMG_\n\n./immich-stack\n</code></pre>"},{"location":"getting-started/quick-start/#using-numeric-sequences-legacy","title":"Using Numeric Sequences (Legacy)","text":"<pre><code># For Sony burst photos (DSCPDC_0000_BURST..., DSCPDC_0001_BURST..., etc.)\nexport PARENT_FILENAME_PROMOTE=0000,0001,0002,0003\n\n# For Canon burst photos (IMG_0001, IMG_0002, etc.)\nexport PARENT_FILENAME_PROMOTE=IMG_0001,IMG_0002,IMG_0003\n\n# The system automatically detects sequences and orders photos correctly\n# Even files beyond your list (e.g., 0999) will be sorted properly\n./immich-stack\n</code></pre>"},{"location":"how-to/","title":"How-To Guides","text":"<p>Practical guides for common tasks and workflows with Immich Stack.</p>"},{"location":"how-to/#available-guides","title":"Available Guides","text":""},{"location":"how-to/#real-world-examples","title":"Real-World Examples","text":"<p>Copy-paste configurations for common photo workflows. Covers:</p> <ul> <li>RAW + JPEG pairing (Canon, Nikon, Sony, Fujifilm, Samsung, iPhone)</li> <li>Google Pixel photos (RAW, Motion Photos, Night mode)</li> <li>Google Photos edited versions</li> <li>Lightroom numeric edits</li> <li>Photoshop workflows (PSD + exports)</li> <li>Burst photos and sequences</li> <li>Mixed camera setups</li> <li>Parent selection control</li> </ul>"},{"location":"how-to/#debug-parent-selection","title":"Debug Parent Selection","text":"<p>Learn how to troubleshoot and debug parent selection issues when stacking photos. Covers:</p> <ul> <li>Understanding parent selection precedence</li> <li>Common parent selection problems</li> <li>Advanced debugging techniques</li> <li>Testing parent selection rules</li> <li>Edge cases and best practices</li> </ul>"},{"location":"how-to/#optimize-performance","title":"Optimize Performance","text":"<p>Optimize stacking criteria for better performance with large photo libraries. Covers:</p> <ul> <li>Performance fundamentals and targets</li> <li>Choosing the right grouping mode</li> <li>Optimizing time deltas and regex patterns</li> <li>Expression mode optimization</li> <li>Memory optimization and benchmarking</li> </ul>"},{"location":"how-to/#migrate-criteria","title":"Migrate Criteria","text":"<p>Safely migrate from one stacking criteria configuration to another. Covers:</p> <ul> <li>Migration safety principles</li> <li>Three migration strategies (clean slate, incremental, additive)</li> <li>Advanced migration scenarios</li> <li>Testing and validation</li> <li>Rollback procedures and troubleshooting</li> </ul>"},{"location":"how-to/#quick-links","title":"Quick Links","text":"<ul> <li>Looking for examples? Start with Real-World Examples</li> <li>Having issues? See Troubleshooting Guide</li> <li>Need performance? See Optimize Performance</li> <li>Changing criteria? Read Migrate Criteria</li> <li>Wrong parents selected? Check Debug Parent Selection</li> </ul>"},{"location":"how-to/debug-parent-selection/","title":"How to Debug Parent Selection Issues","text":"<p>This guide helps you troubleshoot and debug parent selection problems when stacking photos.</p>"},{"location":"how-to/debug-parent-selection/#understanding-parent-selection","title":"Understanding Parent Selection","text":"<p>Parent selection determines which asset becomes the visible representative of a stack. The selection follows a strict precedence order:</p> <ol> <li>PARENT_FILENAME_PROMOTE list order (left to right)</li> <li>PARENT_EXT_PROMOTE list order (left to right)</li> <li>Built-in extension rank (<code>.jpeg</code> &gt; <code>.jpg</code> &gt; <code>.png</code> &gt; others)</li> <li>Alphabetical order (case-insensitive)</li> <li>Local date/time (earliest first)</li> <li>Asset ID (lexicographic order)</li> </ol>"},{"location":"how-to/debug-parent-selection/#common-parent-selection-problems","title":"Common Parent Selection Problems","text":""},{"location":"how-to/debug-parent-selection/#problem-1-wrong-file-is-stack-parent","title":"Problem 1: Wrong File is Stack Parent","text":"<p>Symptom: Expected file is not the stack parent</p> <p>Debug Steps:</p> <ol> <li>Enable debug logging:</li> </ol> <pre><code>LOG_LEVEL=debug\nDRY_RUN=true\n</code></pre> <ol> <li>Check your promotion rules:</li> </ol> <pre><code>PARENT_FILENAME_PROMOTE=edit,raw,original\nPARENT_EXT_PROMOTE=.jpg,.dng\n</code></pre> <ol> <li>Review the logs for parent selection details:</li> </ol> <pre><code>level=debug msg=\"Parent candidate\" filename=IMG_1234_edited.jpg rank=1\nlevel=debug msg=\"Parent candidate\" filename=IMG_1234.jpg rank=2\n</code></pre> <p>Solutions:</p> <ul> <li>Verify promotion strings are case-insensitive but must be substrings of the filename</li> <li>Check that promoted files actually exist in the stack</li> <li>Review precedence order (filename promotion beats extension promotion)</li> </ul>"},{"location":"how-to/debug-parent-selection/#problem-2-parent-changes-between-runs","title":"Problem 2: Parent Changes Between Runs","text":"<p>Symptom: Different file becomes parent on each run</p> <p>Causes:</p> <ul> <li>Non-deterministic file ordering (this should not happen after recent fixes)</li> <li>Changing promotion rules</li> <li>Assets with identical ranks using tie-breaking rules</li> </ul> <p>Debug Steps:</p> <ol> <li>Lock down your configuration:</li> </ol> <pre><code>PARENT_FILENAME_PROMOTE=edit,raw\nPARENT_EXT_PROMOTE=.jpg,.dng\n</code></pre> <ol> <li>Run with same configuration multiple times:</li> </ol> <pre><code>DRY_RUN=true\nLOG_LEVEL=debug\n</code></pre> <ol> <li>Compare parent selections across runs</li> </ol> <p>Solutions:</p> <ul> <li>Ensure consistent promotion rules</li> <li>Use more specific promotion substrings</li> <li>Add extension promotion for additional tie-breaking</li> </ul>"},{"location":"how-to/debug-parent-selection/#problem-3-sequence-not-ordering-correctly","title":"Problem 3: Sequence Not Ordering Correctly","text":"<p>Symptom: Burst photos in wrong order (e.g., 0001, 0003, 0002)</p> <p>Debug Steps:</p> <ol> <li>Check your sequence configuration:</li> </ol> <pre><code># Wrong: Using generic substrings\nPARENT_FILENAME_PROMOTE=0001,0002,0003\n\n# Right: Using sequence keyword\nPARENT_FILENAME_PROMOTE=sequence\n</code></pre> <ol> <li>Verify sequence detection:</li> </ol> <pre><code>LOG_LEVEL=debug\nDRY_RUN=true\n</code></pre> <p>Solutions:</p> <ul> <li>Use <code>sequence</code> keyword instead of comma-separated numbers</li> <li>For specific patterns, use <code>sequence:4</code> (4-digit numbers) or <code>sequence:IMG_</code> (with prefix)</li> <li>Avoid numeric substrings that match timestamps</li> </ul>"},{"location":"how-to/debug-parent-selection/#problem-4-edited-files-not-promoted","title":"Problem 4: Edited Files Not Promoted","text":"<p>Symptom: RAW or original files become parents instead of edited versions</p> <p>Debug Steps:</p> <ol> <li>Verify your promotion configuration:</li> </ol> <pre><code>PARENT_FILENAME_PROMOTE=edit,edited,final\nPARENT_EXT_PROMOTE=.jpg,.jpeg\n</code></pre> <ol> <li>Check filename patterns in logs:</li> </ol> <pre><code>LOG_LEVEL=debug\n</code></pre> <ol> <li>Verify edited files actually contain the promotion substring:</li> </ol> <pre><code>IMG_1234.jpg        # Does NOT contain \"edit\"\nIMG_1234_edit.jpg   # Contains \"edit\" \u2713\nIMG_1234edited.jpg  # Contains \"edit\" \u2713\n</code></pre> <p>Solutions:</p> <ul> <li>Use multiple promotion strings: <code>edit,edited,_edit,final</code></li> <li>Add extension promotion: <code>.jpg,.jpeg</code> to prefer JPEGs</li> <li>Use empty string for negative matching to promote files WITHOUT certain strings</li> </ul>"},{"location":"how-to/debug-parent-selection/#advanced-debugging-techniques","title":"Advanced Debugging Techniques","text":""},{"location":"how-to/debug-parent-selection/#technique-1-isolate-a-specific-stack","title":"Technique 1: Isolate a Specific Stack","text":"<p>Test parent selection for a specific group of files:</p> <ol> <li>Create minimal test criteria:</li> </ol> <pre><code>CRITERIA='[{\"key\":\"originalFileName\",\"regex\":{\"key\":\"^IMG_1234\",\"index\":0}}]'\nDRY_RUN=true\nLOG_LEVEL=debug\n</code></pre> <ol> <li>Review detailed logs for only this file group</li> </ol>"},{"location":"how-to/debug-parent-selection/#technique-2-test-promotion-rules","title":"Technique 2: Test Promotion Rules","text":"<p>Create a test script to verify promotion logic:</p> <pre><code>#!/bin/bash\n\n# Test different promotion configurations\ndeclare -a configs=(\n  \"edit,raw\"\n  \"raw,edit\"\n  \"sequence,edit\"\n  \",edit,raw\"  # Empty string for negative matching\n)\n\nfor config in \"${configs[@]}\"; do\n  echo \"Testing: PARENT_FILENAME_PROMOTE=$config\"\n  PARENT_FILENAME_PROMOTE=\"$config\" \\\n  DRY_RUN=true \\\n  LOG_LEVEL=info \\\n  ./immich-stack | grep \"Parent\"\n  echo \"---\"\ndone\n</code></pre>"},{"location":"how-to/debug-parent-selection/#technique-3-compare-expected-vs-actual","title":"Technique 3: Compare Expected vs Actual","text":"<ol> <li>Document your expected parent for each stack:</li> </ol> <pre><code>Expected: IMG_1234_edited.jpg (rank 1: contains \"edited\")\nActual: IMG_1234.jpg (rank 3: alphabetical)\n</code></pre> <ol> <li>Trace through precedence rules to identify where expectations diverge</li> </ol>"},{"location":"how-to/debug-parent-selection/#technique-4-use-dry-run-with-verbose-logging","title":"Technique 4: Use Dry-Run with Verbose Logging","text":"<p>Combine dry-run mode with debug logging to see all parent selection decisions:</p> <pre><code>DRY_RUN=true\nLOG_LEVEL=debug\nLOG_FORMAT=json  # For easier parsing\n./immich-stack &gt; debug-output.log 2&gt;&amp;1\n</code></pre> <p>Then analyze the log:</p> <pre><code># Find all parent selection events\ngrep \"Parent candidate\" debug-output.log\n\n# Count parent selections by filename pattern\ngrep \"Parent candidate\" debug-output.log | awk '{print $5}' | sort | uniq -c\n</code></pre>"},{"location":"how-to/debug-parent-selection/#testing-parent-selection-rules","title":"Testing Parent Selection Rules","text":""},{"location":"how-to/debug-parent-selection/#test-case-1-basic-promotion","title":"Test Case 1: Basic Promotion","text":"<p>Setup:</p> <pre><code>Files:\n- IMG_1234.jpg\n- IMG_1234_edited.jpg\n- IMG_1234.dng\n\nConfig:\nPARENT_FILENAME_PROMOTE=edited\n</code></pre> <p>Expected: IMG_1234_edited.jpg is parent</p> <p>Verification:</p> <pre><code>DRY_RUN=true LOG_LEVEL=debug ./immich-stack | grep \"1234\"\n</code></pre>"},{"location":"how-to/debug-parent-selection/#test-case-2-extension-precedence","title":"Test Case 2: Extension Precedence","text":"<p>Setup:</p> <pre><code>Files:\n- IMG_5678.jpg\n- IMG_5678.jpeg\n- IMG_5678.png\n\nConfig:\nPARENT_FILENAME_PROMOTE=\"\"\nPARENT_EXT_PROMOTE=.jpg,.jpeg\n</code></pre> <p>Expected: IMG_5678.jpeg is parent (built-in rank: jpeg &gt; jpg &gt; png)</p>"},{"location":"how-to/debug-parent-selection/#test-case-3-sequence-ordering","title":"Test Case 3: Sequence Ordering","text":"<p>Setup:</p> <pre><code>Files:\n- BURST_0001.jpg\n- BURST_0003.jpg\n- BURST_0002.jpg\n\nConfig:\nPARENT_FILENAME_PROMOTE=sequence\n</code></pre> <p>Expected: Order: 0001, 0002, 0003</p>"},{"location":"how-to/debug-parent-selection/#common-edge-cases","title":"Common Edge Cases","text":""},{"location":"how-to/debug-parent-selection/#unicode-filenames","title":"Unicode Filenames","text":"<pre><code># Works correctly - case-insensitive substring matching\nPARENT_FILENAME_PROMOTE=\u7de8\u96c6,\u2605favorites,caf\u00e9\n</code></pre>"},{"location":"how-to/debug-parent-selection/#empty-string-matching","title":"Empty String Matching","text":"<pre><code># Promote files that DON'T contain \"_edited\" or \"_crop\"\nPARENT_FILENAME_PROMOTE=,_edited,_crop\n\n# Result:\n# IMG_1234.jpg          \u2192 Promoted (no _edited, no _crop)\n# IMG_1234_edited.jpg   \u2192 Not promoted (contains _edited)\n</code></pre>"},{"location":"how-to/debug-parent-selection/#multiple-sequence-keywords","title":"Multiple Sequence Keywords","text":"<pre><code># Only first \"sequence\" is used, rest ignored\nPARENT_FILENAME_PROMOTE=COVER,sequence,edited,sequence:4\n# Result: COVER files first, then sequences, then \"edited\", then others\n</code></pre>"},{"location":"how-to/debug-parent-selection/#troubleshooting-checklist","title":"Troubleshooting Checklist","text":"<p>When debugging parent selection:</p> <ul> <li>[ ] Verify promotion strings are substrings (not regex patterns)</li> <li>[ ] Check case-insensitive matching is working</li> <li>[ ] Confirm promoted files actually exist in stack</li> <li>[ ] Review precedence order (filename &gt; extension &gt; built-in &gt; alpha)</li> <li>[ ] Test with dry-run mode first</li> <li>[ ] Enable debug logging for detailed output</li> <li>[ ] Check for typos in promotion configuration</li> <li>[ ] Verify environment variables are loaded correctly</li> <li>[ ] Compare results across multiple runs for consistency</li> </ul>"},{"location":"how-to/debug-parent-selection/#best-practices","title":"Best Practices","text":"<ol> <li>Start Simple: Test with basic promotion rules first</li> <li>Use Dry-Run: Always test with <code>DRY_RUN=true</code> before production</li> <li>Enable Debug Logs: Use <code>LOG_LEVEL=debug</code> for detailed insights</li> <li>Document Expected Behavior: Write down what you expect before running</li> <li>Test Incrementally: Add one promotion rule at a time</li> <li>Use Sequence Keyword: Prefer <code>sequence</code> over comma-separated numbers</li> <li>Verify Configuration Loading: Check that env vars or CLI flags are applied</li> </ol>"},{"location":"how-to/debug-parent-selection/#getting-help","title":"Getting Help","text":"<p>If you're still having parent selection issues:</p> <ol> <li>Collect debug logs with <code>LOG_LEVEL=debug</code></li> <li>Document your configuration (CRITERIA, PARENT_FILENAME_PROMOTE, etc.)</li> <li>Provide example filenames and expected vs actual parents</li> <li>Include relevant log excerpts showing parent selection</li> <li>Open an issue on GitHub with this information</li> </ol>"},{"location":"how-to/migrate-criteria/","title":"How to Migrate Between Criteria Configurations","text":"<p>This guide helps you safely migrate from one stacking criteria configuration to another without losing data or creating inconsistent stacks.</p>"},{"location":"how-to/migrate-criteria/#why-migrate-criteria","title":"Why Migrate Criteria","text":"<p>You might need to migrate criteria when:</p> <ul> <li>Changing from simple to advanced grouping</li> <li>Adjusting time delta values</li> <li>Switching from Legacy to Groups or Expression mode</li> <li>Refining parent selection rules</li> <li>Consolidating multiple criteria into one</li> <li>Fixing incorrect stacking logic</li> </ul>"},{"location":"how-to/migrate-criteria/#migration-safety-principles","title":"Migration Safety Principles","text":""},{"location":"how-to/migrate-criteria/#core-safety-rules","title":"Core Safety Rules","text":"<ol> <li>Always use dry-run first: Preview changes before applying</li> <li>Backup your database: Immich database before major migrations</li> <li>Test with small subset: Verify logic on small sample first</li> <li>Document old configuration: Save current criteria before changing</li> <li>Monitor first run: Watch logs closely for unexpected behavior</li> </ol>"},{"location":"how-to/migrate-criteria/#migration-strategies","title":"Migration Strategies","text":"<pre><code>Strategy 1: Clean Slate (safest, most disruptive)\n\u2514\u2500 Delete all stacks \u2192 Apply new criteria\n\nStrategy 2: Incremental Replace (safer, less disruptive)\n\u2514\u2500 Keep existing stacks \u2192 Replace only conflicting ones\n\nStrategy 3: Additive (safest, least disruptive)\n\u2514\u2500 Keep existing stacks \u2192 Add only new stacks\n</code></pre>"},{"location":"how-to/migrate-criteria/#pre-migration-checklist","title":"Pre-Migration Checklist","text":"<p>Before starting any migration:</p> <ul> <li>[ ] Document current criteria configuration</li> <li>[ ] Backup Immich database</li> <li>[ ] Test new criteria with <code>DRY_RUN=true</code></li> <li>[ ] Review dry-run logs for expected behavior</li> <li>[ ] Identify which stacks will be affected</li> <li>[ ] Choose migration strategy</li> <li>[ ] Plan rollback procedure</li> <li>[ ] Schedule migration during low-usage period</li> </ul>"},{"location":"how-to/migrate-criteria/#migration-strategy-1-clean-slate","title":"Migration Strategy 1: Clean Slate","text":""},{"location":"how-to/migrate-criteria/#when-to-use","title":"When to Use","text":"<ul> <li>Major criteria changes</li> <li>Current stacks are mostly incorrect</li> <li>Starting fresh is simpler than incremental updates</li> <li>Small library where recreating stacks is fast</li> </ul>"},{"location":"how-to/migrate-criteria/#process","title":"Process","text":"<ol> <li>Save current configuration:</li> </ol> <pre><code># Save to file\necho \"CRITERIA='$CRITERIA'\" &gt; old-criteria.env\necho \"PARENT_FILENAME_PROMOTE=$PARENT_FILENAME_PROMOTE\" &gt;&gt; old-criteria.env\n</code></pre> <ol> <li>Test new configuration with dry-run:</li> </ol> <pre><code>CRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\".\"],\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":2000}}]'\nDRY_RUN=true\nLOG_LEVEL=debug\n./immich-stack\n</code></pre> <ol> <li> <p>Review dry-run output:</p> </li> <li> <p>Check number of stacks that would be created</p> </li> <li>Verify parent selection looks correct</li> <li> <p>Ensure grouping logic is as expected</p> </li> <li> <p>Execute clean slate migration:</p> </li> </ol> <pre><code>RUN_MODE=once\nRESET_STACKS=true\nCONFIRM_RESET_STACK=\"I acknowledge all my current stacks will be deleted and new one will be created\"\nCRITERIA='[new criteria here]'\nPARENT_FILENAME_PROMOTE=new,promotion,rules\n./immich-stack\n</code></pre> <ol> <li>Verify results:</li> </ol> <pre><code>LOG_LEVEL=info\n./immich-stack\n</code></pre>"},{"location":"how-to/migrate-criteria/#example-migrating-from-legacy-to-expression-mode","title":"Example: Migrating from Legacy to Expression Mode","text":"<p>Old Configuration:</p> <pre><code>CRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\".\"],\"index\":0}}]'\n</code></pre> <p>New Configuration:</p> <pre><code>CRITERIA='{\"mode\":\"advanced\",\"expression\":{\"operator\":\"AND\",\"children\":[{\"criteria\":{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\".\"],\"index\":0}}},{\"criteria\":{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}}]}}'\n</code></pre> <p>Migration:</p> <pre><code># Step 1: Dry-run with new criteria\nDRY_RUN=true \\\nCRITERIA='{\"mode\":\"advanced\",\"expression\":{\"operator\":\"AND\",\"children\":[{\"criteria\":{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\".\"],\"index\":0}}},{\"criteria\":{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}}]}}' \\\n./immich-stack\n\n# Step 2: Review output, then execute\nRUN_MODE=once \\\nRESET_STACKS=true \\\nCONFIRM_RESET_STACK=\"I acknowledge all my current stacks will be deleted and new one will be created\" \\\nCRITERIA='{\"mode\":\"advanced\",\"expression\":{\"operator\":\"AND\",\"children\":[{\"criteria\":{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\".\"],\"index\":0}}},{\"criteria\":{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}}]}}' \\\n./immich-stack\n</code></pre>"},{"location":"how-to/migrate-criteria/#migration-strategy-2-incremental-replace","title":"Migration Strategy 2: Incremental Replace","text":""},{"location":"how-to/migrate-criteria/#when-to-use_1","title":"When to Use","text":"<ul> <li>Minor criteria adjustments</li> <li>Most existing stacks are correct</li> <li>Only specific stacks need updating</li> <li>Large library where full reset is time-consuming</li> </ul>"},{"location":"how-to/migrate-criteria/#process_1","title":"Process","text":"<ol> <li>Save current configuration:</li> </ol> <pre><code>echo \"CRITERIA='$CRITERIA'\" &gt; old-criteria.env\n</code></pre> <ol> <li>Update criteria and enable replace mode:</li> </ol> <pre><code>REPLACE_STACKS=true\nCRITERIA='[updated criteria]'\nDRY_RUN=true\n./immich-stack\n</code></pre> <ol> <li> <p>Review which stacks will be replaced:</p> </li> <li> <p>Logs will show \"Deleted Stack ... - replacing child stack with new one\"</p> </li> <li> <p>Count how many stacks will be affected</p> </li> <li> <p>Execute replacement:</p> </li> </ol> <pre><code>REPLACE_STACKS=true\nCRITERIA='[updated criteria]'\nDRY_RUN=false\n./immich-stack\n</code></pre> <ol> <li>Monitor logs for unexpected replacements</li> </ol>"},{"location":"how-to/migrate-criteria/#example-adjusting-time-delta","title":"Example: Adjusting Time Delta","text":"<p>Old Configuration (too tight):</p> <pre><code>CRITERIA='[{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":500}}]'\n</code></pre> <p>New Configuration (more reasonable):</p> <pre><code>CRITERIA='[{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":2000}}]'\n</code></pre> <p>Migration:</p> <pre><code># Dry-run first\nREPLACE_STACKS=true \\\nDRY_RUN=true \\\nCRITERIA='[{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":2000}}]' \\\n./immich-stack\n\n# Execute after verifying\nREPLACE_STACKS=true \\\nDRY_RUN=false \\\nCRITERIA='[{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":2000}}]' \\\n./immich-stack\n</code></pre>"},{"location":"how-to/migrate-criteria/#migration-strategy-3-additive","title":"Migration Strategy 3: Additive","text":""},{"location":"how-to/migrate-criteria/#when-to-use_2","title":"When to Use","text":"<ul> <li>Adding new grouping rules</li> <li>Existing stacks should remain untouched</li> <li>Only creating new stacks for previously ungrouped assets</li> <li>Safest option when existing stacks are correct</li> </ul>"},{"location":"how-to/migrate-criteria/#process_2","title":"Process","text":"<ol> <li>Disable stack replacement:</li> </ol> <pre><code>REPLACE_STACKS=false\n</code></pre> <ol> <li>Add new criteria:</li> </ol> <pre><code>CRITERIA='[new criteria including previous logic]'\nDRY_RUN=true\n./immich-stack\n</code></pre> <ol> <li> <p>Verify only new stacks are created:</p> </li> <li> <p>Check logs for \"Stack created\" (not \"replacing\")</p> </li> <li> <p>Verify existing stacks are skipped</p> </li> <li> <p>Execute addition:</p> </li> </ol> <pre><code>REPLACE_STACKS=false\nCRITERIA='[new criteria]'\n./immich-stack\n</code></pre>"},{"location":"how-to/migrate-criteria/#example-adding-filename-grouping-to-time-based-stacks","title":"Example: Adding Filename Grouping to Time-Based Stacks","text":"<p>Old Configuration:</p> <pre><code>CRITERIA='[{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]'\n</code></pre> <p>New Configuration (adds filename grouping):</p> <pre><code>CRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\".\"],\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]'\n</code></pre> <p>Migration:</p> <pre><code># Additive migration - keep existing stacks\nREPLACE_STACKS=false \\\nCRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\".\"],\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]' \\\n./immich-stack\n</code></pre>"},{"location":"how-to/migrate-criteria/#advanced-migration-scenarios","title":"Advanced Migration Scenarios","text":""},{"location":"how-to/migrate-criteria/#scenario-1-migrating-parent-selection-rules","title":"Scenario 1: Migrating Parent Selection Rules","text":"<p>When changing parent selection rules without changing grouping:</p> <pre><code># Old promotion rules\nPARENT_FILENAME_PROMOTE=raw,original\n\n# New promotion rules (prefer edited files)\nPARENT_FILENAME_PROMOTE=edited,final,raw,original\n\n# Migration\nREPLACE_STACKS=true  # Must replace to change parents\nPARENT_FILENAME_PROMOTE=edited,final,raw,original\n./immich-stack\n</code></pre> <p>Note: Changing promotion rules requires <code>REPLACE_STACKS=true</code> because parent relationships must be updated.</p>"},{"location":"how-to/migrate-criteria/#scenario-2-splitting-one-large-criteria-into-multiple","title":"Scenario 2: Splitting One Large Criteria into Multiple","text":"<p>Old (single criteria):</p> <pre><code>CRITERIA='[{\"key\":\"originalFileName\",\"regex\":{\"key\":\".*\",\"index\":0}}]'\n</code></pre> <p>New (multiple specific criteria):</p> <pre><code>CRITERIA='{\"mode\":\"advanced\",\"groups\":[{\"operator\":\"AND\",\"criteria\":[{\"key\":\"originalFileName\",\"regex\":{\"key\":\"^PXL_\",\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]},{\"operator\":\"AND\",\"criteria\":[{\"key\":\"originalFileName\",\"regex\":{\"key\":\"^IMG_\",\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]}]}'\n</code></pre> <p>Migration:</p> <pre><code># Clean slate recommended for major restructuring\nRUN_MODE=once\nRESET_STACKS=true\nCONFIRM_RESET_STACK=\"I acknowledge all my current stacks will be deleted and new one will be created\"\nCRITERIA='[new groups configuration]'\n./immich-stack\n</code></pre>"},{"location":"how-to/migrate-criteria/#scenario-3-merging-multiple-criteria","title":"Scenario 3: Merging Multiple Criteria","text":"<p>Old (multiple runs with different criteria):</p> <pre><code># Run 1: Group by filename\nCRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\".\"],\"index\":0}}]'\n\n# Run 2: Group by time\nCRITERIA='[{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]'\n</code></pre> <p>New (unified criteria):</p> <pre><code>CRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\".\"],\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]'\n</code></pre> <p>Migration:</p> <pre><code># Clean slate to unify into single logic\nRUN_MODE=once\nRESET_STACKS=true\nCONFIRM_RESET_STACK=\"I acknowledge all my current stacks will be deleted and new one will be created\"\nCRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\".\"],\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]'\n./immich-stack\n</code></pre>"},{"location":"how-to/migrate-criteria/#testing-migrations","title":"Testing Migrations","text":""},{"location":"how-to/migrate-criteria/#test-framework","title":"Test Framework","text":"<p>Create a test script to validate migration:</p> <pre><code>#!/bin/bash\n\necho \"Migration Test Script\"\n\n# Step 1: Save current state\nSTACK_COUNT_BEFORE=$(curl -s $API_URL/stacks -H \"x-api-key: $API_KEY\" | jq 'length')\necho \"Current stack count: $STACK_COUNT_BEFORE\"\n\n# Step 2: Dry-run with new criteria\necho \"Running dry-run...\"\nDRY_RUN=true \\\nCRITERIA='[new criteria]' \\\n./immich-stack &gt; migration-test.log\n\n# Step 3: Analyze dry-run results\nEXPECTED_STACKS=$(grep \"formed\" migration-test.log | awk '{print $6}')\necho \"Expected new stacks: $EXPECTED_STACKS\"\n\n# Step 4: Confirm before executing\nread -p \"Proceed with migration? (yes/no) \" -n 3 -r\necho\nif [[ $REPLY =~ ^yes$ ]]; then\n  echo \"Executing migration...\"\n  DRY_RUN=false \\\n  CRITERIA='[new criteria]' \\\n  ./immich-stack\n\n  # Verify\n  STACK_COUNT_AFTER=$(curl -s $API_URL/stacks -H \"x-api-key: $API_KEY\" | jq 'length')\n  echo \"Stack count after: $STACK_COUNT_AFTER\"\nelse\n  echo \"Migration cancelled\"\nfi\n</code></pre>"},{"location":"how-to/migrate-criteria/#validation-checklist","title":"Validation Checklist","text":"<p>After migration, verify:</p> <ul> <li>[ ] Stack count matches expectations</li> <li>[ ] Parent assets are correct for sample stacks</li> <li>[ ] No unexpected stack deletions</li> <li>[ ] Logs show expected behavior</li> <li>[ ] UI shows stacks correctly grouped</li> <li>[ ] No assets lost or duplicated</li> </ul>"},{"location":"how-to/migrate-criteria/#rollback-procedures","title":"Rollback Procedures","text":""},{"location":"how-to/migrate-criteria/#immediate-rollback","title":"Immediate Rollback","text":"<p>If migration fails or produces unexpected results:</p> <ol> <li>Stop current process:</li> </ol> <pre><code>docker stop immich-stack\n</code></pre> <ol> <li>Restore database backup:</li> </ol> <pre><code># Restore Immich database from backup\n# (Process varies by setup - consult Immich docs)\n</code></pre> <ol> <li>Revert to old configuration:</li> </ol> <pre><code>source old-criteria.env\n./immich-stack\n</code></pre>"},{"location":"how-to/migrate-criteria/#partial-rollback","title":"Partial Rollback","text":"<p>If only some stacks are problematic:</p> <ol> <li> <p>Identify affected assets:</p> </li> <li> <p>Use Immich UI to find incorrectly stacked photos</p> </li> <li> <p>Manually unstack in Immich UI</p> </li> <li> <p>Re-run with corrected criteria:</p> </li> </ol> <pre><code>REPLACE_STACKS=true\nCRITERIA='[corrected criteria]'\n./immich-stack\n</code></pre>"},{"location":"how-to/migrate-criteria/#migration-best-practices","title":"Migration Best Practices","text":"<ol> <li>Always Test First: Use <code>DRY_RUN=true</code> before any migration</li> <li>Backup Before Changing: Database backups are essential</li> <li>Start Small: Test criteria on small subset first</li> <li>Monitor Closely: Watch logs during first real run</li> <li>Validate Results: Check sample stacks in UI after migration</li> <li>Document Changes: Keep log of what changed and why</li> <li>Schedule Wisely: Migrate during low-usage periods</li> <li>Have Rollback Plan: Know how to revert if needed</li> </ol>"},{"location":"how-to/migrate-criteria/#common-migration-mistakes","title":"Common Migration Mistakes","text":""},{"location":"how-to/migrate-criteria/#mistake-1-not-testing-with-dry-run","title":"Mistake 1: Not Testing with Dry-Run","text":"<p>Problem: Executing migration without preview</p> <p>Solution: Always run with <code>DRY_RUN=true</code> first</p>"},{"location":"how-to/migrate-criteria/#mistake-2-forgetting-replace_stacks","title":"Mistake 2: Forgetting REPLACE_STACKS","text":"<p>Problem: New criteria doesn't affect existing stacks</p> <p>Solution:</p> <pre><code>REPLACE_STACKS=true  # Required to update existing stacks\n</code></pre>"},{"location":"how-to/migrate-criteria/#mistake-3-wrong-migration-strategy","title":"Mistake 3: Wrong Migration Strategy","text":"<p>Problem: Using additive when clean slate is needed</p> <p>Solution: Choose strategy based on extent of changes (minor = incremental, major = clean slate)</p>"},{"location":"how-to/migrate-criteria/#mistake-4-no-rollback-plan","title":"Mistake 4: No Rollback Plan","text":"<p>Problem: Can't undo migration if it fails</p> <p>Solution: Backup database and save old configuration before migrating</p>"},{"location":"how-to/migrate-criteria/#mistake-5-incomplete-criteria-conversion","title":"Mistake 5: Incomplete Criteria Conversion","text":"<p>Problem: Missing part of old logic in new criteria</p> <p>Solution: Document old criteria completely, verify new criteria includes all required logic</p>"},{"location":"how-to/migrate-criteria/#troubleshooting-failed-migrations","title":"Troubleshooting Failed Migrations","text":""},{"location":"how-to/migrate-criteria/#issue-stacks-not-created-as-expected","title":"Issue: Stacks Not Created as Expected","text":"<p>Debug:</p> <pre><code>LOG_LEVEL=debug\nDRY_RUN=true\n./immich-stack &gt; debug-migration.log\n</code></pre> <p>Check:</p> <ul> <li>Criteria syntax is valid JSON</li> <li>All required fields present</li> <li>Regex patterns are correct</li> <li>Time deltas are reasonable</li> </ul>"},{"location":"how-to/migrate-criteria/#issue-too-many-stacks-replaced","title":"Issue: Too Many Stacks Replaced","text":"<p>Debug:</p> <ul> <li>Review REPLACE_STACKS setting</li> <li>Check if criteria changed more than expected</li> <li>Verify parent promotion rules</li> </ul> <p>Solution:</p> <ul> <li>Use more conservative criteria</li> <li>Start with REPLACE_STACKS=false</li> <li>Incrementally add replacing logic</li> </ul>"},{"location":"how-to/migrate-criteria/#issue-performance-degraded-after-migration","title":"Issue: Performance Degraded After Migration","text":"<p>Debug:</p> <ul> <li>New criteria may be more complex</li> <li>Expression nesting may be too deep</li> <li>Regex patterns may be inefficient</li> </ul> <p>Solution: See How to Optimize Criteria for Performance</p>"},{"location":"how-to/migrate-criteria/#migration-templates","title":"Migration Templates","text":""},{"location":"how-to/migrate-criteria/#template-1-simple-time-delta-adjustment","title":"Template 1: Simple Time Delta Adjustment","text":"<pre><code># Save old config\nOLD_DELTA=1000\nNEW_DELTA=2000\n\n# Test\nDRY_RUN=true \\\nCRITERIA=\"[{\\\"key\\\":\\\"localDateTime\\\",\\\"delta\\\":{\\\"milliseconds\\\":$NEW_DELTA}}]\" \\\n./immich-stack\n\n# Execute\nREPLACE_STACKS=true \\\nCRITERIA=\"[{\\\"key\\\":\\\"localDateTime\\\",\\\"delta\\\":{\\\"milliseconds\\\":$NEW_DELTA}}]\" \\\n./immich-stack\n</code></pre>"},{"location":"how-to/migrate-criteria/#template-2-adding-new-grouping-criteria","title":"Template 2: Adding New Grouping Criteria","text":"<pre><code># Old: filename only\n# New: filename + time\n\nDRY_RUN=true \\\nCRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\".\"],\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]' \\\n./immich-stack\n\n# Execute as clean slate\nRUN_MODE=once \\\nRESET_STACKS=true \\\nCONFIRM_RESET_STACK=\"I acknowledge all my current stacks will be deleted and new one will be created\" \\\nCRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\".\"],\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]' \\\n./immich-stack\n</code></pre>"},{"location":"how-to/migrate-criteria/#template-3-parent-promotion-rule-changes","title":"Template 3: Parent Promotion Rule Changes","text":"<pre><code># Test new promotion rules\nDRY_RUN=true \\\nREPLACE_STACKS=true \\\nPARENT_FILENAME_PROMOTE=new,rules,here \\\n./immich-stack\n\n# Execute\nREPLACE_STACKS=true \\\nPARENT_FILENAME_PROMOTE=new,rules,here \\\n./immich-stack\n</code></pre>"},{"location":"how-to/migrate-criteria/#getting-help-with-migrations","title":"Getting Help with Migrations","text":"<p>If you encounter issues during migration:</p> <ol> <li>Collect full logs with <code>LOG_LEVEL=debug</code></li> <li>Document old and new configurations</li> <li>Describe expected vs actual behavior</li> <li>Check if dry-run showed different results</li> <li>Verify database state via Immich API or UI</li> <li>Open issue on GitHub with details</li> </ol>"},{"location":"how-to/optimize-performance/","title":"How to Optimize Criteria for Performance","text":"<p>This guide helps you optimize stacking criteria for better performance, especially with large photo libraries (50k+ assets).</p>"},{"location":"how-to/optimize-performance/#performance-fundamentals","title":"Performance Fundamentals","text":""},{"location":"how-to/optimize-performance/#key-performance-factors","title":"Key Performance Factors","text":"<ol> <li>Criteria Complexity: More complex criteria = longer processing time</li> <li>Library Size: Linear scaling with asset count</li> <li>Regex Patterns: Complex regex can slow processing significantly</li> <li>Time Deltas: Smaller deltas = more groups = more processing</li> <li>Expression Nesting: Deep nesting multiplies evaluation cost</li> </ol>"},{"location":"how-to/optimize-performance/#performance-targets","title":"Performance Targets","text":"Library Size Target Processing Time Recommended Mode &lt; 10k assets &lt; 30 seconds Any mode 10k-50k assets &lt; 2 minutes Legacy or Groups 50k-100k assets &lt; 5 minutes Legacy preferred &gt; 100k assets &lt; 10 minutes Legacy only"},{"location":"how-to/optimize-performance/#choosing-the-right-grouping-mode","title":"Choosing the Right Grouping Mode","text":""},{"location":"how-to/optimize-performance/#mode-comparison","title":"Mode Comparison","text":"<pre><code>Legacy Mode:\n- Simplest and fastest\n- AND logic only\n- Best for large libraries (100k+ assets)\n- Lowest memory usage\n\nGroups Mode:\n- Moderate complexity\n- Multiple strategies with AND/OR per group\n- Good for medium libraries (10k-50k assets)\n- Moderate memory usage\n\nExpression Mode:\n- Most flexible but slowest\n- Unlimited nesting with AND/OR/NOT\n- Best for small libraries (&lt; 10k assets)\n- Highest memory usage\n</code></pre>"},{"location":"how-to/optimize-performance/#when-to-use-each-mode","title":"When to Use Each Mode","text":"<p>Use Legacy Mode When:</p> <ul> <li>Library has &gt; 50k assets</li> <li>Simple grouping rules suffice</li> <li>Performance is critical</li> <li>Memory is limited</li> </ul> <p>Use Groups Mode When:</p> <ul> <li>Need multiple grouping strategies</li> <li>Library has 10k-50k assets</li> <li>Performance is moderately important</li> <li>Some flexibility needed</li> </ul> <p>Use Expression Mode When:</p> <ul> <li>Need complex nested logic</li> <li>Library has &lt; 10k assets</li> <li>Flexibility is more important than speed</li> <li>Have sufficient memory available</li> </ul>"},{"location":"how-to/optimize-performance/#optimizing-time-delta-criteria","title":"Optimizing Time Delta Criteria","text":""},{"location":"how-to/optimize-performance/#time-delta-performance","title":"Time Delta Performance","text":"<p>Smaller time deltas create more, smaller groups which increases processing:</p> <pre><code>// Tight grouping - MORE processing\n{\"key\": \"localDateTime\", \"delta\": {\"milliseconds\": 100}}\n\n// Loose grouping - LESS processing\n{\"key\": \"localDateTime\", \"delta\": {\"milliseconds\": 5000}}\n</code></pre>"},{"location":"how-to/optimize-performance/#choosing-the-right-delta","title":"Choosing the Right Delta","text":"Use Case Recommended Delta Reasoning Burst photos (same moment) 100-500ms Captures rapid sequences HDR/bracketing 1000-2000ms Multiple exposures General stacking 1000-3000ms Balance accuracy and performance Panoramas 2000-5000ms Slower shooting process Time-lapse frames 5000-10000ms Intentional time gaps"},{"location":"how-to/optimize-performance/#testing-delta-performance","title":"Testing Delta Performance","text":"<pre><code># Test with different deltas and measure time\ntime CRITERIA='[{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]' ./immich-stack\n\ntime CRITERIA='[{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":5000}}]' ./immich-stack\n</code></pre>"},{"location":"how-to/optimize-performance/#optimizing-regex-patterns","title":"Optimizing Regex Patterns","text":""},{"location":"how-to/optimize-performance/#regex-performance-impact","title":"Regex Performance Impact","text":"<p>Complex regex patterns are evaluated for every asset in your library.</p> <p>Fast Patterns (prefer these):</p> <pre><code>// Simple prefix match\n{\"key\": \"PXL_\", \"index\": 0}\n\n// Simple digit pattern\n{\"key\": \"IMG_\\\\d{4}\", \"index\": 0}\n\n// Anchored pattern\n{\"key\": \"^IMG_\", \"index\": 0}\n</code></pre> <p>Slow Patterns (avoid):</p> <pre><code>// Multiple wildcards with backtracking\n{\"key\": \".*photo.*\\\\d+.*edited.*\", \"index\": 0}\n\n// Complex alternation\n{\"key\": \"(IMG|DSC|PXL)_\\\\d{4,6}_.*\", \"index\": 0}\n\n// Nested repetition\n{\"key\": \"(.*)+(IMG|DSC)+\", \"index\": 0}\n</code></pre>"},{"location":"how-to/optimize-performance/#regex-optimization-techniques","title":"Regex Optimization Techniques","text":"<ol> <li>Use Anchors: <code>^IMG_</code> is faster than <code>IMG_</code></li> <li>Avoid Wildcards: <code>IMG_\\d{4}</code> is faster than <code>IMG_.*</code></li> <li>Use Character Classes: <code>[A-Z]</code> instead of <code>(A|B|C|...)</code></li> <li>Limit Repetition: <code>\\d{4}</code> instead of <code>\\d+</code></li> <li>Avoid Backtracking: Don't use nested <code>.*</code> or <code>(.+)+</code></li> </ol>"},{"location":"how-to/optimize-performance/#testing-regex-performance","title":"Testing Regex Performance","text":"<pre><code># Benchmark different regex patterns\ntime CRITERIA='[{\"key\":\"originalFileName\",\"regex\":{\"key\":\"^PXL_\",\"index\":0}}]' ./immich-stack\n\ntime CRITERIA='[{\"key\":\"originalFileName\",\"regex\":{\"key\":\".*PXL.*\",\"index\":0}}]' ./immich-stack\n</code></pre>"},{"location":"how-to/optimize-performance/#expression-mode-optimization","title":"Expression Mode Optimization","text":""},{"location":"how-to/optimize-performance/#nesting-depth-impact","title":"Nesting Depth Impact","text":"Nesting Level Performance Impact Use Case 1-2 levels Negligible (&lt; 5% overhead) Safe for all libraries 3-4 levels Slight increase (5-15% overhead) Acceptable for &lt; 50k assets 5+ levels Noticeable impact (&gt; 15% overhead) Only for &lt; 10k assets"},{"location":"how-to/optimize-performance/#example-optimizing-deep-nesting","title":"Example: Optimizing Deep Nesting","text":"<p>Before (5 levels deep):</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"operator\": \"OR\",\n        \"children\": [\n          {\n            \"operator\": \"AND\",\n            \"children\": [\n              {\n                \"operator\": \"OR\",\n                \"children\": [\n                  {\n                    \"operator\": \"AND\",\n                    \"children\": [\n                      {\n                        \"criteria\": {\n                          \"key\": \"originalFileName\",\n                          \"regex\": { \"key\": \"PXL_\", \"index\": 0 }\n                        }\n                      },\n                      {\n                        \"criteria\": {\n                          \"key\": \"localDateTime\",\n                          \"delta\": { \"milliseconds\": 1000 }\n                        }\n                      }\n                    ]\n                  }\n                ]\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> <p>After (2 levels deep - same logic, flattened):</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"criteria\": {\n          \"key\": \"originalFileName\",\n          \"regex\": { \"key\": \"PXL_\", \"index\": 0 }\n        }\n      },\n      {\n        \"criteria\": {\n          \"key\": \"localDateTime\",\n          \"delta\": { \"milliseconds\": 1000 }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>Result: 60% faster processing for same logic.</p>"},{"location":"how-to/optimize-performance/#simplification-strategies","title":"Simplification Strategies","text":"<ol> <li>Flatten Nested ANDs: <code>AND(AND(A, B), C)</code> \u2192 <code>AND(A, B, C)</code></li> <li>Flatten Nested ORs: <code>OR(OR(A, B), C)</code> \u2192 <code>OR(A, B, C)</code></li> <li>Remove Redundant Operators: Single-child operators can be eliminated</li> <li>Use Groups Mode: If nesting &gt; 3 levels, consider Groups mode instead</li> </ol>"},{"location":"how-to/optimize-performance/#memory-optimization","title":"Memory Optimization","text":""},{"location":"how-to/optimize-performance/#memory-usage-scaling","title":"Memory Usage Scaling","text":"<p>Memory usage depends on:</p> <ol> <li>Asset count: ~1KB per asset in memory</li> <li>Criteria complexity: Expression trees consume additional memory</li> <li>Stack size: Larger stacks increase memory overhead</li> </ol>"},{"location":"how-to/optimize-performance/#expected-memory-usage","title":"Expected Memory Usage","text":"Library Size Legacy Mode Groups Mode Expression Mode 10k assets &lt; 100MB &lt; 150MB &lt; 200MB 50k assets 100-500MB 500-750MB 750MB-1GB 100k assets 500MB-1GB 1-1.5GB 1.5-2GB 200k assets 1-2GB Not recommended Not recommended"},{"location":"how-to/optimize-performance/#memory-optimization-techniques","title":"Memory Optimization Techniques","text":"<ol> <li>Use Filters:</li> </ol> <pre><code>WITH_ARCHIVED=false  # Exclude archived assets\nWITH_DELETED=false   # Exclude deleted assets\n</code></pre> <ol> <li>Process in Batches: For very large libraries, process subsets:</li> </ol> <pre><code># Process only recent photos\nCRITERIA='[{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}},{\"key\":\"originalFileName\",\"regex\":{\"key\":\"^2025\",\"index\":0}}]'\n</code></pre> <ol> <li> <p>Use Simpler Criteria: Legacy mode uses less memory than Expression mode</p> </li> <li> <p>Increase Swap: For systems with limited RAM</p> </li> </ol>"},{"location":"how-to/optimize-performance/#benchmarking-your-configuration","title":"Benchmarking Your Configuration","text":""},{"location":"how-to/optimize-performance/#performance-testing-script","title":"Performance Testing Script","text":"<pre><code>#!/bin/bash\n\necho \"Testing performance with different configurations...\"\n\n# Test 1: Legacy mode with simple criteria\necho \"Test 1: Legacy mode\"\ntime CRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\".\"],\"index\":0}}]' \\\n  DRY_RUN=true \\\n  LOG_LEVEL=warn \\\n  ./immich-stack\n\n# Test 2: Groups mode\necho \"Test 2: Groups mode\"\ntime CRITERIA='{\"mode\":\"advanced\",\"groups\":[{\"operator\":\"AND\",\"criteria\":[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\".\"],\"index\":0}}]}]}' \\\n  DRY_RUN=true \\\n  LOG_LEVEL=warn \\\n  ./immich-stack\n\n# Test 3: Expression mode\necho \"Test 3: Expression mode\"\ntime CRITERIA='{\"mode\":\"advanced\",\"expression\":{\"operator\":\"AND\",\"children\":[{\"criteria\":{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\".\"],\"index\":0}}}]}}' \\\n  DRY_RUN=true \\\n  LOG_LEVEL=warn \\\n  ./immich-stack\n</code></pre>"},{"location":"how-to/optimize-performance/#analyzing-results","title":"Analyzing Results","text":"<p>Compare execution times and choose the fastest configuration that meets your needs.</p> <pre><code>Test 1: Legacy mode      - 45 seconds\nTest 2: Groups mode      - 62 seconds\nTest 3: Expression mode  - 78 seconds\n\nRecommendation: Use Legacy mode (42% faster than Expression)\n</code></pre>"},{"location":"how-to/optimize-performance/#cron-mode-performance-tuning","title":"Cron Mode Performance Tuning","text":""},{"location":"how-to/optimize-performance/#interval-sizing","title":"Interval Sizing","text":"<p>Choose CRON_INTERVAL based on processing time:</p> <p>Formula: <code>CRON_INTERVAL = (processing_time \u00d7 2) + buffer</code></p> <p>Example:</p> <pre><code># Processing takes 10 minutes\n# Interval = (10 \u00d7 2) + 10 = 30 minutes minimum\nCRON_INTERVAL=1800  # 30 minutes\n</code></pre>"},{"location":"how-to/optimize-performance/#preventing-overlap","title":"Preventing Overlap","text":"<p>Monitor logs for timing warnings:</p> <pre><code>\u26a0\ufe0f Warning: Processing took 5400s, which exceeds interval of 3600s\n</code></pre> <p>Solution: Increase CRON_INTERVAL or optimize criteria to reduce processing time.</p>"},{"location":"how-to/optimize-performance/#resource-limits","title":"Resource Limits","text":"<p>Set Docker resource limits to prevent runaway usage:</p> <pre><code>services:\n  immich-stack:\n    deploy:\n      resources:\n        limits:\n          memory: 2G # Adjust based on library size\n          cpus: \"1.0\"\n</code></pre>"},{"location":"how-to/optimize-performance/#real-world-optimization-examples","title":"Real-World Optimization Examples","text":""},{"location":"how-to/optimize-performance/#example-1-large-google-photos-library","title":"Example 1: Large Google Photos Library","text":"<p>Before (8 minutes):</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"criteria\": {\n          \"key\": \"originalFileName\",\n          \"regex\": { \"key\": \".*PXL.*\", \"index\": 0 }\n        }\n      },\n      {\n        \"criteria\": { \"key\": \"localDateTime\", \"delta\": { \"milliseconds\": 500 } }\n      }\n    ]\n  }\n}\n</code></pre> <p>After (3 minutes - 62% faster):</p> <pre><code>[\n  { \"key\": \"originalFileName\", \"regex\": { \"key\": \"^PXL_\", \"index\": 0 } },\n  { \"key\": \"localDateTime\", \"delta\": { \"milliseconds\": 1000 } }\n]\n</code></pre> <p>Changes:</p> <ul> <li>Switched to Legacy mode</li> <li>Anchored regex pattern (^PXL_)</li> <li>Increased time delta (500ms \u2192 1000ms)</li> </ul>"},{"location":"how-to/optimize-performance/#example-2-mixed-camera-library","title":"Example 2: Mixed Camera Library","text":"<p>Before (12 minutes):</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"OR\",\n    \"children\": [\n      {\n        \"criteria\": {\n          \"key\": \"originalFileName\",\n          \"regex\": { \"key\": \"(IMG|DSC|PXL)_.*\", \"index\": 0 }\n        }\n      },\n      {\n        \"criteria\": {\n          \"key\": \"originalFileName\",\n          \"regex\": { \"key\": \".*BURST.*\", \"index\": 0 }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>After (5 minutes - 58% faster):</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"groups\": [\n    {\n      \"operator\": \"AND\",\n      \"criteria\": [\n        {\n          \"key\": \"originalFileName\",\n          \"split\": { \"delimiters\": [\"_\", \".\"], \"index\": 0 }\n        },\n        { \"key\": \"localDateTime\", \"delta\": { \"milliseconds\": 1000 } }\n      ]\n    }\n  ]\n}\n</code></pre> <p>Changes:</p> <ul> <li>Switched to Groups mode</li> <li>Removed complex regex patterns</li> <li>Used split-based grouping instead</li> </ul>"},{"location":"how-to/optimize-performance/#example-3-event-photography","title":"Example 3: Event Photography","text":"<p>Before (20 minutes, 150k assets):</p> <pre><code>{\n  \"mode\": \"advanced\",\n  \"expression\": {\n    \"operator\": \"AND\",\n    \"children\": [\n      {\n        \"criteria\": {\n          \"key\": \"originalFileName\",\n          \"regex\": { \"key\": \".*\\\\d{4}.*\", \"index\": 0 }\n        }\n      },\n      {\n        \"criteria\": { \"key\": \"localDateTime\", \"delta\": { \"milliseconds\": 100 } }\n      }\n    ]\n  }\n}\n</code></pre> <p>After (6 minutes - 70% faster):</p> <pre><code>[\n  {\n    \"key\": \"originalFileName\",\n    \"split\": { \"delimiters\": [\"_\", \"-\", \".\"], \"index\": 0 }\n  },\n  { \"key\": \"localDateTime\", \"delta\": { \"milliseconds\": 2000 } }\n]\n</code></pre> <p>Changes:</p> <ul> <li>Switched to Legacy mode</li> <li>Removed regex (used split instead)</li> <li>Increased time delta (100ms \u2192 2000ms)</li> <li>Simpler filename grouping</li> </ul>"},{"location":"how-to/optimize-performance/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"how-to/optimize-performance/#key-metrics-to-track","title":"Key Metrics to Track","text":"<ol> <li>Processing Time: Total time for stack operations</li> <li>Assets per Second: <code>total_assets / processing_time</code></li> <li>Memory Usage: Peak memory during processing</li> <li>Stack Count: Number of stacks created/modified</li> </ol>"},{"location":"how-to/optimize-performance/#logging-performance-data","title":"Logging Performance Data","text":"<pre><code>LOG_LEVEL=info\nLOG_FORMAT=json\n\n# Processing logs will include:\n# - \"\ud83c\udf04 52193 assets fetched\"\n# - \"Legacy criteria stacking formed 4275 stacks from 52193 assets\"\n# - Execution time in logs\n</code></pre>"},{"location":"how-to/optimize-performance/#setting-performance-goals","title":"Setting Performance Goals","text":"Library Size Target Rate Example &lt; 10k assets &gt; 200 assets/sec 10k assets in 50 seconds 10k-50k assets &gt; 150 assets/sec 50k assets in 5 minutes &gt; 50k assets &gt; 100 assets/sec 100k assets in 15 minutes"},{"location":"how-to/optimize-performance/#troubleshooting-slow-performance","title":"Troubleshooting Slow Performance","text":""},{"location":"how-to/optimize-performance/#diagnostic-steps","title":"Diagnostic Steps","text":"<ol> <li>Enable timing logs:</li> </ol> <pre><code>LOG_LEVEL=debug\nLOG_FORMAT=json\ntime ./immich-stack\n</code></pre> <ol> <li>Check memory usage:</li> </ol> <pre><code>docker stats immich-stack\n</code></pre> <ol> <li> <p>Profile regex patterns: Test individual regex patterns with small datasets</p> </li> <li> <p>Simplify criteria: Try Legacy mode with basic criteria as baseline</p> </li> </ol>"},{"location":"how-to/optimize-performance/#common-bottlenecks","title":"Common Bottlenecks","text":"<ol> <li>Complex Regex: Switch to split-based grouping</li> <li>Small Time Deltas: Increase delta to reduce groups</li> <li>Deep Expression Nesting: Flatten or switch to Groups/Legacy mode</li> <li>Large Library: Use filters to process subsets</li> <li>Low Memory: Increase swap or process in batches</li> </ol>"},{"location":"how-to/optimize-performance/#best-practices-summary","title":"Best Practices Summary","text":"<ol> <li>Start Simple: Use Legacy mode for initial setup</li> <li>Benchmark: Test different configurations and measure</li> <li>Use Appropriate Delta: 1000-2000ms works for most use cases</li> <li>Optimize Regex: Use anchors and avoid wildcards</li> <li>Limit Nesting: Keep expression nesting &lt; 3 levels</li> <li>Filter Assets: Exclude archived/deleted when possible</li> <li>Size Intervals: Set CRON_INTERVAL &gt; 2\u00d7 processing time</li> <li>Monitor Resources: Track memory and CPU usage</li> <li>Test Incrementally: Add complexity only when needed</li> <li>Document Performance: Track metrics over time</li> </ol>"},{"location":"how-to/real-world-examples/","title":"Real-World Examples","text":"<p>Common stacking scenarios and how to solve them with immich-auto-stack.</p>"},{"location":"how-to/real-world-examples/#defaults-at-a-glance","title":"Defaults at a glance","text":"<p>These examples assume the defaults unless overridden:</p> <ul> <li>Criteria: <code>originalFileName</code> split on <code>[\"~\", \".\"]</code> (index <code>0</code>) + <code>localDateTime</code> within <code>1000ms</code></li> <li>Parent filename promote: <code>cover,edit,crop,hdr,biggestNumber</code></li> <li>Parent ext promote: <code>.jpg,.png,.jpeg,.heic,.dng</code></li> </ul> <p>Parent selection order:</p> <ol> <li>Regex <code>promote_index</code> (if present)</li> <li>Parent filename promote (order matters)</li> <li><code>biggestNumber</code> (only when in the promote list)</li> <li>Parent ext promote (order matters)</li> <li>Extension rank (<code>jpeg &gt; jpg &gt; png &gt; others</code>) when not explicitly promoted</li> <li>Alphabetical (case-sensitive)</li> </ol> <p>Important</p> <ul> <li>Order matters in both promote lists.</li> <li><code>biggestNumber</code> only works on numeric suffixes after delimiters found in your <code>originalFileName</code> split. If you want <code>-1</code> / <code>_2</code> to count, add <code>-</code> or <code>_</code> to <code>split.delimiters</code>.</li> </ul>"},{"location":"how-to/real-world-examples/#quick-verification","title":"Quick verification","text":"<p>Run in dry-run + debug to see grouping and parent selection in logs:</p> <pre><code>LOG_LEVEL=debug immich-stack --dry-run\n</code></pre> <p>All grouping/parent-selection scenarios below have matching tests in <code>pkg/stacker/examples_test.go</code>.</p>"},{"location":"how-to/real-world-examples/#raw-jpeg-pairing","title":"RAW + JPEG Pairing","text":""},{"location":"how-to/real-world-examples/#canon-nikon-sony-same-filename-different-extension","title":"Canon / Nikon / Sony (same filename, different extension)","text":"<p>Problem: Your camera produces <code>IMG_1234.jpg</code> and <code>IMG_1234.CR2</code> (or <code>.NEF</code>, <code>.ARW</code>). You want them grouped as a single stack with the JPEG on top.</p> <p>Solution: The default configuration handles this out of the box. No custom criteria needed.</p> <pre><code>API_KEY=your_key\nAPI_URL=http://immich-server:2283/api\n</code></pre> <p>The default criteria splits on <code>~</code> and <code>.</code> to extract the base filename (<code>IMG_1234</code>) and groups assets taken within 1 second of each other. The default <code>PARENT_EXT_PROMOTE=.jpg,.png,.jpeg,.heic,.dng</code> ensures common processed formats win over RAW.</p>"},{"location":"how-to/real-world-examples/#fujifilm-raf-jpeg","title":"Fujifilm RAF + JPEG","text":"<p>Problem: Your Fujifilm camera produces <code>DSCF1234.jpg</code> and <code>DSCF1234.RAF</code>. Same as above but with <code>.RAF</code> extension.</p> <p>Solution: Default configuration works. <code>.jpg</code> is promoted by default, so the JPEG will be the stack parent.</p>"},{"location":"how-to/real-world-examples/#samsung-galaxy-jpg-dng","title":"Samsung Galaxy (JPG + DNG)","text":"<p>Problem: Samsung phones produce <code>20240115_143022.jpg</code> and <code>20240115_143022.dng</code> when shooting RAW+JPEG.</p> <p>Solution: Default configuration works. Both <code>.jpg</code> and <code>.dng</code> are in the default extension promote list, with <code>.jpg</code> having higher priority.</p>"},{"location":"how-to/real-world-examples/#apple-iphone-proraw-heic-dng","title":"Apple iPhone ProRAW (HEIC + DNG)","text":"<p>Problem: iPhones with ProRAW enabled produce <code>IMG_1234.HEIC</code> and <code>IMG_1234.DNG</code>. You want them stacked with the HEIC on top.</p> <p>Solution: Default configuration works. Both <code>.heic</code> and <code>.dng</code> are in the default extension promote list, with <code>.heic</code> having higher priority.</p>"},{"location":"how-to/real-world-examples/#google-pixel-photos","title":"Google Pixel Photos","text":""},{"location":"how-to/real-world-examples/#pixel-raw-jpeg-standard","title":"Pixel RAW + JPEG (standard)","text":"<p>Problem: Pixel phones use a specific naming pattern:</p> <ul> <li><code>PXL_20260121_195958829.RAW-01.COVER.jpg</code></li> <li><code>PXL_20260121_195958829.RAW-02.ORIGINAL.dng</code></li> </ul> <p>The default split on <code>[\"~\", \".\"]</code> produces <code>PXL_20260121_195958829</code> from both files (index 0 after splitting on all delimiters). This works with default config out of the box.</p> <p>Solution: Default configuration works. For explicit control:</p> <pre><code>CRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\".\"],\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]'\nPARENT_EXT_PROMOTE=.jpg,.png,.jpeg,.heic,.dng\n</code></pre>"},{"location":"how-to/real-world-examples/#pixel-motion-photos","title":"Pixel Motion Photos","text":"<p>Problem: Pixel creates a Motion Photo variant alongside the regular photo:</p> <ul> <li><code>PXL_20240115_143022345.jpg</code></li> <li><code>PXL_20240115_143022345.MP.jpg</code></li> </ul> <p>You want them stacked together.</p> <p>Solution: Default configuration groups them (both resolve to <code>PXL_20240115_143022345</code> after splitting on <code>[\"~\", \".\"]</code>). To control which file is on top:</p> <p>To put the Motion Photo on top (default behavior): no change needed. The case-sensitive alphabetical tiebreaker sorts <code>.MP.jpg</code> before <code>.jpg</code> (uppercase <code>M</code> &lt; lowercase <code>j</code>), so the Motion Photo is the parent by default.</p> <p>To put the regular photo on top:</p> <pre><code>PARENT_FILENAME_PROMOTE=,mp,cover,edit,crop,hdr,biggestNumber\n</code></pre> <p>The leading empty string promotes files that do not contain <code>mp</code> (or any other keyword), making the plain <code>PXL_*.jpg</code> the parent.</p>"},{"location":"how-to/real-world-examples/#pixel-10-pro-triple-grouping-30x-zoom","title":"Pixel 10 Pro Triple Grouping (30x Zoom)","text":"<p>Problem: The Pixel 10 Pro creates three files for high-zoom shots:</p> <ul> <li><code>PXL_20260120_120000000.jpg</code> (original JPEG)</li> <li><code>PXL_20260120_120000000.dng</code> (RAW)</li> <li><code>PXL_20260120_120000000.NIGHT.jpg</code> (AI-processed)</li> </ul> <p>All three should be in one stack with the original JPEG on top.</p> <p>Solution: Default configuration groups them (the split on <code>[\"~\", \".\"]</code> extracts the same base filename from all three). However, the two <code>.jpg</code> files tie on extension promotion, and the case-sensitive alphabetical tiebreaker puts <code>.NIGHT.jpg</code> before <code>.jpg</code> (uppercase <code>N</code> &lt; lowercase <code>j</code>).</p> <p>To ensure the original JPEG is on top, use negative matching:</p> <pre><code>PARENT_FILENAME_PROMOTE=,night,cover,edit,crop,hdr,biggestNumber\n</code></pre> <p>The leading empty string promotes files that do not contain <code>night</code> (or any other keyword), making the plain <code>.jpg</code> the parent.</p>"},{"location":"how-to/real-world-examples/#google-photos-edited-versions","title":"Google Photos Edited Versions","text":"<p>Problem: Google Photos exports include edited copies alongside originals:</p> <ul> <li><code>vacation_sunset.jpg</code></li> <li><code>vacation_sunset-edited.jpg</code></li> </ul> <p>You want them stacked together.</p> <p>Solution: Add <code>-</code> to the split delimiters so both files resolve to the same base name:</p> <pre><code>CRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\"-\",\"~\",\".\"],\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]'\nPARENT_FILENAME_PROMOTE=edit,cover,crop,hdr,biggestNumber\n</code></pre> <p>The split on <code>[\"-\", \"~\", \".\"]</code> extracts <code>vacation_sunset</code> from both files. <code>PARENT_FILENAME_PROMOTE</code> with <code>edit</code> first makes the edited version the parent since its filename contains \"edited\". To put the original on top instead, use negative matching:</p> <pre><code>PARENT_FILENAME_PROMOTE=,edit,cover,crop,hdr,biggestNumber\n</code></pre> <p>The leading empty string promotes files that do not contain <code>edit</code> (or any other keyword), making the plain <code>vacation_sunset.jpg</code> the parent. Simply removing <code>edit</code> from the promote list is not enough \u2014 the alphabetical tiebreaker would still pick <code>vacation_sunset-edited.jpg</code> because <code>-</code> sorts before <code>.</code>.</p>"},{"location":"how-to/real-world-examples/#rawjpeg-with-lightroom-numeric-edits","title":"RAW+JPEG with Lightroom Numeric Edits","text":"<p>Problem: You shoot RAW+JPEG and use Lightroom to export edited versions with numeric suffixes. Your library contains:</p> <ul> <li><code>ABC001.ARW</code></li> <li><code>ABC001.JPEG</code></li> <li><code>ABC001-1.JPEG</code></li> <li><code>ABC001-2.JPEG</code></li> </ul> <p>You want all four in one stack, with the latest edit (<code>ABC001-2.JPEG</code>) as the thumbnail.</p> <p>Solution: Add <code>-</code> to the split delimiters so all files resolve to the same base name <code>ABC001</code>:</p> <pre><code>CRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\"-\",\"~\",\".\"],\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]'\nPARENT_EXT_PROMOTE=.jpg,.png,.jpeg,.heic,.dng,.arw\n</code></pre> <p>The default <code>PARENT_FILENAME_PROMOTE</code> already includes <code>biggestNumber</code>, which picks <code>ABC001-2.JPEG</code> (highest numeric suffix) as the parent. <code>PARENT_EXT_PROMOTE</code> with processed formats first ensures a JPG/PNG wins over the RAW when no numeric edit exists.</p> <p>This also works with the Pixel RAW naming pattern (<code>PXL_*.RAW-01.COVER.jpg</code> / <code>PXL_*.RAW-02.ORIGINAL.dng</code>) since the same split logic extracts the shared base. The default promote list includes <code>cover</code>, so the COVER JPEG can be selected as parent.</p>"},{"location":"how-to/real-world-examples/#photoshop-workflows","title":"Photoshop Workflows","text":""},{"location":"how-to/real-world-examples/#raw-jpeg-psd-photoshop-project-files","title":"RAW + JPEG + PSD (Photoshop Project Files)","text":"<p>Problem: You shoot RAW+JPEG and edit in Photoshop, keeping the <code>.psd</code> project file alongside exports. Your library contains:</p> <ul> <li><code>IMG_1234.CR2</code> (RAW)</li> <li><code>IMG_1234.jpg</code> (camera JPEG)</li> <li><code>IMG_1234.psd</code> (Photoshop project)</li> </ul> <p>You want all files grouped with the JPEG on top.</p> <p>Solution: Default configuration groups files with the same base filename. The <code>.psd</code> extension is listed after JPEG formats in the default extension promote list, so JPEG files become the stack thumbnail:</p> <pre><code>API_KEY=your_key\nAPI_URL=http://immich-server:2283/api\n</code></pre>"},{"location":"how-to/real-world-examples/#raw-jpeg-psd-with-final-export","title":"RAW + JPEG + PSD with Final Export","text":"<p>Problem: You also export a final edited version alongside the source files:</p> <ul> <li><code>IMG_1234.CR2</code> (RAW)</li> <li><code>IMG_1234.jpg</code> (camera JPEG)</li> <li><code>IMG_1234.psd</code> (Photoshop project)</li> <li><code>IMG_1234-final.jpg</code> (exported edit)</li> </ul> <p>You want all files grouped with the final export on top.</p> <p>Solution: Add <code>-</code> to the split delimiters so <code>IMG_1234-final.jpg</code> groups with the others:</p> <pre><code>CRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\"-\",\"~\",\".\"],\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]'\nPARENT_FILENAME_PROMOTE=final,edit,cover,crop,hdr,biggestNumber\nPARENT_EXT_PROMOTE=.jpg,.png,.jpeg,.heic,.psd,.dng,.cr2\n</code></pre> <p>The split on <code>[\"-\", \"~\", \".\"]</code> extracts <code>IMG_1234</code> from all files. The <code>final</code> keyword promotes <code>IMG_1234-final.jpg</code> as parent.</p>"},{"location":"how-to/real-world-examples/#photoshop-with-versioned-exports","title":"Photoshop with Versioned Exports","text":"<p>Problem: You use Photoshop's \"Save As\" to create multiple export versions:</p> <ul> <li><code>portrait.psd</code> (project file)</li> <li><code>portrait_1.jpg</code> (first export)</li> <li><code>portrait_2.jpg</code> (second export)</li> <li><code>portrait_final.jpg</code> (final version)</li> </ul> <p>You want them stacked with the final version on top.</p> <p>Solution: Add <code>_</code> to the split delimiters so all files resolve to the same base name:</p> <pre><code>CRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\"_\",\"~\",\".\"],\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":86400000}}]'\nPARENT_FILENAME_PROMOTE=final,biggestNumber\nPARENT_EXT_PROMOTE=.jpg,.png,.jpeg,.psd\n</code></pre> <p>The split on <code>[\"_\", \"~\", \".\"]</code> extracts <code>portrait</code> from all files. <code>final</code> in the promote list ensures <code>portrait_final.jpg</code> is the parent. The <code>biggestNumber</code> fallback handles versioned files (<code>_2</code> &gt; <code>_1</code>) when no <code>final</code> file exists. The large time delta (24 hours) accommodates files created across editing sessions.</p> <p><code>biggestNumber</code> limitation</p> <p><code>biggestNumber</code> requires pure numeric suffixes (e.g., <code>_1</code>, <code>_2</code>). Files named <code>_v1</code>, <code>_v2</code> will fall back to alphabetical ordering.</p> <p>To put the PSD on top instead (useful if you primarily work in Photoshop):</p> <pre><code>PARENT_EXT_PROMOTE=.psd,.jpg,.png,.jpeg\n</code></pre>"},{"location":"how-to/real-world-examples/#aperturelightroom-vault-with-photoshop-edits","title":"Aperture/Lightroom Vault with Photoshop Edits","text":"<p>Problem: You migrated from Aperture or Lightroom and have a mix of RAW, JPEG, and Photoshop files with various naming conventions:</p> <ul> <li><code>IMG_1234.CR2</code> (original RAW)</li> <li><code>IMG_1234.jpg</code> (original JPEG)</li> <li><code>IMG_1234-Edit.psd</code> (Photoshop edit)</li> <li><code>IMG_1234-Edit.jpg</code> (exported from Photoshop)</li> </ul> <p>You want all four grouped with the exported edit on top.</p> <p>Solution: Add <code>-</code> to the split delimiters:</p> <pre><code>CRITERIA='[{\"key\":\"originalFileName\",\"split\":{\"delimiters\":[\"-\",\"~\",\".\"],\"index\":0}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":86400000}}]'\nPARENT_FILENAME_PROMOTE=edit,cover,crop,hdr,biggestNumber\nPARENT_EXT_PROMOTE=.jpg,.png,.jpeg,.heic,.psd,.dng,.cr2\n</code></pre> <p>This puts <code>IMG_1234-Edit.jpg</code> on top (contains \"edit\" + has <code>.jpg</code> extension priority over <code>.psd</code>).</p>"},{"location":"how-to/real-world-examples/#burst-photos","title":"Burst Photos","text":""},{"location":"how-to/real-world-examples/#camera-bursts-with-shared-timestamp","title":"Camera Bursts with Shared Timestamp","text":"<p>Problem: Some cameras embed a shared timestamp in burst filenames:</p> <ul> <li><code>DSCPDC_0000_BURST20180828114700954.JPG</code></li> <li><code>DSCPDC_0001_BURST20180828114700954.JPG</code></li> <li><code>DSCPDC_0002_BURST20180828114700954.JPG</code></li> <li><code>DSCPDC_0003_BURST20180828114700954_COVER.JPG</code></li> </ul> <p>You want them grouped into one stack with the cover shot on top.</p> <p>Solution: Use a regex to extract the shared BURST timestamp for grouping, and <code>sequence</code> for ordering:</p> <pre><code>CRITERIA='[{\"key\":\"originalFileName\",\"regex\":{\"key\":\"BURST(\\\\d+)\",\"index\":1}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":1000}}]'\nPARENT_FILENAME_PROMOTE=cover,sequence\n</code></pre> <p>The regex extracts <code>20180828114700954</code> from all four files, grouping them. The <code>cover</code> keyword promotes the <code>_COVER</code> file as parent. The <code>sequence</code> keyword orders the rest numerically.</p>"},{"location":"how-to/real-world-examples/#sequential-burst-photos-with-common-prefix","title":"Sequential Burst Photos with Common Prefix","text":"<p>Problem: Your camera names bursts as <code>photo_0001.jpg</code>, <code>photo_0002.jpg</code>, <code>photo_0003.jpg</code>. They share a common prefix but have different sequence numbers.</p> <p>Solution: Use a regex to extract the common prefix for grouping, then <code>sequence</code> to control parent order:</p> <pre><code>CRITERIA='[{\"key\":\"originalFileName\",\"regex\":{\"key\":\"^(.+?)_\\\\d+\\\\.\",\"index\":1}},{\"key\":\"localDateTime\",\"delta\":{\"milliseconds\":3000}}]'\nPARENT_FILENAME_PROMOTE=sequence,cover,edit,crop,hdr\n</code></pre> <p>The regex extracts <code>photo</code> from all three files, grouping them together. The <code>sequence</code> keyword sorts the stack by the numeric portion, making the first in sequence the parent.</p> <p>Important</p> <p>The <code>sequence</code> keyword controls parent selection order within an already-grouped stack. It does not affect grouping itself. The regex criterion is what makes the files group together.</p>"},{"location":"how-to/real-world-examples/#limitation-fully-sequential-filenames","title":"Limitation: Fully Sequential Filenames","text":"<p>Photos with completely different base filenames (e.g., <code>IMG_1234.jpg</code>, <code>IMG_1235.jpg</code>, <code>IMG_1236.jpg</code>) cannot be reliably grouped by filename since no shared portion can be extracted. Apple iPhone bursts fall into this category as they rely on EXIF BurstUUID metadata, which is not available through the Immich API.</p>"},{"location":"how-to/real-world-examples/#parent-selection-control","title":"Parent Selection Control","text":""},{"location":"how-to/real-world-examples/#always-show-processed-files-on-top-lightroom-behavior","title":"Always Show Processed Files on Top (Lightroom Behavior)","text":"<p>Problem: You want processed files (JPEG, PNG, HEIC) always displayed as the stack representative, with RAW files accessible but hidden behind them.</p> <p>Solution:</p> <pre><code>PARENT_EXT_PROMOTE=.jpg,.png,.jpeg,.heic,.dng,.cr2,.cr3,.nef,.arw,.raf,.orf,.rw2\n</code></pre> <p>List processed formats first. RAW formats at the end means they'll never be chosen as parent when a processed file exists.</p>"},{"location":"how-to/real-world-examples/#always-show-raw-on-top","title":"Always Show RAW on Top","text":"<p>Problem: You primarily work with RAW files and want them as the stack representative.</p> <p>Solution:</p> <pre><code>PARENT_EXT_PROMOTE=.dng,.cr2,.cr3,.nef,.arw,.raf,.orf,.rw2,.jpg,.png,.jpeg\n</code></pre>"},{"location":"how-to/real-world-examples/#prefer-edited-files-on-top","title":"Prefer Edited Files on Top","text":"<p>Problem: You have edited versions alongside originals and want the edit to always be the stack parent.</p> <p>Solution:</p> <pre><code>PARENT_FILENAME_PROMOTE=final,edit,crop,hdr,cover,biggestNumber\n</code></pre> <p>Files containing \"final\" get highest priority, then \"edit\", etc.</p>"},{"location":"how-to/real-world-examples/#mixed-camera-setups","title":"Mixed Camera Setups","text":""},{"location":"how-to/real-world-examples/#multiple-cameras-with-different-naming","title":"Multiple Cameras with Different Naming","text":"<p>Problem: You shoot with both a Pixel phone and a Canon DSLR. Pixel files are <code>PXL_*.jpg</code> + <code>PXL_*.dng</code>, Canon files are <code>IMG_*.JPG</code> + <code>IMG_*.CR2</code>. You want both sets to stack correctly.</p> <p>Solution: Default configuration handles both since it groups by filename before extension + timestamp. Both naming patterns work with the default <code>split</code> on <code>\".\"</code>.</p> <p>For explicit camera-aware grouping with an OR expression:</p> <pre><code>CRITERIA='{\n    \"mode\": \"advanced\",\n    \"expression\": {\n        \"operator\": \"AND\",\n        \"children\": [\n            {\n                \"operator\": \"OR\",\n                \"children\": [\n                    {\n                        \"criteria\": {\n                            \"key\": \"originalFileName\",\n                            \"regex\": {\"key\": \"^(PXL_\\\\d+_\\\\d+)\", \"index\": 1}\n                        }\n                    },\n                    {\n                        \"criteria\": {\n                            \"key\": \"originalFileName\",\n                            \"regex\": {\"key\": \"^(IMG_\\\\d+)\", \"index\": 1}\n                        }\n                    },\n                    {\n                        \"criteria\": {\n                            \"key\": \"originalFileName\",\n                            \"split\": {\"delimiters\": [\"~\", \".\"], \"index\": 0}\n                        }\n                    }\n                ]\n            },\n            {\n                \"criteria\": {\n                    \"key\": \"localDateTime\",\n                    \"delta\": {\"milliseconds\": 1000}\n                }\n            }\n        ]\n    }\n}'\n</code></pre> <p>The OR expression tries Pixel naming first, then Canon, then falls back to generic split. The AND with <code>localDateTime</code> ensures time proximity.</p>"},{"location":"how-to/real-world-examples/#docker-compose-full-example","title":"Docker Compose Full Example","text":"<p>A complete <code>docker-compose.yml</code> for Pixel RAW+JPEG with edited file promotion:</p> <pre><code>services:\n  immich-stack:\n    image: majorfi/immich-stack:latest\n    environment:\n      - API_KEY=your_immich_api_key\n      - API_URL=http://immich-server:2283/api\n      - RUN_MODE=cron\n      - CRON_INTERVAL=3600\n      - PARENT_EXT_PROMOTE=.jpg,.png,.jpeg,.heic,.dng\n      - PARENT_FILENAME_PROMOTE=cover,edit,crop,hdr,biggestNumber\n      - LOG_LEVEL=info\n    restart: unless-stopped\n</code></pre>"},{"location":"integration/docker-compose/","title":"Docker Compose Integration","text":""},{"location":"integration/docker-compose/#basic-configuration","title":"Basic Configuration","text":"<pre><code>version: \"3.8\"\n\nservices:\n  immich-stack:\n    container_name: immich_stack\n    # Use Docker Hub image (recommended for Portainer)\n    image: majorfi/immich-stack:main # or :latest after next release\n    # Or use GitHub Container Registry\n    # image: ghcr.io/majorfi/immich-stack:latest\n    environment:\n      - API_KEY=${API_KEY} # Can be a single key or comma-separated for multiple users\n      - API_URL=${API_URL:-http://immich-server:2283/api}\n      - DRY_RUN=${DRY_RUN:-false}\n      - RESET_STACKS=${RESET_STACKS:-false}\n      - CONFIRM_RESET_STACK=${CONFIRM_RESET_STACK}\n      # Note: RESET_STACKS requires RUN_MODE=once; it will error in cron mode\n      - REPLACE_STACKS=${REPLACE_STACKS:-false}\n      - PARENT_FILENAME_PROMOTE=${PARENT_FILENAME_PROMOTE:-edit}\n      - PARENT_EXT_PROMOTE=${PARENT_EXT_PROMOTE:-.jpg,.dng}\n      - WITH_ARCHIVED=${WITH_ARCHIVED:-false}\n      - WITH_DELETED=${WITH_DELETED:-false}\n      - RUN_MODE=${RUN_MODE:-once}\n      - CRON_INTERVAL=${CRON_INTERVAL:-86400}\n      # Logging configuration (optional)\n      - LOG_LEVEL=${LOG_LEVEL:-info} # Options: trace, debug, info, warn, error\n      - LOG_FORMAT=${LOG_FORMAT:-text} # Options: text, json\n      - LOG_FILE=${LOG_FILE} # Set to /app/logs/immich-stack.log to enable file logging\n      - CRITERIA=${CRITERIA}\n    volumes:\n      - ./logs:/app/logs # Required if using LOG_FILE for persistent logging\n    restart: on-failure\n</code></pre>"},{"location":"integration/docker-compose/#integration-with-immich-docker-compose","title":"Integration with Immich Docker Compose","text":"<p>To integrate with an existing Immich installation:</p> <ol> <li> <p>Copy the <code>immich-stack</code> service from our <code>docker-compose.yml</code> into your Immich's <code>docker-compose.yml</code></p> </li> <li> <p>Add these environment variables to your Immich's <code>.env</code> file (you can also add the optional ones):</p> </li> </ol> <pre><code># Immich Stack settings\nAPI_KEY=your_immich_api_key\nAPI_URL=http://immich-server:2283/api  # Use internal Docker network\nRUN_MODE=once  # Options: once, cron\nCRON_INTERVAL=86400  # in seconds, only used if RUN_MODE=cron\n</code></pre> <ol> <li>Add the service dependency in Immich's <code>docker-compose.yml</code>:</li> </ol> <pre><code>immich-stack:\n  container_name: immich_stack\n  image: ghcr.io/majorfi/immich-stack:latest\n  environment:\n    - API_KEY=${API_KEY}\n  - API_URL=${API_URL:-http://immich-server:2283/api}\n  - DRY_RUN=${DRY_RUN:-false}\n  - RESET_STACKS=${RESET_STACKS:-false}\n  - CONFIRM_RESET_STACK=${CONFIRM_RESET_STACK}\n   # Note: RESET_STACKS requires RUN_MODE=once; it will error in cron mode\n  - REPLACE_STACKS=${REPLACE_STACKS:-false}\n  - PARENT_FILENAME_PROMOTE=${PARENT_FILENAME_PROMOTE:-edit}\n  - PARENT_EXT_PROMOTE=${PARENT_EXT_PROMOTE:-.jpg,.dng}\n  - WITH_ARCHIVED=${WITH_ARCHIVED:-false}\n  - WITH_DELETED=${WITH_DELETED:-false}\n  - RUN_MODE=${RUN_MODE:-once}\n    - CRON_INTERVAL=${CRON_INTERVAL:-86400}\n    # Logging configuration (optional)\n    - LOG_LEVEL=${LOG_LEVEL:-info}\n    - LOG_FORMAT=${LOG_FORMAT:-text}\n    - LOG_FILE=${LOG_FILE}  # Set to /app/logs/immich-stack.log for file logging\n    - CRITERIA=${CRITERIA}\n  volumes:\n    - ./logs:/app/logs  # Required if using LOG_FILE\n  restart: on-failure\n  depends_on:\n    immich-server:\n      condition: service_healthy\n</code></pre> <ol> <li>Restart your Immich stack:</li> </ol> <pre><code>docker compose down\ndocker compose up -d\n</code></pre>"},{"location":"integration/docker-compose/#logging-configuration","title":"Logging Configuration","text":""},{"location":"integration/docker-compose/#viewing-logs","title":"Viewing Logs","text":"<p>To view logs from the container:</p> <pre><code># Real-time logs\ndocker logs -f immich_stack\n\n# Last 100 lines\ndocker logs --tail 100 immich_stack\n</code></pre>"},{"location":"integration/docker-compose/#file-logging","title":"File Logging","text":"<p>By default, logs only appear in <code>docker logs</code>. To enable persistent file logging:</p> <ol> <li>Set the <code>LOG_FILE</code> environment variable in your <code>.env</code>:</li> </ol> <pre><code>LOG_FILE=/app/logs/immich-stack.log\n</code></pre> <ol> <li>Ensure the volume mount exists in docker-compose.yml:</li> </ol> <pre><code>volumes:\n  - ./logs:/app/logs\n</code></pre> <ol> <li> <p>Logs will now be written to both:</p> </li> <li> <p>Container stdout (viewable with <code>docker logs</code>)</p> </li> <li>The file <code>./logs/immich-stack.log</code> on your host</li> </ol>"},{"location":"integration/docker-compose/#log-levels-and-formats","title":"Log Levels and Formats","text":"<p>Adjust logging verbosity and format:</p> <pre><code># Debug level for troubleshooting\nLOG_LEVEL=debug\n\n# JSON format for log aggregation tools\nLOG_FORMAT=json\n</code></pre> <p>Note: Without <code>LOG_FILE</code> set, the <code>/app/logs</code> directory will remain empty even if mounted.</p>"},{"location":"integration/docker/","title":"Docker Integration","text":""},{"location":"integration/docker/#quick-start","title":"Quick Start","text":"<p>Run Immich Stack using Docker:</p> <pre><code># Create a .env file\ncat &gt; .env &lt;&lt; EOL\nAPI_KEY=your_immich_api_key\nAPI_URL=http://immich-server:2283/api\nRUN_MODE=cron\nCRON_INTERVAL=60\nEOL\n\n# Run with Docker Hub\ndocker run -d --name immich-stack --env-file .env -v ./logs:/app/logs majorfi/immich-stack:latest\n\n# Or using GitHub Container Registry\ndocker run -d --name immich-stack --env-file .env -v ./logs:/app/logs ghcr.io/majorfi/immich-stack:latest\n</code></pre>"},{"location":"integration/docker/#image-sources","title":"Image Sources","text":"<p>Immich Stack is available from two container registries:</p> <ol> <li>Docker Hub (recommended for Portainer):</li> </ol> <pre><code>docker pull majorfi/immich-stack:latest\n</code></pre> <ol> <li>GitHub Container Registry:</li> </ol> <pre><code>docker pull ghcr.io/majorfi/immich-stack:latest\n</code></pre>"},{"location":"integration/docker/#container-configuration","title":"Container Configuration","text":""},{"location":"integration/docker/#environment-variables","title":"Environment Variables","text":"<p>All configuration is done through environment variables. See Environment Variables for details.</p>"},{"location":"integration/docker/#volumes","title":"Volumes","text":"<p>The container uses one volume:</p> <ul> <li><code>/app/logs</code>: For storing log files (only used when <code>LOG_FILE</code> is set)   <pre><code>-v ./logs:/app/logs\n</code></pre></li> </ul> <p>Note: The <code>/app/logs</code> directory will remain empty unless you set the <code>LOG_FILE</code> environment variable. Without it, logs only appear in <code>docker logs</code>.</p>"},{"location":"integration/docker/#network","title":"Network","text":"<p>When running with Immich, use the same Docker network:</p> <pre><code>--network immich_default\n</code></pre>"},{"location":"integration/docker/#building-locally","title":"Building Locally","text":"<p>Build the Docker image locally:</p> <pre><code># Clone the repository\ngit clone https://github.com/majorfi/immich-stack.git\ncd immich-stack\n\n# Build the image\ndocker build -t immich-stack .\n\n# Run the container\ndocker run -d \\\n  --name immich-stack \\\n  --env-file .env \\\n  -v ./logs:/app/logs \\\n  immich-stack\n</code></pre>"},{"location":"integration/docker/#container-management","title":"Container Management","text":""},{"location":"integration/docker/#view-logs","title":"View Logs","text":"<pre><code># View logs\ndocker logs immich-stack\n\n# Follow logs\ndocker logs -f immich-stack\n\n# View last 100 lines\ndocker logs --tail 100 immich-stack\n</code></pre>"},{"location":"integration/docker/#file-logging","title":"File Logging","text":"<p>To enable persistent file logging:</p> <ol> <li>Add <code>LOG_FILE</code> to your <code>.env</code>:</li> </ol> <pre><code>LOG_FILE=/app/logs/immich-stack.log\n</code></pre> <ol> <li>Mount the logs volume:</li> </ol> <pre><code>-v ./logs:/app/logs\n</code></pre> <ol> <li> <p>Logs will be written to both:</p> </li> <li> <p>Container stdout (viewable with <code>docker logs</code>)</p> </li> <li>The file <code>./logs/immich-stack.log</code> on your host</li> </ol>"},{"location":"integration/docker/#log-configuration","title":"Log Configuration","text":"<p>Control log verbosity and format:</p> <pre><code># Debug logging\nLOG_LEVEL=debug\n\n# JSON format for structured logging\nLOG_FORMAT=json\n\n# Enable file logging\nLOG_FILE=/app/logs/immich-stack.log\n</code></pre>"},{"location":"integration/docker/#stop-container","title":"Stop Container","text":"<pre><code>docker stop immich-stack\n</code></pre>"},{"location":"integration/docker/#remove-container","title":"Remove Container","text":"<pre><code>docker rm immich-stack\n</code></pre>"},{"location":"integration/docker/#update-container","title":"Update Container","text":"<pre><code># Pull new image\ndocker pull majorfi/immich-stack:latest\n\n# Stop and remove old container\ndocker stop immich-stack\ndocker rm immich-stack\n\n# Run new container\ndocker run -d \\\n  --name immich-stack \\\n  --env-file .env \\\n  -v ./logs:/app/logs \\\n  majorfi/immich-stack:latest\n</code></pre>"},{"location":"integration/docker/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Version Pinning:</p> </li> <li> <p>Use specific versions in production</p> </li> <li> <p>Test new versions before updating</p> </li> <li> <p>Resource Limits:</p> </li> <li> <p>Set memory limits for large libraries</p> </li> <li> <p>Monitor container resource usage</p> </li> <li> <p>Backup:</p> </li> <li> <p>Backup your <code>.env</code> file</p> </li> <li> <p>Consider backing up logs</p> </li> <li> <p>Security:</p> </li> <li> <p>Use Docker secrets for sensitive data</p> </li> <li>Restrict container capabilities</li> <li>Use non-root user</li> </ol>"}]}